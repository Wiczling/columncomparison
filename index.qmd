---
title: "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling"
author: "Paweł Wiczling, Agnieszka Kamedulska"
adress: "Department of Biopharmaceutics and Pharmacodynamics, Medical University of Gdańsk, Gen. J. Hallera 107, 80-416 Gdańsk, Poland"
date: "`r format(Sys.Date())`"
format:
  html:
    theme: cosmo
    toc: true
    code-fold: true
    code-tools: true
    fig-width: 7
    fig-height: 7
---

```{r setuphtml, include=FALSE}
knitr::opts_chunk$set(cache=TRUE, message=FALSE, error=FALSE, warning=FALSE, comment=NA, out.width='95%')
```

# Introduction

In this work we applied the previously developed Bayesian multilevel framework [@kamedulska_toward_2022,] [@kamedulska_statistical_2022,] [@wiczling_application_2021,] [@kubik_analysis_2018] to characterize chromatographic gradient retention time datasets collected using a multicomponent mixtures of analytes, five stationary phases, and a wide range of chromatographic conditions (pH, organic modifier, temperature, gradient program). Such datasets carry much information about chromatographic retention that, if extracted, can provide useful predictive information, i.e. a detailed multidimensional characterization of chromatographic stationary phases and ability to predict retention (along with uncertainty) based on various number of preliminary experiments (e.g. to predict retention time for a set of analytes given no, or several measurements collected using a different stationary phase).

In this case study, we compared five RP-HPLC stationary phases (XBridge Shield RP18, XTerra MS C18, XBridge Phenyl, XBridge C8, Xterra MS C8) based on LC-MS/TOF data.

# Experimental design

The data was collected using a mixture of 300 analytes and 84 gradient liquid chromatography experiments for each column. The experiments differed in gradient duration (30, 90, and 270 min) and pH of the mobile phase (from 2.5 to 10.5). Experiments were conducted in MeOH or ACN as organic modifiers and at two temperatures ($\small 25^0C$ and $\small 35^0C$).

The molecular structure of the analytes was converted from SMILE format to MDL mol format using OpenBabel. The input molecules were then analyzed for the presence of approximately 204 functional groups and structural elements using Checkmol (version 0.5b N. Haider, University of Vienna, 2003-2018). Functional groups that were not present on any analyte and functional groups merging other simpler functional groups were excluded from the analysis. The lipophilicity (ACD log P), dissociation constant (pKalit) were added to the dataset. They were calculated using ACD/Labs program based on the structures of analytes generated from smiles strings.

# Setup

The packages we will use are listed below.

```{r setup}
library(pracma)
library(dplyr)
library(ggplot2)
require(gridExtra)
library(cmdstanr)
library(knitr)
library(reshape2)
library(bayesplot)
library(posterior)
library(GGally)
library(kableExtra)

set.seed(10271998) 
```

# Data

Data can be accessed via github (data folder) or osf.io repositories [@kubik_XBridgeC18_2022,] [@kubik_XterraC18_2022,] [@kubik_XTerraC8_2022,] [@kubik_XBridgePhenyl_2022,] [@kubik_XBridgeC8_2022].

## Prepare the data

We will begin with loading and merging the analyzed datasets:

```{r loaddata}
data1 = read.csv('data/1-X_Bridge_Shield_C18_5cm.csv')
data2 = read.csv('data/1-XTerra_MS_C18.csv')
data3 = read.csv('data/1-X_Bridge_Phenyl.csv')
data4 = read.csv('data/1-XBridge_C8.csv')
data5 = read.csv('data/1-Xterra_C8.csv')

dataNames = read.csv('data/4-compounds-names.csv')
dataACD = read.csv('data/2-ACD-pKas-logP.csv')
dataACD$R = rowSums(dataACD[,3:7]<14) # No of dissociation steps

functional_groups = read.csv('data/6-checkmol-functional-groups.csv')
functional_groups_names = read.csv('data/Legend-checkmol-functional-group-names.csv')

# marge the data:

data1['Column'] <- 1
data2['Column'] <- 2
data3['Column'] <- 3
data4['Column'] <- 4
data5['Column'] <- 5

data1['ColumnName'] <- 'XBridge Shield RP18'
data2['ColumnName'] <- 'XTerra MS C18'
data3['ColumnName'] <- 'XBridge Phenyl'
data4['ColumnName'] <- 'XBridge C8'
data5['ColumnName'] <- 'Xterra MS C8'

data = rbind(data1, data2, data3, data4, data5)

data$Mod  = as.character(data$Mod)
data$Mod2 = ifelse(data$Mod=="MeOH",1,2)   

data<-data %>% 
  left_join(select(dataACD,METID,R))
  
rm(data1, data2, data3, data4, data5)
```

The data requires some cleaning:

1.  we remove measurements with low score, analytes with less than 42 measurements per column, analytes with less than 210 measurements out of total 420, and use only measurements with the highest score (if several are present),

```{r cleaning1}
data <- data  %>%
  subset(Score>95) %>%
  group_by(METID,EXPID,Column) %>%
  slice(which.max(Score)) %>%
  group_by(METID,Column) %>%
  add_count() %>%
  subset(n>42) %>%
  group_by(METID) %>%
  add_count() %>%
  subset(nn>210) %>%
  select(-n,-nn) %>%
  ungroup()
```

2.  we remove some outlying measurements (mismatch between literature pKa and observed data),

```{r cleaning2}
data <- data %>%  
  subset(METID!=72) %>%  # dilevalol is repeated in the dataset
  subset(!(tg==270 & Temp==25 & Mod2==1 & pH==5)) %>% 
  subset(!(tg==270 & Temp==25 & Mod2==1 & pH==9)) %>% 
  subset(R<=2) %>%
   subset(!(METID %in% c(11,91,154,204,227,274,102,235,131,158,257,138,281,248,110,135,78,201,264,31,293,8,25,176,246)))%>%
  select(-R)

```

3.  we also prepare several predictors: pKa, logP and functional_groups,

```{r cleaning3}
pKaslit = dataACD[,3:7]           # pKa values as predicted by ACD
pKasliterror = dataACD[,25:29]    # pKa error as predicted by ACD
chargesA = abs(dataACD[,13:18])   # number of ionized groups (anions)
chargesB = abs(dataACD[,19:24])   # number of ionized groups (cations)
charges = chargesA+chargesB                         # absolute charge
groupsA = (chargesA[,2:5] - chargesA[,1:4])         # acidic group
groupsB = -(chargesB[,2:5] - chargesB[,1:4])        # basic group
R = dataACD$R                      # number of dissociation steps
groups = groupsB-groupsA
logPobs = dataACD$logP 

functional_groups=functional_groups[,2:ncol(functional_groups)]

# combine nr of caroboxylic acid and carboxyalic acid salt functional groups
# heterocyclic compounds with more than 6 heterocycles are treated as if they have six
functional_groups[,76]=functional_groups[,76]+functional_groups[,77]       
functional_groups[which(functional_groups[,202]>5.5),202] = 6; 

# exclude some functional groups
idx_included <- c(4,5,9,11,14,18,19,20,21,24,26,29,30,31,32,33,34,38,39,40,41,45,49,50,52,53,54,56,57,59,63,64,68,69,70,71,76,78,79,81,82,83,84,85,88,90,106,108,113,114,115,127,131,133,137,138,150,164,166,167)
functional_groups_names <- functional_groups_names[idx_included,]
functional_groups <- functional_groups[,idx_included]

rm(idx_included)
```

4.  finally, we select only analytes with \<=2 dissociation steps.

```{r cleaning4}
maxR <- 2         
idx <- which(dataACD$METID %in% data$METID)
 # max two dissociation steps        
pKaslit <- pKaslit[idx,1:maxR]           # pKa values as predicted by ACD
pKasliterror <- pKasliterror[idx,1:maxR] # pKa error as predicted by ACD
chargesA <- chargesA[idx,1:(maxR+1)]     # number of ionized groups (anions)
chargesB <- chargesB[idx,1:(maxR+1)]     # number of ionized groups (cations)
charges <- charges[idx,1:(maxR+1)]       # absolute charge
groupsA <- groupsA[idx,1:maxR]           # acidic group
groupsB <- groupsB[idx,1:maxR]           # basic group
R <- R[idx]                              # number of dissociation steps
logPobs <- logPobs[idx]                 # logP
nrfungroups=functional_groups[idx,]
totalnrgroups <- summarise_each(nrfungroups, funs(sum))

# remove functional groups not present in the dataset:
nrfungroups <- nrfungroups[,which(totalnrgroups!=0)]
functionalgroupsnames<- functional_groups_names[which(totalnrgroups!=0),]
totalnrgroups <- summarise_each(nrfungroups, funs(sum))
K <- ncol(nrfungroups)

# identify acidic groups
idxGroupsA <-which(groupsA!=0,arr.ind = T)
nGroupsA <- nrow(idxGroupsA)
pKaslitA<-pKaslit[idxGroupsA]

# identify basic groups
idxGroupsB <-which(groupsB!=0,arr.ind = T)
nGroupsB <- nrow(idxGroupsB)
pKaslitB<-pKaslit[idxGroupsB]

# groups dissociated in the whole pH range

idxB = which(chargesB[,3]==1)
idxA = which(chargesA[,1]==1)

nObs <- length(data$METID)
nAnalytes <- length(unique(data$METID))
nColumns<-length(unique(data$Column))
                
#  variables used later to annotate graphs legend
temp.labs <- c("25\u00b0C","35\u00b0C")
names(temp.labs) <- c('25','35')

mod.labs <- c("ACN","MeOH")
names(mod.labs) <- c('2','1')

col.labs <- c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8")
names(col.labs) <- c('1','2','3','4','5')

diss.labs <- c("r=1","r=2","r=3")
names(diss.labs) <- c('1','2','3')

```

## Exploratory data analysis

During the exploratory data analysis phase, we create a series of plots to better understand our data.

### Plots

The following plots present retention time profiles for 6 analytes:

1.  acridine (monoprotic acid)
2.  baclofen (zwitterion: acidic and basic group)
3.  hydrocortison (neutral)
4.  pioglitazone (zwitterion: basic and acidic group)
5.  quinine (diprotic: 2 basic groups),
6.  tolbutamide (monoprotic base).

The vertical lines show ACD-based pKa values (solid line: acidic group; dotted line: basic group)

```{r rawdata}

analyte_ID_sample <- c(9,17,33,58,140,180)
#analyte_ID_sample <-unique(data$METID) # if all

idx <- which(unique(data$METID) %in% analyte_ID_sample)
groups <- groupsB-groupsA

for(i in 1:length(analyte_ID_sample)){

p <- ggplot(data[which(data$METID %in% analyte_ID_sample[i]),])+
      geom_jitter(aes(x = pHs, y = RT, color = as.factor(tg), shape=as.factor(ColumnName)), width =0.1, height=0.1)+ 
      facet_grid(Temp~Mod2, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+
      geom_vline(xintercept = pKaslit[idx[i],1],linetype=groups[idx[i],1]+2)+
      geom_vline(xintercept = pKaslit[idx[i],2],linetype=groups[idx[i],2]+2)+
      labs(title=paste(dataNames$Name[analyte_ID_sample[i]]), 
           x ="pH", y = "Retention time, min", 
           color =    "tg, min", 
           shape = 'Column')+ 
  xlim(2,11)
print(p)

ggsave(paste0("figures\\rawdata\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".png"), plot=p, width = 20, height = 20, units = "cm", dpi = 300)
ggsave(paste0("figures\\rawdata\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".pdf"), plot=p, width = 20, height = 20, units = "cm", dpi = 300)
}

```

### Summary of the data

1.  Number of identified analytes: `r nAnalytes`
2.  Number of observations: `r nObs`
3.  $\small logP$: `r round(mean(logPobs),2)` $\pm$ `r round(sd(logPobs),2)`
4.  Number of analytes with 0, 1 and 2 dissociation steps: `r tabulate(as.factor(R))`
5.  Number of acidic and basic groups: `r round(length(pKaslitA),2)` and `r round(length(pKaslitB),2)`
6.  Number of functional groups across all analytes included in the analysis:

```{r functionalgroups}
p<-totalnrgroups %>% tidyr::gather("Name", "count", 1:54)  %>% 
   ggplot(., aes(x=count, y=reorder(Name,count)))+
   geom_point()+
   labs(x="Number of functional groups", y="Functional group name")

ggsave(paste0("figures\\predictors\\", "functionalgroups", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\predictors\\", "functionalgroups", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

print(p)


```

# Methods

## Model

In this work $\small z$ = 1..`r nObs` denotes observation, $\small i$=1..`r nAnalytes` denotes analyte, $\small col$=1..5 denotes column, $\small m$=1..2 denotes organic modifier and $\small r$=1..$\small R[i]$ denotes dissociation step for $\small i$-th analyte. The observed retention times ($\small t_{Robs,z}$) were described using the following model:

$$
t_{Robs,z} \sim student_t(\nu, t_{R,z} ,\sigma_{col[z],i[z]})
$$

where z denotes z-th observation and student_t denotes the Student's t-distribution with the mean given by the predicted retention time $\small t_{R,z}$, scale $\small \sigma_{col,i}$ (analyte and column-specific), and normality parameter $\small \nu$ (set to 3).

Gradient retention time $\small t_{R,z}$ was calculated utilizing the well-known integral equation:

$$
\int_0^{t_{R,z}-t_{0,z}-t_e}\frac{dt}{t_{0,z}\cdot ki_z(t) }=1,
$$

where $\small ki_z(t)$ denotes instantaneous isocratic retention factor corresponding to the mobile phase composition at time t at column inlet for analyte and chromatographic conditions corresponding to the z-th observation, $\small t_{0,z}$ denotes column hold-up (dead) time and $\small t_e$ denotes extra column-time. The numerical solution of this integral equation was carried out using method of steps with 4 and 10 steps for methanol and acetonitrile gradients using method proposed by Nikitas et al. [@nikitas_new_2002] The following function described the relationship between the isocratic retention factor and pH for an i-th analyte with $\small R[i]$ dissociation steps and $\small R[i]+1$ forms.

$$
ki_z(t)=\frac{k_{z,i[z],1}(t)+\sum_{r=1}^{R[i[z]]} k_{z,i[z],r+1}(t) \cdot 10^{r\cdot pH_z(t)-\sum_{r=1}^{R[i]} pKa_{z,i[z],r}(t)} }{1+\sum_{r=1}^R 10^{r\cdot pH_z(t)-\sum_{r=1}^{R[i[z]]} pKa_{z,i[z],r}(t) } }
$$

$\small log(k_{z,i,r})$ was assumed to depend on the organic modifier content based on the Neue equation, on temperature assuming linear equation, and on the pH of the mobiles phase (for ionized forms of analytes).

$$
\begin{aligned}
& log(k_{z,i,r}(t)) = logkw_{col[z],i,r} - \frac{S1_{m[z],col[z],i,r} \cdot (1+S2_{m[z]}) \cdot \varphi_z(t)}{1+S2_{m[z]} \cdot \varphi_z(t)} + ... \\ 
& apH_{col[z],m[z],i,r} \cdot (pH_z(t)-7) + dlogkT_{col[z],i} \cdot (T_z-25)/10
\end{aligned}
$$

where $\small logkw_{col,i,r}$ represents logarithm of retention factors extrapolated to 0% of organic modifier content for column $\small col$, $\small i$-th analyte and $\small r$-th analyte form; $\small S1_{i,m,col,r}$ and $\small S2_m$ are the slopes in the Neue equation for column $\small col$, modifier $\small m$, $\small i$-th analyte and $\small r$-th analyte form. In this parametrization of the Neue equation, $\small S1$ reflects the difference between logarithm of retention factors corresponding to water (0% of organic modifier content) and MeOH or ACN (100% of organic modifier content) as eluents. $\small dlogkT_{col,i}$ denotes the change in $\small logkw$ due to the increase in temperature by $\small 10^oC$. $\small apH_{col,m,i,r}$ denotes the pH effects on $\small logkw$ for ionized forms of analyte.

Further we assume a linear relationship between $\small pKa$ values and the organic modifier content:

$$
pKa_{z,i,r}(t)=pKaw_{i,r}+\alpha_{m[z],i,r}\cdot\varphi_z(t)
$$

where $\small pKa_{z,i,r}(t)$ denotes dissociation constant of an $\small i$-th analyte and $\small r$-th dissociation step form and chromatographic conditions corresponding the z-th observation, $\small pKaw_{i,r}$ denotes aqueous $\small pKa$, and $\alpha_{m,i,r}$ denotes the slope for $\small m$-th modifier, $\small i$-th analyte and $\small r$-th form. The linear relationships is generally valid for $\small \varphi$ \< 0.8.

The relationship between pH and the organic modifier content for various combinations of organic modifier and buffer was experimentally determined prior to the chromatographic analysis. The obtained relationships was then described using quadratic equations for each nominal pH, temperature and organic modifier:

$$
pH_z(t)=pHo_z+\alpha 1_z\cdot \varphi_z(t)+\alpha2_z\cdot {\varphi_z(t)}^2
$$

The individual values of $\small logkw$, $\small S1$ were first defined for the neutral form of an analyte in MeOH for the Xbridge Sheld RP18 column (denoted as $\small logkwN_i$ and $\small S1mN_i$). The effect of ACN was described as ($\small dS1N_i$), thus S1 in ACN equals $\small S1aN_i = S1mN_i +dS1N_i$, the effect of column ($\small c=1..4$) was described by $\small clogkwN_{c,i}$, $\small cS1mN_{c,i}$, and $\small cdS1N_{c,i}$). The individual parameters for the neutral forms were described using the following equations:

$$
\begin{aligned}
& \begin{bmatrix}
logkwN_i \\
S1mN_i\\
\end{bmatrix} \sim
MVN(\begin{bmatrix}
\hat{logkw}+\beta_1 \cdot (logP_i-2.2) \\
\hat{S1m}+\beta_2 \cdot (logP_i-2.2) \\
\end{bmatrix},  \Omega) \\
& dS1N_i \sim N(\hat{dS1}, \omega_3)\\
& \Omega =
diag(\omega_{1:2}) \cdot \begin{bmatrix}
 1 & \rho \\
 \rho & 1  \\
 \end{bmatrix} \cdot diag(\omega_{1:2}) \\
& \begin{bmatrix}
clogkwN_{1,i} \\
clogkwN_{2,i} \\
clogkwN_{3,i} \\
clogkwN_{4,i} \\
\end{bmatrix} \sim
MVN(\begin{bmatrix}
\hat{clogkw_1}+c\beta_{1,1} \cdot (logP_i-2.2) \\
\hat{clogkw_2}+c\beta_{2,1} \cdot (logP_i-2.2) \\
\hat{clogkw_3}+c\beta_{3,1} \cdot (logP_i-2.2) \\
\hat{clogkw_4}+c\beta_{4,1} \cdot (logP_i-2.2) \\
\end{bmatrix},  c\Omega) \\
& c\Omega =
diag(c\omega) \cdot \begin{bmatrix}
 1 & c\rho_{12} & c\rho_{13} & c\rho_{14} \\
  c\rho_{21} & 1 & c\rho_{23} & c\rho_{24} \\
   c\rho_{31} & c\rho_{32} & 1 & c\rho_{34} \\
   c \rho_{41} & c\rho_{42} & c\rho_{43} & 1 \\
 \end{bmatrix} \cdot diag(c\omega) \\
& cS1mN_{c,i} \sim N(\hat{cS1m}+c\beta_{c,2}\cdot (logP_i-2.2), c\omega_{c,2}) \text{ for c=1...4} \\
& cdS1N_{c,i} \sim N(\hat{cdS1_c}, c\omega_{c,3}) \text{ for c=1...4} \\
& dlogkT_{c,i} \sim N(\hat{dlogkT_c},\omega_{T,c}) \text{ for c=1...4} \\
\end{aligned}
$$

were MVN denotes the multivariate normal distribution; $\small \hat{logkw}$, $\small \hat{S1m}$, $\small \hat{dS1}$ are the mean values of individual chromatographic parameters that correspond to a typical neutral analyte with $\small logP$ =2.2 at $\small 25^oC$ for Xbridge Shield RP18 stationary phase. $\small \beta s$ are regression coefficients between the individual chromatographic parameters and the $\small logP_i$. $\small \omega$ denotes the standard deviation for between analyte variability (BAV). $\small \hat{dlogkT}$ denotes the effect of temperature for a typical analyte and $\small \omega_T$ the standard deviation for between analyte variability for temperature effects. Similar set of equations was used for column effects. Here c denoted the column effect (4 differences with respect to the reference Xbridge Shield RP18 column).

The difference in retention between the ionized form of an analyte and the neutral form of an analyte was separately estimated for acids and bases for $\small logkw$, $\small S1m$, $\small dS1$ parameters. Similar set of equations was used for column effects.

$$
\begin{aligned}
& dlogkwA_a \sim N(\hat{dlogkw_1}, \kappa_1), \\
& dlogkwB_b \sim N(\hat{dlogkw_2}, \kappa_1), \\
& dS1mA_a \sim N(\hat{dS1m_1}, \kappa_2), \\
& dS1mB_b \sim N(\hat{dS1m_2}, \kappa_2), \\
& ddS1A_a \sim N(\hat{ddS1_1}, \kappa_3), \\
& ddS1B_b \sim N(\hat{ddS1_2}, \kappa_3), \\
& cdlogkwA_{c,a} \sim N(\hat{cdlogkw_{c,1}}, c\kappa_{c,1}) \text{ for c=1...4}, \\
& cdlogkwB_{c,b} \sim N(\hat{cdlogkw_{c,2}}, c\kappa_{c,1}) \text{ for c=1...4}, \\
& cdS1mA_{c,a} \sim N(\hat{cdS1m_{c,1}}, c\kappa_{c,2}) \text{ for c=1...4}, \\
& cdS1mB_{c,b} \sim N(\hat{cdS1m_{c,2}}, c\kappa_{c,2}) \text{ for c=1...4}, \\
& cddS1A_{c,a} \sim N(\hat{cddS1_{c,1}}, c\kappa_{c,3}) \text{ for c=1...4}, \\
& cddS1B_{c,b} \sim N(\hat{cddS1_{c,2}}, c\kappa_{c,3}) \text{ for c=1...4}. \\
\end{aligned}
$$ where a=1..`r nGroupsA` and b=1..`r nGroupsB` denote the indexes of acidic and basic groups.

Similarly $\small pKa$ an $\small \alpha$ parameters were described separately for acids and based:

$$
\begin{aligned}
& pKawA_{a} \sim N(pKaAlit_{a}, \tau_1), \\
& pKawB_{b} \sim N(pKaBlit_{b}, \tau_1), \\
& \alpha mA_{a} \sim N(\hat{\alpha m_1},\tau_2), \\
& \alpha mB_{b} \sim N(\hat{\alpha m_2},\tau_2), \\
& d\alpha A_{a} \sim N(\hat{d\alpha_1},\tau_3), \\
& d\alpha B_{b} \sim N(\hat{d\alpha_2},\tau_3).
\end{aligned}
$$

Further, we created the matrices containing the value of $\small logkw$,$\small S1$,$\small S2$,$\small pKaw$, and $\small alpha$ for i-th analyte, col-th column, m-th modifier an r-th dissociation step based on the value of neutral form and effects of column, organic modifier, and dissociation. This transformation was denoted as f(.). The exact procedure can be found in the stan code.

$$
\begin{aligned}
& logkw_{col,i,r}= f(logkwN_i,clogkwN_{c,i},dlogkwA_{a},cdlogkwA_{c,a}, dlogkwB_{b}, cdlogkwB_{c,b},...) \\
& S1_{m,col,i,r}  = f(S1mN_i,cS1mN_{c,i}, dS1mA_a, cdS1mA_{c,a}, S1mB_b, cdS1mB_{c,b}, ...\\
& dS1N_i, cdS1N_{c,i}, ddS1A_a, cddS1A_{c,a}, ddS1B_b, cddS1B_{c,b},...) \\
& apH_{m,col,i,r} = f(\hat{apH_1},\hat{capH_{c,1}},\hat{apH_2},\hat{capH_{c,2}},...) \\
& S2_{m} = 10^{f(\hat{logS2m},\hat{dlogS2},...)} \\
& pKaw_{i,r} = f(pKawA_{a},pKawB_{b},...) \\
& \alpha_{m,i,r} = f(\alpha mA_{a}, d\alpha A_{a}, \alpha mB_{b}, d\alpha B_{b},...)
\end{aligned}
$$

Three dots represent additional arguments. Residual error model assumes different parameters for each column and analyte:

$$
\begin{aligned}
& log(\sigma_{col,i}) = f(log\sigma_i, clog\sigma_{c,i},...) \\
& log\sigma_i  \sim N(log(m\sigma),s\sigma) \\
& clog\sigma_{c,i} \sim N(clogm\sigma_c,cs\sigma_c) \text{ for c=1...4},
\end{aligned}
$$

The detailed description of parameters and used priors is provided in the following table (BAV denotes between analyte variability):

```{r table, results="asis"}

# to properly render in quarto: https://github.com/quarto-dev/quarto-cli/issues/3340

Name = c('$\\hat{logkw}$',
         '$\\hat{S1m}$',
         '$\\hat{dS1}$',
         '$\\beta_1$',
         '$\\beta_2$',
         '$\\hat{dlogkw_1}$',
         '$\\hat{dlogkw_2}$',
         '$\\hat{dS1m_1}$',
         '$\\hat{dS1m_2}$',
         '$\\hat{ddS1_1}$',
         '$\\hat{ddS1_2}$',
         '$\\hat{apH_1}$',
         '$\\hat{apH_2}$',
         '$\\hat{dlogkT}$',
         '$\\omega_1$',
         '$\\omega_2$',
         '$\\omega_3$',
         '$\\rho$',
         '$\\omega_T$',
         '$\\kappa_1$',
         '$\\kappa_2$',
         '$\\kappa_3$',
         '$\\hat{clogkw_c}$',
         '$\\hat{cS1m_c}$',
         '$\\hat{cdS1_c}$',
         '$c\\beta_{c,1}$',
         '$c\\beta_{c,2}$',
         '$\\hat{cdlogkw_{c,1}}$',
         '$\\hat{cdlogkw_{c,2}}$',
         '$\\hat{cdS1m_{c,1}}$',
         '$\\hat{cdS1m_{c,2}}$',
         '$\\hat{cddS1_{c,1}}$',
         '$\\hat{cddS1_{c,2}}$',
         '$\\hat{cdlogkT_c}$',
         '$capH_{c,1}$',
         '$capH_{c,2}$',
         '$c\\omega_{c,1}$',
         '$c\\rho$',
         '$c\\omega_{c,2}$',
         '$c\\omega_{c,3}$',
         '$c\\kappa_{c,1}$',
         '$c\\kappa_{c,2}$',
         '$c\\kappa_{c,3}$',
         '$c\\omega_{T,c}$',
         '$\\hat{logS2m}$',
         '$\\hat{dlogS2}$',
         '$\\hat{\\alpha m_1}$',
         '$\\hat{\\alpha m_2}$',
         '$\\hat{d\\alpha_1}$',
         '$\\hat{d\\alpha_2}$',
         '$\\tau_1$',
         '$\\tau_2$',
         '$\\tau_3$',
         '$m\\sigma$',
         '$s\\sigma$',
         '$clogmsigma_c$',
         '$c\\sigma_c$')

Namecode = c('logkwHat',
         'S1mHat',
         'dS1Hat',
         'beta[1]',
         'beta[2]',
         'dlogkwHat[1]',
         'dlogkwHat[2]',
         'dS1mHat[1]',
         'dS1mHat[2]',
         'ddS1Hat[1]',
         'ddS1Hat[2]',
         'apH[1]',
         'apH[2]',
         'dlogkTHat',
         'omega[1]',
         'omega[2]',
         'omega[3]',
         'rho',
         'omegaT',
         'kappa[1]',
         'kappa[2]',
         'kappa[3]',
         'clogkwHat[c]',
         'cS1mHat[c]',
         'cdS1Hat[c]',
         'cbeta[c,1]',
         'cbeta[c,2]',
         'cdlogkwHat[c,1]',
         'cdlogkwHat[c,2]',
         'cdS1mHat[c,1]',
         'cdS1mHat[c,2]',
         'cddS1Hat[c,1]',
         'cddS1Hat[c,2]',
         'cdlogkTHat[c]',
         'capH[c,1]',
         'capH[c,2]',
         'comega[c,1]',
         'crho',
         'comega[c,2]',
         'comega[c,3]',
         'ckappa[c,1]',
         'ckappa[c,2]',
         'ckappa[c,3]',
         'comegaT[c]',
         'logS2mHat',
         'dlogS2Hat',
         'alphamHat[1]',
         'alphamHat[2]',
         'dalphaHat[1]',
         'dalphaHat[2]',
         'tau[1]',
         'tau[2]',
         'tau[3]',
         'msigma',
         'ssigma',
         'clogmsigma[c]',
         'cssigma[c]')

Description = c('typical logkw [Neutral]',
                'effect of MeOH on logkw [Neutral]',
                'effect of ACN on S1m [Neutral]',
                'effect of logP on logkw [Neutral]',
                'effect of logP on S1m [Neutral]',
                'effect of dissociation on logkw [Acids]',
                'effect of dissociation on logkw [Bases]',
                'effect of dissociation on S1m [Acids]',
                'effect of dissociation on S1m [Bases]',
                'effect of dissociation on dS1 [Acids]',
                'effect of dissociation on dS1 [Bases]',
                'effect of pH on logkw [Acids]',
                'effect of pH on logkw [Bases]',
                'effect of temperature on logkw',
                'sd of BAV for logkw [Neutral]',
                'sd of BAV for S1 [Neutral]',
                'sd of BAV for dS1 [Neutral]',
                'correlation logkw vs S1 [Neutral]',
                'sd of BAV for dlogkT [Neutral]',
                'sd of BAV for dlogkw [Acids and Bases]',
                'sd of BAV for dS1m [Acids and Bases]',
                'sd of BAV for ddS1 [Acids and Bases]',
                'effect of column c on logkw [Neutral]',
                'effect of column c on S1m [Neutral]',
                'effect of column c on dS1 [Neutral]',
                'effect of column c on beta[1] [Neutral]',
                'effect of column c on beta[2] [Neutral]',
                'effect of column c on dlogkw [Acids]',
                'effect of column c on dlogkw [Bases]',
                'effect of column c on dS1m [Acids]',
                'effect of column c on dS1m [Bases]',
                'effect of column c on ddS1 [Acids]',
                'effect of column c on ddS1 [Bases]',
                'effect of column c on dlogkwT',
                'effect of column c on apH [Acids]',
                'effect of column c on apH [Bases]',
                'sd of BAV for clogkw [Neutral]',
                'corr beetwen clogkw [Neutral]',
                'sd of BAV for cS1 [Neutral]',
                'sd of BAV for cdS1 [Neutral]',
                'sd of BAV for cdlogkw [Acids and Bases]',
                'sd of BAV for cdS1m [Acids and Bases]',
                'sd of BAV for cddS1 [Acids and Bases]',
                'sd of BAV for dlogkT',
                'typical value of S2m (log10 scale)',
                'effect of ACN on logS2m',
                'effect of MeOH on pKa [Acids]',
                'effect of MeOH on pKa [Bases]',
                'effect of ACN on alpham [Acids]',
                'effect of ACN on alpham [Bases]',
                'sd of BAV for pKalit',
                'sd of BAV for alpham',
                'sd of BAV for dalpha',
                'typical sd of residuals for XBridge',
                'sd of BAV of residuals for XBridge',
                'effect of column c on msigma (log scale)',
                'sd of BAV of residuals for column c'
                )


Priors = c('N(2.2,2)',
         'N(4, 1)',
         'N(1, 1)',
         'N(1, 0.125)',
         'N(0.5, 0.5)',
         'N(-1, 0.125)',
         'N(-1, 0.125)',
         'N(0, 0.5)',
         'N(0, 0.5)',
         'N(0, 0.25)',
         'N(0, 0.25)',
         'N(0, 0.1)',
         'N(0, 0.1)',
         'N(-0.087, 0.022)',
         'N+(0, 2)',
         'N+(0, 2)',
         'N+(0, 2)',
         'LKJCORRN(0.75, 0.125)',
         'N+(0, 0.022)',
         'N+(0, 0.25)',
         'N+(0, 0.25)',
         'N+(0, 0.25)',
         'N(0, 1)',
         'N(0, 0.5)',
         'N(0, 0.25)',
         'N(0, 0.25)',
         'N(0, 0.25)',
         'N(0, 0.0625)',
         'N(0, 0.0625)',
         'N(0, 0.25)',
         'N(0, 0.25)',
         'N(0, 0.125)',
         'N(0, 0.125)',
         'N(0, 0.011)',
         'N(0, 0.05)',
         'N(0, 0.05)',
         'N+(0, 1)',
         'LKJ(2)',
         'N+(0, 1)',
         'N+(0, 1)',
         'N+(0, 0.125)',
         'N+(0, 0.125)',
         'N+(0, 0.125)',
         'N+(0, 0.011)',
         'N(-0.7, 0.125);',
         'N(1, 0.125);',
         'N(2, 0.25)',
         'N(-1, 0.25)',
         'N(0, 0.125)',
         'N(0, 0.125)',
         'N+(0, 0.25)',
         'N+(0, 0.125)',
         'N+(0, 0.125)',
         'N+(0,1)',
         'N(0,1)',
         'N+(0,0.125)',
         'N+(0,0.125)')

table_of_parameters = data.frame(Name,Namecode,Description,Priors)


table_of_parameters %>%
kableExtra::kbl(caption = "Desciption of model paramters", escape = FALSE, longtable=TRUE) %>%
kableExtra::kable_classic(full_width = F, html_font = "Cambria") %>%
kableExtra::kable_styling(latex_options = c("repeat_header")) %>%
 kableExtra::pack_rows("XBridge Shield RP18 parameters", 1, 22) %>%
 kableExtra::pack_rows("between column differences", 23, 44) %>%
 kableExtra::pack_rows("S2", 45, 46) %>%
 kableExtra::pack_rows("pKa", 47, 53) %>%
 kableExtra::pack_rows("Residuals", 54, 57) %>%
 unclass() %>%
 cat()
 
```

## Stan

Multilevel modeling was performed in [Stan software](https://mc-stan.org/) linked with R/ [cmdstanr](https://mc-stan.org/cmdstanr/). For the inference we used 500 iterations, 1000 warmup iterations, and 8 Markov chains. The reduce_sum function was selected to accelerate the calculations. It works by parallelizing the execution of a single Stan chain across multiple cores. Convergence diagnostics were checked using Gelman−Rubin statistics and trace plots.

### Initialize variables and parameters

```{r stansetup}
# create Stan data set:

datastruct <- with(data,
                  list(nAnalytes=length(unique(data$METID)),
                       nModifiers=length(unique(data$Mod2)),
                       nColumns=length(unique(data$Column)),
                       nObs=length(data$METID),
                       analyte=match(data$METID, unique(data$METID)),
                       modifier=match(data$Mod2, sort(unique(data$Mod2))),
                       column=match(data$Column, unique(data$Column)),
                       steps=4*(2-data$Mod2) + 10*(data$Mod2-1),
                       hplcparam=cbind(data$tg,data$td,data$to,data$te,data$fio,data$fik,data$Mod2-1,data$pHo,
                                       data$alpha1,data$alpha2,(data$Temp-25)/10,data$Column-1),
                       logPobs=logPobs, 
                       maxR=maxR,
                       R=R,
                       nGroupsA=nGroupsA,
                       nGroupsB=nGroupsB,
                       pKaslitA=pKaslitA,
                       pKaslitB=pKaslitB,
                       idxGroupsA=idxGroupsA,
                       idxGroupsB=idxGroupsB,
                       trobs=data$RT,
                       run_estimation=1))

# initialize the values for each variable in each chain:
init <- function(){
  list(   logkwHat  = rnorm(1,2.2,2),
          S1mHat    = rnorm(1,4,1),
          dS1Hat    = rnorm(1,1,0.5),
          dlogkwHat = rnorm(2,-1,0.125),
          dS1mHat   = rnorm(2,0,0.5),
          ddS1Hat   = rnorm(2,0,0.25),
          logS2mHat = rnorm(1,-0.7,0.125),
          dlogS2Hat = rnorm(1,1,0.125),
          beta  = rnorm(2,c(1,0.5),c(0.125,0.5)),
          dlogkTHat    = rnorm(1,-0.087,0.0022),
          apH  = rnorm(2,0,0.1),
          alphamHat  = rnorm(2,c(2,-1),0.25),
          dalphaHat = rnorm(2,0,0.125),
          tau   = c(0.25,0.125,0.125)*exp(rnorm(3, 0, 0.2)),
          omega = c(1,1,1)*exp(rnorm(3, 0, 0.5)),
          rho = matrix(c(1, 0.75, 0.75, 1), nrow=2),
          omegaT  = rlnorm(1,log(0.022),0.2), 
          kappa = 0.25* exp(rnorm(3, 0, 0.2)),
          
          clogkwHat  =  rnorm(nColumns-1,0,1),
          cS1mHat  =  rnorm(nColumns-1,0,0.5),
          cdS1Hat  =  rnorm(nColumns-1,0,0.25),
          cdlogkwHat = matrix(rnorm(2*(nColumns-1),0,0.0625),nrow=(nColumns-1)),
          cdS1mHat = matrix(rnorm(2*(nColumns-1),0,0.25),nrow=(nColumns-1)),
          cddS1Hat = matrix(rnorm(2*(nColumns-1),0,0.125),nrow=(nColumns-1)),
          cbeta  = matrix(rnorm(2*(nColumns-1),0,0.25),nrow=(nColumns-1)),
          cdlogkTHat = rnorm(nColumns-1,0,0.011),
          
          capH   = matrix(rnorm(2*(nColumns-1),0,0.05),nrow=(nColumns-1)),
          comega = 0.1 * exp(matrix(rnorm(3*(nColumns-1),0,1),nrow=(nColumns-1))),
          ckappa = 0.1 * exp(matrix(rnorm(3*(nColumns-1),0,0.125),nrow=(nColumns-1))),
          comegaT = 0.1 * exp(matrix(rnorm(1*(nColumns-1),0,0.011),nrow=(nColumns-1))),
          corr_L = diag(nColumns-1),
          paramN =  cbind(2+0.75*(logPobs-2.2), 4*matrix(1,nAnalytes,1)+0.5*(logPobs-2.2)),
          dS1N   =  matrix(0,nAnalytes,1),
          dlogkT = rnorm(nAnalytes,-0.0868,0.0217),
          dlogkwA = matrix(-1,nGroupsA,1),
          dlogkwB = matrix(-1,nGroupsB,1),
          dS1mA = matrix(0,nGroupsA,1),
          dS1mB = matrix(0,nGroupsB,1),
          dS1A = matrix(0,nGroupsA,1),
          dS1B = matrix(0,nGroupsB,1),
          
          etaclogkwNStd = matrix(0,nColumns-1,nAnalytes),
          etacS1mN = matrix(0,nColumns-1,nAnalytes),
          etacdS1N = matrix(0,nColumns-1,nAnalytes),
          etacdlogkT = matrix(0,nColumns-1,nAnalytes),
          etacdlogkwA = matrix(0,nColumns-1,nGroupsA),
          etacdlogkwB = matrix(0,nColumns-1,nGroupsB),
          etacdS1mA = matrix(0,nColumns-1,nGroupsA),
          etacdS1mB = matrix(0,nColumns-1,nGroupsB),
          etacdS1A = matrix(0,nColumns-1,nGroupsA),
          etacdS1B = matrix(0,nColumns-1, nGroupsB),
          pKawA = pKaslitA,
          pKawB = pKaslitB,
          etaalphamA = matrix(0,nGroupsA,1),
          etaalphamB = matrix(0,nGroupsB,1),
          etadalphaA = matrix(0,nGroupsA,1),
          etadalphaB = matrix(0,nGroupsB,1),
          
          msigma  = rlnorm(1,log(1),0.2),
          ssigma  = rlnorm(1,log(0.2),0.2),
          logsigma   = rnorm(nAnalytes,0,0.2),
          
          clogmsigma  = rnorm(nColumns-1,0,0.125),
          cssigma     = rlnorm(nColumns-1,log(0.125),0.125),
          etaclogsigma   = matrix(rnorm(nAnalytes*(nColumns-1),0,0.125),nrow=(nColumns-1))
          
  )
}

```

### The Stan model:

```{r stancode}
writeLines(readLines("stan/hplc-gra-fivecolumns.stan"))
```

### Fitting the model

We compiled the model using cmdstanr:

```{r stancompile, eval = FALSE}
mod1 <- cmdstan_model("stan/hplc-gra-fivecolumns.stan", 
                      stanc_options = list("O1"), 
                      cpp_options = list(stan_threads = TRUE))
# for optimization
modode <- cmdstan_model("stan/hplc-gra-fivecolumns.stan", 
                      stanc_options = list("O1"))
```

We used optimization for initial testing:

```{r stanoptimize, eval = FALSE}
fit_ode <- modode$optimize(
  data = datastruct,
  output_dir = "stanfiles",
  init = init
)

fit_ode$print(max_rows=100)
```

For local computations one can use cmdstanr:

```{r stansample, eval = FALSE}
# fit <- mod1$sample(
#   data = datastruct,
#   output_dir = "stanfiles",
#   init = init,
#   iter_warmup = 1000,
#   iter_sampling = 1000,
#   chains = 4,
#   parallel_chains = 4,
#   threads_per_chain = 6,
#   refresh = 100,
#   adapt_delta=0.9
# )
```

We performed out computations at the Academic Computer Center in Gdańsk, [Tryton Cluster](https://docs.task.gda.pl/kdm/zasoby-sprzetowe/tryton/). In this case:

1.  we dumped the necessary data to .json format

```{r dumpfiles, eval = FALSE}
write_stan_json(datastruct, "stan/standata.json", always_decimal = FALSE)
write_stan_json(init(), "stan/init-1.json", always_decimal = FALSE)
write_stan_json(init(), "stan/init-2.json", always_decimal = FALSE)
write_stan_json(init(), "stan/init-3.json", always_decimal = FALSE)
write_stan_json(init(), "stan/init-4.json", always_decimal = FALSE)
write_stan_json(init(), "stan/init-5.json", always_decimal = FALSE)
write_stan_json(init(), "stan/init-6.json", always_decimal = FALSE)
write_stan_json(init(), "stan/init-7.json", always_decimal = FALSE)
write_stan_json(init(), "stan/init-8.json", always_decimal = FALSE)
```

2.  we run the model using the batch file:

```{=html}
<pre> 
#!/bin/bash -l
#SBATCH --job-name=cmdstan_conda
#SBATCH -N 1
#SBATCH -n 24
#SBATCH -p batch
#SBATCH --time=48:00:00
#SBATCH --mem=64gb
#SBATCH --array=1-8%8

module load tryton/cmdstan/2.30.1-conda
export STAN_THREADS=true
export CMDSTAN_MODEL_NAME="hplc-gra-twocolumns"
export MODEL_SRC_DIR=${TASK_USER_WORK}
cd ${MODEL_SRC_DIR}
[ -f ${CMDSTAN_MODEL_NAME} ] && echo "Model "${CMDSTAN_MODEL_NAME}" exists" || cmdstan_model ${CMDSTAN_MODEL_NAME}
wait
${PWD}/${CMDSTAN_MODEL_NAME} sample num_samples=500 num_warmup=1000 algorithm=hmc engine=nuts max_depth=10 stepsize=0.01 adapt delta=0.9 data file=$PWD/standata.json init=$PWD/init-${SLURM_ARRAY_TASK_ID}.json  num_threads=${SLURM_NTASKS} output file=$PWD/output_${SLURM_ARRAY_TASK_ID}.csv 
</pre>
```

3.  After calculations, we loaded the output files using cmdstanr. The files are accessible through [stan output files](https://cloud.gumed.edu.pl/s/MbHmekcg79w4ot4 "Stan output files").

```{r stanload}
fit <- cmdstanr::as_cmdstan_fit(c(
                                  'stanfiles/output_1.csv',
                                  'stanfiles/output_2.csv',
                                  'stanfiles/output_3.csv',
                                  'stanfiles/output_4.csv',
                                  'stanfiles/output_5.csv',
                                  'stanfiles/output_6.csv',
                                  'stanfiles/output_7.csv',
                                  'stanfiles/output_8.csv'
                                ))
```

4.  finally we checked the diagnostics of Monte Carlo inferences based on the Stan documentation described herein [diagnose](https://mc-stan.org/docs/cmdstan-guide/diagnose.html)

```{r standiagnose, eval = FALSE}
 #fit$cmdstan_diagnose()
 setwd("stanfiles")
 str = paste0(cmdstan_path(), "/bin/diagnose  output_*.csv")
 system(str,intern=TRUE)
```

The diagnostics are reasonable given model complexity. Output copied here to save time:

```{=html}
<pre>
 [1] "Processing csv files: output_1.csv, output_2.csv, output_3.csv, output_4.csv, output_5.csv, output_6.csv, output_7.csv, output_8.csv"
 [2] ""
 [3] "Checking sampler transitions treedepth." 
 [4] "4000 of 4000 (100.00%) transitions hit the maximum treedepth limit of 10, or 2^10 leapfrog steps." 
 [5] "Trajectories that are prematurely terminated due to this limit will result in slow exploration." 
 [6] "For optimal performance, increase this limit." 
 [7] ""
 [8] "Checking sampler transitions for divergences." 
 [9] "No divergent transitions found." 
[10] ""
[11] "Checking E-BFMI - sampler transitions HMC potential energy." 
[12] "E-BFMI satisfactory."
[13] ""
[14] "Effective sample size satisfactory." 
[15] ""
[16] "The following parameters had split R-hat greater than 1.05:" 
[17] "etacdS1N[3,38], etaalphamB[92]"
[18] "Such high values indicate incomplete mixing and biased estimation."
[19] "You should consider regularizating your model with additional prior information or a more effective parameterization." 
[20] ""
[21] "Processing complete."                                                                 
</pre>
```
# Results

## Summary of model parameters (table):

The [stansummary](https://mc-stan.org/docs/cmdstan-guide/stansummary.html) function was used to report summary and diagnostic statistics over model parameters. 

```{r tblsummary}
# fit$print(max_rows=200) # for first 200 parameters

fit$print(c("logkwHat","S1mHat","dS1Hat",
            "dlogkwHat","dS1mHat","ddS1Hat",
            "logS2mHat","dlogS2Hat",
            "beta",
            "dlogkTHat","apH",
            "omega","omegaT", "kappa",
            "rho[2,1]",
            "msigma","ssigma"), max_rows = 26)

fit$print(c("alphamHat","dalphaHat",
            "tau"), max_rows = 7)

fit$print(c("clogkwHat","cS1mHat","cdS1Hat",
            "cdlogkwHat","cdS1mHat","cddS1Hat",
            "cbeta",
            "cdlogkTHat",
            "capH",
            "comega", "ckappa", "comegaT",
            "crho",
            "clogmsigma","cssigma"), max_rows = 108)

```

The summary can also be extracted for individual parameters. Here presented for analyte 9 (`r dataNames$Name[9]`)

```{r tblisummary}
# which(unique(data$METID)==9) - 3rd compound in stan
fit$print(c("logkwx[3,1,1]", "logkwx[3,1,2]", "logkwx[3,1,3]",
            "logkwx[3,2,1]", "logkwx[3,2,2]", "logkwx[3,2,3]",
                "S1x[3,1,1,1]", "S1x[3,1,1,2]", "S1x[3,1,1,3]",
                "S1x[3,2,1,1]", "S1x[3,2,1,2]", "S1x[3,2,1,3]",
                "S1x[3,1,2,1]", "S1x[3,1,2,2]", "S1x[3,1,2,3]", 
                "S1x[3,2,2,1]", "S1x[3,2,2,2]", "S1x[3,2,2,3]",
                "apHx[3,1,1]", "apHx[3,1,2]", "apHx[3,1,3]",
                "pKawx[3,1]", "pKawx[3,2]",
                "alphax[3,1,1]", "alphax[3,1,2]",
                "alphax[3,2,1]", "alphax[3,2,2]",
                "S2x[1,1]", "S2x[2,1]",
                "sigmax[3,1]", "sigmax[3,2]"), max_rows = 31)
```

```{r summary2, eval = FALSE, echo=FALSE}
 x<-fit$summary(variables = c("logkwHat","S1mHat","dS1Hat",
             "dlogkwHat","dS1mHat","ddS1Hat",
             "logS2mHat","dlogS2Hat",
             "beta",
             "alphamHat","dalphaHat",
             "dlogkTHat","apH",
             "omega","omegaT",
             "kappa",
             "msigma","ssigma",
             "tau",
             "clogkwHat","cS1mHat","cdS1Hat",
             "cdlogkwHat","cdS1mHat","cddS1Hat",
             "cbeta",
             "cdlogkTHat",
             "capH",
             "comega", "ckappa", "comegaT",
             "clogmsigma","cssigma", "rho[2,1]", "corr_L"), "mean", "sd")

  print(x, n=141)
```

## Trace plots

Trace plots are time series plots of Markov chains. Here we show standard trace plots for several parameters

```{r traceplots, include=TRUE}
bayesplot::mcmc_trace(fit$draws(c("logkwHat","S1mHat","dS1Hat","clogkwHat","cS1mHat","cdS1Hat"))) 
```

## Summary of model parameters (figures)

First plot presents parameter specific for XBridge Shield RP18 column and parameters common for all the columns:

```{r figsummary, include=TRUE}

p1<-bayesplot::mcmc_intervals(fit$draws(c("logkwHat","S1mHat","dS1Hat","dlogkwHat",
                                  "dlogkTHat", "dS1mHat","ddS1Hat","logS2mHat","dlogS2Hat","beta",
                                  "apH","alphamHat","dalphaHat")), point_size = 2)

p2<-bayesplot::mcmc_intervals(fit$draws(c("omega","omegaT","kappa","msigma","ssigma", "tau","rho[2,1]")), point_size = 2)

ggsave(paste0("figures\\param\\", "XBridgeShieldRP18_1", ".png"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\param\\", "XBridgeShieldRP18_2", ".png"), plot=p2, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\param\\", "XBridgeShieldRP18_1", ".pdf"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\param\\", "XBridgeShieldRP18_2", ".pdf"), plot=p2, width = 20, height = 20, units = "cm")
print(p1)
print(p2)

```

The plots below provide a summary of column effects (relative to XBridge Shield RP18 column):

```{r columneffects1, include=TRUE}
p1<-bayesplot::mcmc_intervals(fit$draws(c("clogkwHat[1]","cS1mHat[1]","cdS1Hat[1]",
            "cdlogkwHat[1,1]", "cdlogkwHat[1,2]",
            "cdS1mHat[1,1]","cdS1mHat[1,2]", 
            "cddS1Hat[1,1]","cddS1Hat[1,2]",
            "cbeta[1,1]","cbeta[1,2]",
            "cdlogkTHat[1]",
            "capH[1,1]", "capH[1,2]")), point_size = 2)+
   theme(plot.title = element_text(size = 8))+
  scale_y_discrete(labels = c("clogkwHat[1]"="clogkwHat[c]",
                              "cS1mHat[1]"="cS1mHat[c]",
                              "cdS1Hat[1]"="cdS1Hat[c]",
                              "cdlogkwHat[1,1]"="cdlogkwHat[c,1]", 
                              "cdlogkwHat[1,2]"="cdlogkwHat[c,2]",
                              "cdS1mHat[1,1]"= "cdS1mHat[c,1]",
                              "cdS1mHat[1,2]"="cdS1mHat[c,2]", 
                              "cddS1Hat[1,1]"="cddS1Hat[c,1]",
                              "cddS1Hat[1,2]"="cddS1Hat[c,2]",
                              "cbeta[1,1]"="cbeta[c,1]",
                              "cbeta[1,2]"="cbeta[c,2]",
                              "cdlogkTHat[1]"="cdlogkTHat[c]",
                              "capH[1,1]"="capH[c,1]", 
                              "capH[1,2]"="capH[c,2]"),
                   limits = c("capH[1,2]",
                               "capH[1,1]",
                               "cdlogkTHat[1]",                    
                               "cbeta[1,2]",
                               "cbeta[1,1]",
                               "cddS1Hat[1,2]",
                               "cddS1Hat[1,1]",
                               "cdS1mHat[1,2]",
                               "cdS1mHat[1,1]",
                               "cdlogkwHat[1,2]",
                               "cdlogkwHat[1,1]", 
                               "cdS1Hat[1]",
                               "cS1mHat[1]",                              
                               "clogkwHat[1]"))+
  xlim(-0.5,1)

p2<-bayesplot::mcmc_intervals(fit$draws(c("clogkwHat[2]","cS1mHat[2]","cdS1Hat[2]",
            "cdlogkwHat[2,1]", "cdlogkwHat[2,2]",
            "cdS1mHat[2,1]","cdS1mHat[2,2]", 
            "cddS1Hat[2,1]","cddS1Hat[2,2]",
            "cbeta[2,1]","cbeta[2,2]",
            "cdlogkTHat[2]",
            "capH[2,1]", "capH[2,2]")), point_size = 2)+
  theme(axis.text.y=element_blank(),plot.title = element_text(size = 8))+
  xlim(-0.5,1)

p3<-bayesplot::mcmc_intervals(fit$draws(c("clogkwHat[3]","cS1mHat[3]","cdS1Hat[3]",
            "cdlogkwHat[3,1]", "cdlogkwHat[3,2]",
            "cdS1mHat[3,1]","cdS1mHat[3,2]", 
            "cddS1Hat[3,1]","cddS1Hat[3,2]",
            "cbeta[3,1]","cbeta[3,2]",
            "cdlogkTHat[3]",
            "capH[3,1]", "capH[3,2]")), point_size = 2)+
  theme(axis.text.y=element_blank(),plot.title = element_text(size = 8))+
  xlim(-0.5,1)

p4<-bayesplot::mcmc_intervals(fit$draws(c("clogkwHat[4]","cS1mHat[4]","cdS1Hat[4]",
            "cdlogkwHat[4,1]", "cdlogkwHat[4,2]",
            "cdS1mHat[4,1]","cdS1mHat[4,2]", 
            "cddS1Hat[4,1]","cddS1Hat[4,2]",
            "cbeta[4,1]","cbeta[4,2]",
            "cdlogkTHat[4]",
            "capH[4,1]", "capH[4,2]")), point_size = 2)+
  theme(axis.text.y=element_blank(),plot.title = element_text(size = 8))+
  xlim(-0.5,1)

p=grid.arrange(p1+ggtitle("XTerra MS C18"), 
               p2+ggtitle("XBridge Phenyl"),
               p3+ggtitle("XBridge C8"),
               p4+ggtitle("Xterra MS C8"), ncol=4, widths=c(1.75,1,1,1))


ggsave(paste0("figures\\param\\", "columneffects1", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\param\\", "columneffects1", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

```

```{r columneffects2, include=TRUE}
p1<-bayesplot::mcmc_intervals(fit$draws(c("comega[1,1]",
                                          "comega[1,2]",
                                          "comega[1,3]",
                                          "comegaT[1]",
                                          "ckappa[1,1]",
                                          "ckappa[1,2]",
                                          "ckappa[1,3]")), point_size = 2) + 
  theme(plot.title = element_text(size = 8))+
  scale_y_discrete(labels = c("comega[1,1]"="comega[c,1]",
                             "comega[1,2]"="comega[c,2]",
                             "comega[1,3]"="comega[c,3]",
                             "comegaT[1]" = "comegaT[c]",
                             "ckappa[1,1]"="ckappa[c,1]",
                             "ckappa[1,2]"="ckappa[c,2]",
                             "ckappa[1,3]"="ckappa[c,3]"),
                   limits = c("ckappa[1,3]",
                              "ckappa[1,2]",
                              "ckappa[1,1]",
                              "comegaT[1]",
                              "comega[1,3]",                                          
                              "comega[1,2]",
                              "comega[1,1]"))+
  xlim(0,0.8)

p2<-bayesplot::mcmc_intervals(fit$draws(c("comega[2,1]",
                                          "comega[2,2]",
                                          "comega[2,3]",
                                          "comegaT[2]",
                                          "ckappa[2,1]",
                                          "ckappa[2,2]",
                                          "ckappa[2,3]")), point_size = 2)+
  theme(axis.text.y=element_blank(),plot.title = element_text(size = 8))+
  xlim(0,0.8)

p3<-bayesplot::mcmc_intervals(fit$draws(c("comega[3,1]",
                                          "comega[3,2]",
                                          "comega[3,3]",
                                          "comegaT[3]",
                                          "ckappa[3,1]",
                                          "ckappa[3,2]",
                                          "ckappa[3,3]")), point_size = 2)+
  theme(axis.text.y=element_blank(),plot.title = element_text(size = 8))+
  xlim(0,0.8)

p4<-bayesplot::mcmc_intervals(fit$draws(c("comega[4,1]",
                                          "comega[4,2]",
                                          "comega[4,3]",
                                          "comegaT[4]",
                                          "ckappa[4,1]",
                                          "ckappa[4,2]",
                                          "ckappa[4,3]")), point_size = 2)+
  theme(axis.text.y=element_blank(),plot.title = element_text(size = 8))+
  xlim(0,0.8)

p=grid.arrange(p1+ggtitle("XTerra MS C18"), 
               p2+ggtitle("XBridge Phenyl"),
               p3+ggtitle("XBridge C8"),
               p4+ggtitle("Xterra MS C8"), ncol=4, widths=c(1.75,1,1,1))


ggsave(paste0("figures\\param\\", "columneffects2", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\param\\", "columneffects2", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

```

Below we combine separate plot into the one graphic to characterizing column effects:

```{r figclogkw}
draws_df_subset <- fit$draws(format = "df", variable = c("clogkwHat","cdlogkwHat"))

Neutral_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(clogkwHat[c]) %>%
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(logkwHat = clogkwHat) %>%
  mutate(Type = "N")

Acids_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(clogkwHat[c],cdlogkwHat[c,r]) %>%
  filter(r==1) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(xlogkwHat=clogkwHat+cdlogkwHat)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(logkwHat = xlogkwHat) %>%
  mutate(Type = "A")

Basic_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(clogkwHat[c],cdlogkwHat[c,r]) %>%
  filter(r==2)%>%
  ungroup() %>%
  select(-r) %>%
  mutate(xlogkwHat=clogkwHat+cdlogkwHat)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(logkwHat = xlogkwHat) %>%
  mutate(Type = "B")


p1<-bind_rows(Neutral_results, Acids_results, Basic_results) %>%
  ggplot(aes(y = ColumnNames, x = logkwHat, xmin = .lower, xmax = .upper,color = Type)) +
   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  
  scale_color_manual(labels = c("A", "B", "N"), values = c("#F8766D", "#619CFF", "black"))+ 
   ylab(' ') +
   xlab("Column effects on logkw (clogkw)")

```

```{r figcS1}
draws_df_subset <- fit$draws(format = "df", variable = c("S1mHat","cS1mHat","dS1mHat","cdS1mHat",
                                                         "dS1Hat","cdS1Hat","ddS1Hat","cddS1Hat"))

MeOH_Neutral_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(S1mHat,cS1mHat[c]) %>%
  mutate(xS1mHat=cS1mHat)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(S1Hat = xS1mHat) %>%
  mutate(Type = "N")%>% 
  mutate(Modifier="MeOH")

MeOH_Acids_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(cS1mHat[c],cdS1mHat[c,r]) %>%
  filter(r==1) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(xS1mHat=cS1mHat+cdS1mHat)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(S1Hat = xS1mHat) %>%
  mutate(Type = "A")%>% 
  mutate(Modifier="MeOH")

MeOH_Basic_results  <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(cS1mHat[c],cdS1mHat[c,r]) %>%
  filter(r==2) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(xS1mHat=cS1mHat+cdS1mHat)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(S1Hat = xS1mHat) %>%
  mutate(Type = "B")%>% 
  mutate(Modifier="MeOH")


ACN_Neutral_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(cS1mHat[c],cdS1Hat[c]) %>%
  mutate(xS1aHat=cdS1Hat)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(S1Hat = xS1aHat) %>%
  mutate(Type = "N")%>% 
  mutate(Modifier="ACN")

ACN_Acids_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(cS1mHat[c],cdS1Hat[c],cdS1mHat[c,r],cddS1Hat[c,r]) %>%
  filter(r==1) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(xS1aHat=cdS1Hat + cddS1Hat)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(S1Hat = xS1aHat) %>%
  mutate(Type = "A")%>% 
  mutate(Modifier="ACN")

ACN_Basic_results  <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(cS1mHat[c],cdS1Hat[c],cdS1mHat[c,r],cddS1Hat[c,r]) %>%
  filter(r==2) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(xS1aHat= cdS1Hat + cddS1Hat)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>%  
  group_by(ColumnNames)%>%
  tidybayes::median_qi(S1Hat = xS1aHat) %>%
  mutate(Type = "B")%>% 
  mutate(Modifier="ACN")

# p2<-bind_rows(MeOH_Neutral_results, MeOH_Acids_results, MeOH_Basic_results,
#              ACN_Neutral_results,ACN_Acids_results, ACN_Basic_results) %>%
#   ggplot(aes(y = ColumnNames, x = S1Hat, xmin = .lower, xmax = .upper,color = Type)) +
#    tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  
#   scale_color_manual(labels = c("A", "B", "N"), values = c("#F8766D", "#619CFF", "black"))+ 
#   ylab(' ')+
#   xlab("Column effects on S1 (cS1)")+
#   facet_wrap(.~Modifier)

p2_1<-bind_rows(MeOH_Neutral_results, MeOH_Acids_results, MeOH_Basic_results) %>%
  ggplot(aes(y = ColumnNames, x = S1Hat, xmin = .lower, xmax = .upper,color = Type)) +
   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  
  scale_color_manual(labels = c("A", "B", "N"), values = c("#F8766D", "#619CFF", "black"))+ 
  ylab(' ')+
  xlab("Column effects on S1m (cS1m)")

p2_2<-bind_rows(ACN_Neutral_results,ACN_Acids_results, ACN_Basic_results) %>%
  ggplot(aes(y = ColumnNames, x = S1Hat, xmin = .lower, xmax = .upper,color = Type)) +
   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  
  scale_color_manual(labels = c("A", "B", "N"), values = c("#F8766D", "#619CFF", "black"))+ 
  ylab(' ')+
  xlab("Column effects on dS1 (cdS1)")

```

```{r figcbeta}
draws_df_subset <- fit$draws(format = "df", variable = c("beta","cbeta"))

logkw_results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(cbeta[c,r]) %>%
  filter(r==1) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(xbeta=cbeta)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(beta = xbeta)%>% 
  mutate(Parameter="logkw")

S1_results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(cbeta[c,r]) %>%
  filter(r==2) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(xbeta=cbeta)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(beta = xbeta)%>% 
  mutate(Parameter="S1")


p3<-bind_rows(logkw_results, S1_results) %>%
  ggplot(aes(y = ColumnNames, x = beta, xmin = .lower, xmax = .upper,color = Parameter)) +
   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) + 
  scale_color_manual(labels = c("clogkw", "cS1"), values = c("black", "gray"))+
  ylab(' ')+
  xlab("Column effects on \u03b2 (c\u03b2)")
```

```{r figcpH}
draws_df_subset <- fit$draws(format = "df", variable = c("apH","capH"))

Acids_results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(capH[c,r]) %>%
  filter(r==1) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(xapH=capH)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(apH = xapH)%>% 
  mutate(Type="A")

Bases_results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(capH[c,r]) %>%
  filter(r==2) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(xapH=capH)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(apH = xapH)%>% 
  mutate(Type="B")


p4<-bind_rows(Acids_results, Bases_results) %>%
  ggplot(aes(y = ColumnNames, x = apH, xmin = .lower, xmax = .upper,color = Type)) +
   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  
  scale_color_manual(labels = c("A", "B"), values = c("#F8766D", "#619CFF"))+
  ylab(' ')+
   xlab("Column effects on apH (capH)")

```

```{r figctemp}
draws_df_subset <- fit$draws(format = "df", variable = c("dlogkTHat","cdlogkTHat"))

Results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(cdlogkTHat[c]) %>%
  ungroup() %>%
  mutate(xdlogkTHat=cdlogkTHat)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(dlogkTHat = xdlogkTHat)%>% 
  mutate(Parameter="clogkw")

p5<-Results %>%
  ggplot(aes(y = ColumnNames, x = dlogkTHat, xmin = .lower, xmax = .upper,color = Parameter)) +
   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) + 
  scale_color_manual(labels = c("clogkw"), values = c("black"))+
  ylab(' ')+
  xlab("Column effects on dlogkT (cdlogkT)")

```

```{r figcolumn-effects-all}

p=grid.arrange(p1+ theme(legend.position='none'), 
               p3+theme(axis.text.y=element_blank()), 
               p4+ theme(legend.position='none'),
               p5+theme(axis.text.y=element_blank()), 
               p2_1 + theme(legend.position='none'),
               p2_2 +theme(axis.text.y=element_blank()),
               ncol=2)

ggsave(paste0("figures\\param\\", "column-effects-all", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\param\\", "column-effects-all", ".pdf"), plot=p, width = 20, height = 20, units = "cm")


ggsave(paste0("figures\\param\\", "column-effects-all-manuscript", ".png"),
       p,
       device = ragg::agg_png(width = 8.4582, height = 8.4582, units = "cm", res = 300, scaling=0.55))
```

Below we combine separate plot into the one graphic to characterizing parameters characterizing particular columns:

```{r figlogkw}
draws_df_subset <- fit$draws(format = "df", variable = c("logkwHat","clogkwHat","dlogkwHat","cdlogkwHat"))

Neutral_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(logkwHat,clogkwHat[c]) %>%
  mutate(c=c+1)%>%
  mutate(clogkwHat=logkwHat+clogkwHat)%>%
  select(.draw,logkwHat,clogkwHat,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = clogkwHat) %>%
  rename(`1`=logkwHat) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xlogkwHat") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(logkwHat = xlogkwHat) %>%
  mutate(Type = "N")

Acids_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(logkwHat,clogkwHat[c],dlogkwHat[r],cdlogkwHat[c,r]) %>%
  filter(r==1) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(c=c+1)%>%
  mutate(clogkwHat=logkwHat+clogkwHat+dlogkwHat+cdlogkwHat)%>%
  mutate(logkwHat=logkwHat+dlogkwHat)%>%
  select(.draw,logkwHat,clogkwHat,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = clogkwHat) %>%
  rename(`1`=logkwHat) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xlogkwHat") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(logkwHat = xlogkwHat) %>%
  mutate(Type = "A")

Basic_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(logkwHat,clogkwHat[c],dlogkwHat[r],cdlogkwHat[c,r]) %>%
  filter(r==2)%>%
  ungroup() %>%
  select(-r) %>%
  mutate(c=c+1)%>%
  mutate(clogkwHat=logkwHat+clogkwHat+dlogkwHat+cdlogkwHat)%>%
  mutate(logkwHat=logkwHat+dlogkwHat)%>%
  select(.draw,logkwHat,clogkwHat,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = clogkwHat) %>%
  rename(`1`=logkwHat) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xlogkwHat") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(logkwHat = xlogkwHat) %>%
  mutate(Type = "B")


p1<-bind_rows(Neutral_results, Acids_results, Basic_results) %>%
  ggplot(aes(y = ColumnNames, x = logkwHat, xmin = .lower, xmax = .upper,color = Type)) +
   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  
  scale_color_manual(labels = c("A", "B", "N"), values = c("#F8766D", "#619CFF", "black"))+ 
   ylab(' ') +
   xlab("Typical logkw")
```

```{r figS1}
draws_df_subset <- fit$draws(format = "df", variable = c("S1mHat","cS1mHat","dS1mHat","cdS1mHat",
                                                         "dS1Hat","cdS1Hat","ddS1Hat","cddS1Hat"))
MeOH_Neutral_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(S1mHat,cS1mHat[c]) %>%
  mutate(c=c+1)%>%
  mutate(cS1mHat=S1mHat+cS1mHat)%>%
  select(.draw,S1mHat,cS1mHat,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = cS1mHat) %>%
  rename(`1`=S1mHat) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xS1mHat") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(S1Hat = xS1mHat) %>%
  mutate(Type = "N")%>% 
  mutate(Modifier="MeOH")

MeOH_Acids_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(S1mHat,cS1mHat[c],dS1mHat[r],cdS1mHat[c,r]) %>%
  filter(r==1) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(c=c+1)%>%
  mutate(cS1mHat=S1mHat+cS1mHat+dS1mHat+cdS1mHat)%>%
  mutate(S1mHat=S1mHat+dS1mHat)%>%
  select(.draw,S1mHat,cS1mHat,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = cS1mHat) %>%
  rename(`1`=S1mHat) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xS1mHat") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(S1Hat = xS1mHat) %>%
  mutate(Type = "A")%>% 
  mutate(Modifier="MeOH")

MeOH_Basic_results  <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(S1mHat,cS1mHat[c],dS1mHat[r],cdS1mHat[c,r]) %>%
  filter(r==2) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(c=c+1)%>%
  mutate(cS1mHat=S1mHat+cS1mHat+dS1mHat+cdS1mHat)%>%
  mutate(S1mHat=S1mHat+dS1mHat)%>%
  select(.draw,S1mHat,cS1mHat,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = cS1mHat) %>%
  rename(`1`=S1mHat) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xS1mHat") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(S1Hat = xS1mHat) %>%
  mutate(Type = "B")%>% 
  mutate(Modifier="MeOH")


ACN_Neutral_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(S1mHat,cS1mHat[c],dS1Hat,cdS1Hat[c]) %>%
  mutate(c=c+1)%>%
  mutate(cS1aHat=S1mHat+cS1mHat+dS1Hat+cdS1Hat)%>%
  mutate(S1aHat =S1mHat+dS1Hat)%>%
  select(.draw,S1aHat,cS1aHat,c)%>%
  tidyr::pivot_wider(names_from = c, values_from = cS1aHat) %>%
  rename(`1`=S1aHat) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xS1aHat") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(S1Hat = xS1aHat) %>%
  mutate(Type = "N")%>% 
  mutate(Modifier="ACN")

ACN_Acids_results <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(S1mHat,cS1mHat[c],dS1Hat,cdS1Hat[c],dS1mHat[r],cdS1mHat[c,r],ddS1Hat[r],cddS1Hat[c,r]) %>%
  filter(r==1) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(c=c+1)%>%
  mutate(cS1aHat= S1mHat+cS1mHat + dS1mHat+cdS1mHat + dS1Hat+cdS1Hat + ddS1Hat+ cddS1Hat)%>%
  mutate(S1aHat = S1mHat+dS1mHat+dS1Hat+ddS1Hat)%>%
  select(.draw,S1aHat,cS1aHat,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = cS1aHat) %>%
  rename(`1`=S1aHat) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xS1aHat") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(S1Hat = xS1aHat) %>%
  mutate(Type = "A")%>% 
  mutate(Modifier="ACN")

ACN_Basic_results  <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(S1mHat,cS1mHat[c],dS1Hat,cdS1Hat[c],dS1mHat[r],cdS1mHat[c,r],ddS1Hat[r],cddS1Hat[c,r]) %>%
  filter(r==2) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(c=c+1)%>%
  mutate(cS1aHat= S1mHat+cS1mHat + dS1mHat+cdS1mHat + dS1Hat+cdS1Hat + ddS1Hat+cddS1Hat)%>%
  mutate(S1aHat = S1mHat+dS1mHat+dS1Hat+ddS1Hat)%>%
  select(.draw,S1aHat,cS1aHat,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = cS1aHat) %>%
  rename(`1`=S1aHat) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xS1aHat") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(S1Hat = xS1aHat) %>%
  mutate(Type = "B")%>% 
  mutate(Modifier="ACN")


p2<-bind_rows(MeOH_Neutral_results, MeOH_Acids_results, MeOH_Basic_results,
             ACN_Neutral_results,ACN_Acids_results, ACN_Basic_results) %>%
  ggplot(aes(y = ColumnNames, x = S1Hat, xmin = .lower, xmax = .upper,color = Type)) +
   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  
  scale_color_manual(labels = c("A", "B", "N"), values = c("#F8766D", "#619CFF", "black"))+ 
  ylab(' ')+
  xlab("Typical S1")+
  facet_wrap(.~Modifier)

```

```{r figbeta}
draws_df_subset <- fit$draws(format = "df", variable = c("beta","cbeta"))

logkw_results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(beta[r],cbeta[c,r]) %>%
  filter(r==1) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(c=c+1)%>%
  mutate(cbeta=beta+cbeta)%>%
  select(.draw,beta,cbeta,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = cbeta) %>%
  rename(`1`=beta) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xbeta") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(beta = xbeta)%>% 
  mutate(Parameter="logkw")

S1_results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(beta[r],cbeta[c,r]) %>%
  filter(r==2) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(c=c+1)%>%
  mutate(cbeta=beta+cbeta)%>%
  select(.draw,beta,cbeta,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = cbeta) %>%
  rename(`1`=beta) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xbeta") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(beta = xbeta)%>% 
  mutate(Parameter="S1")


p3<-bind_rows(logkw_results, S1_results) %>%
  ggplot(aes(y = ColumnNames, x = beta, xmin = .lower, xmax = .upper,color = Parameter)) +
   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) + 
  scale_color_manual(labels = c("logkw", "S1"), values = c("black", "gray"))+
  ylab(' ')+
  xlab("logP effects (\u03b2)")

```

```{r figpH}
draws_df_subset <- fit$draws(format = "df", variable = c("apH","capH"))

Acids_results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(apH[r], capH[c,r]) %>%
  filter(r==1) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(c=c+1)%>%
  mutate(capH=apH+capH)%>%
  select(.draw,apH,capH,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = capH) %>%
  rename(`1`= apH) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xapH") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(apH = xapH)%>% 
  mutate(Type="A")

Bases_results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(apH[r], capH[c,r]) %>%
  filter(r==2) %>%
  ungroup() %>%
  select(-r) %>%
  mutate(c=c+1)%>%
  mutate(capH=apH+capH)%>%
  select(.draw,apH,capH,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = capH) %>%
  rename(`1`= apH) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xapH") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(apH = xapH)%>% 
  mutate(Type="B")


p4<-bind_rows(Acids_results, Bases_results) %>%
  ggplot(aes(y = ColumnNames, x = apH, xmin = .lower, xmax = .upper,color = Type)) +
   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  
  scale_color_manual(labels = c("A", "B"), values = c("#F8766D", "#619CFF"))+
  ylab(' ')+
   xlab("pH effects (apH)")

```

```{r figtemp}
draws_df_subset <- fit$draws(format = "df", variable = c("dlogkTHat","cdlogkTHat"))

Results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(dlogkTHat, cdlogkTHat[c]) %>%
  ungroup() %>%
  mutate(c=c+1)%>%
  mutate(cdlogkTHat=dlogkTHat+cdlogkTHat)%>%
  select(.draw,dlogkTHat,cdlogkTHat,c) %>%
  tidyr::pivot_wider(names_from = c, values_from = cdlogkTHat) %>%
  rename(`1`= dlogkTHat) %>%
  select(-.draw)%>%
  tidyr::pivot_longer(c(1:5),names_to = "ColumnNames", values_to = "xdlogkTHat") %>% 
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(ColumnNames,
                                '1' = 'XBridge Shield RP18',
                                '2' = 'XTerra MS C18',
                                '3' = 'XBridge Phenyl',
                                '4' = 'XBridge C8',
                                '5' = 'Xterra MS C8'))%>% 
  group_by(ColumnNames)%>%
  tidybayes::median_qi(dlogkTHat = xdlogkTHat)%>% 
  mutate(Parameter="logkw")

p5<-Results %>%
  ggplot(aes(y = ColumnNames, x = dlogkTHat, xmin = .lower, xmax = .upper,color = Parameter)) +
   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) + 
  scale_color_manual(labels = c("logkw"), values = c("black"))+
  ylab(' ')+
  xlab("Temp. effects (dlogkT)")

```

```{r column-parameters-all}
p=grid.arrange(p1+ theme(legend.position='none'), 
               p3+theme(axis.text.y=element_blank()), 
               p4+ theme(legend.position='none'),
               p5+theme(axis.text.y=element_blank()), 
               p2, ncol=2, widths = c(1,1), layout_matrix = rbind(c(1, 2),c(3, 4), c(5, 5)))

ggsave(paste0("figures\\param\\", "column-parameters-all", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\param\\", "column-parameters-all", ".pdf"), plot=p, width = 20, height = 20, units = "cm")


ggsave(paste0("figures\\param\\", "column-parameters-all-manuscript", ".png"),
       p,
       device = ragg::agg_png(width = 8.4582, height = 8.4582, units = "cm", res = 300, scaling=0.55))

```

Similarly we display standard deviations and correlations of BAV characterizing column effects.

```{r sd-column-effects-all}
draws_df_subset <- fit$draws(format = "df", variable = c("comega","ckappa","comegaT","crho"))

comega_results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(comega[c,r]) %>%
  ungroup() %>%
  mutate(xparam=comega)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
    mutate(ParamNames=recode(r,
                                '1' = 'clogkw',
                                '2' = 'cS1m',
                                '3' = 'cdS1'))%>% 
  group_by(ColumnNames,ParamNames)%>%
  tidybayes::median_qi(param = xparam)%>% 
  mutate(Parameter="comega")


ckappa_results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(ckappa[c,r]) %>%
  ungroup() %>%
  mutate(xparam=ckappa)%>%
  mutate_if(is.character,as.factor) %>% 
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
    mutate(ParamNames=recode(r,
                                '1' = 'clogkw',
                                '2' = 'cS1m',
                                '3' = 'cdS1'))%>% 
  group_by(ColumnNames,ParamNames)%>%
  tidybayes::median_qi(param = xparam)%>% 
  mutate(Parameter="ckappa")


p1<-bind_rows(comega_results, ckappa_results) %>%
  mutate(ParamNames=factor(ParamNames,levels=c("clogkw","cS1m","cdS1")))%>%
  ggplot(aes(y = ColumnNames, x = param, xmin = .lower, xmax = .upper, color=ParamNames)) +
  tidybayes::geom_pointinterval(position = position_dodge(width = .3)) + 
  scale_colour_manual(name = " ", values=c("clogkw" = "#F8766D","cS1m" = "#619CFF","cdS1" = "#00BA38")) +
  facet_wrap(.~factor(Parameter,levels=c("comega","ckappa"),labels=c(expression(paste("c",omega)),expression(paste("c",kappa)))),labeller = label_parsed)+
  ylab(' ')+
  xlab("standard deviations")

crho_results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(crho[c,r]) %>%
  ungroup() %>%
  mutate(columnnames1=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  mutate(columnnames2=recode(r,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>% 
  mutate(namelong=paste0("crho","(", columnnames1,",", columnnames2, ")" )) %>%
  mutate(name=paste0(c,r))%>%
  mutate_if(is.character,as.factor) %>%
  subset(name %in% c(21,31,32,41,42,43)) %>%
  group_by(namelong)%>%
  tidybayes::median_qi(param = crho)%>% 
  mutate(Parameter="crho")

p2<-ggplot(crho_results,aes(y = as.factor(namelong), x = param, xmin = .lower, xmax = .upper), color="black") +
  tidybayes::geom_pointinterval(position = position_dodge(width = .3)) + 
  ylab(' ')+
  xlab("crho")+
  theme(legend.position='none')+
  scale_y_discrete(position = "right")


comegaT_results <-draws_df_subset %>%
  slice_sample(n = 1000) %>%
  tidybayes::spread_draws(comegaT[c]) %>%
  ungroup() %>%
  mutate(ColumnNames=recode(c,
                                '1' = 'XTerra MS C18',
                                '2' = 'XBridge Phenyl',
                                '3' = 'XBridge C8',
                                '4' = 'Xterra MS C8'))%>%

  mutate_if(is.character,as.factor) %>%
  group_by(ColumnNames)%>%
  tidybayes::median_qi(param = comegaT)%>% 
  mutate(Parameter="comegaT")

p3<-ggplot(comegaT_results,aes(y = as.factor(ColumnNames), x = param, xmin = .lower, xmax = .upper), color="black") +
  tidybayes::geom_pointinterval(position = position_dodge(width = .3)) + 
  ylab(' ')+
  xlab(expression(paste("c",omega,"T")))+
  theme(legend.position='none')+
  scale_x_continuous(limits =c(0,0.02), breaks=c(0,0.01,0.02))

p=grid.arrange(p1, p3, p2, 
               widths = c(0.3,0.7), layout_matrix = rbind(c(1, 1),c(2, 3)))

ggsave(paste0("figures\\param\\", "sd-column-effects-all", ".png"), plot=p, width = 20, height = 15, units = "cm")
ggsave(paste0("figures\\param\\", "sd-column-effects-all", ".pdf"), plot=p, width = 20, height = 15, units = "cm")

ggsave(paste0("figures\\param\\", "sd-column-effects-all-manuscript", ".png"),
       p,
       device = ragg::agg_png(width = 8.4582, height = 6.34365, units = "cm", res = 300, scaling=0.55))

```

## Isocratic predictions

To better asses the impact of parameters on retention we created graphs presenting the isocratic logarithm of retention factor vs. $\varphi$ for selected analytes. Separate graphs are shown for each dissociation form (r=1,r=2,r=3). Here the individual predictions (given all the data) are shown:

```{r izo-pred-individual}
analyte_ID_sample <-c(9,17,33,58,140,180)

for(i in 1:length(analyte_ID_sample)){

idx_analyte = which(unique(data$METID)==analyte_ID_sample[i])
draws_df_subset <- fit$draws(format = "df", variable = c(
                sprintf("logkwx[%s,1,1]",idx_analyte), 
                sprintf("logkwx[%s,1,2]",idx_analyte), 
                sprintf("logkwx[%s,1,3]",idx_analyte),
                sprintf("logkwx[%s,2,1]",idx_analyte), 
                sprintf("logkwx[%s,2,2]",idx_analyte),
                sprintf("logkwx[%s,2,3]",idx_analyte),
                sprintf("logkwx[%s,3,1]",idx_analyte), 
                sprintf("logkwx[%s,3,2]",idx_analyte),
                sprintf("logkwx[%s,3,3]",idx_analyte),
                sprintf("logkwx[%s,4,1]",idx_analyte), 
                sprintf("logkwx[%s,4,2]",idx_analyte),
                sprintf("logkwx[%s,4,3]",idx_analyte),
                sprintf("logkwx[%s,5,1]",idx_analyte), 
                sprintf("logkwx[%s,5,2]",idx_analyte),
                sprintf("logkwx[%s,5,3]",idx_analyte),
                sprintf("S1x[%s,1,1,1]",idx_analyte), 
                sprintf("S1x[%s,1,1,2]",idx_analyte), 
                sprintf("S1x[%s,1,1,3]",idx_analyte),
                sprintf("S1x[%s,2,1,1]",idx_analyte), 
                sprintf("S1x[%s,2,1,2]",idx_analyte), 
                sprintf("S1x[%s,2,1,3]",idx_analyte),
                sprintf("S1x[%s,1,2,1]",idx_analyte), 
                sprintf("S1x[%s,1,2,2]",idx_analyte), 
                sprintf("S1x[%s,1,2,3]",idx_analyte), 
                sprintf("S1x[%s,2,2,1]",idx_analyte), 
                sprintf("S1x[%s,2,2,2]",idx_analyte), 
                sprintf("S1x[%s,2,2,3]",idx_analyte),
                sprintf("S1x[%s,1,3,1]",idx_analyte), 
                sprintf("S1x[%s,1,3,2]",idx_analyte), 
                sprintf("S1x[%s,1,3,3]",idx_analyte), 
                sprintf("S1x[%s,2,3,1]",idx_analyte), 
                sprintf("S1x[%s,2,3,2]",idx_analyte), 
                sprintf("S1x[%s,2,3,3]",idx_analyte),
                sprintf("S1x[%s,1,4,1]",idx_analyte), 
                sprintf("S1x[%s,1,4,2]",idx_analyte), 
                sprintf("S1x[%s,1,4,3]",idx_analyte), 
                sprintf("S1x[%s,2,4,1]",idx_analyte), 
                sprintf("S1x[%s,2,4,2]",idx_analyte), 
                sprintf("S1x[%s,2,4,3]",idx_analyte),
                sprintf("S1x[%s,1,5,1]",idx_analyte), 
                sprintf("S1x[%s,1,5,2]",idx_analyte), 
                sprintf("S1x[%s,1,5,3]",idx_analyte), 
                sprintf("S1x[%s,2,5,1]",idx_analyte), 
                sprintf("S1x[%s,2,5,2]",idx_analyte), 
                sprintf("S1x[%s,2,5,3]",idx_analyte),
                "S2x[1,1]", 
                "S2x[2,1]"))

p <-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(logkwx[, c, r], S1x[, m, c, r], S2x[m, ]) %>%
  filter(r<=R[idx_analyte]+1)  %>% 
  tidyr::expand_grid(fi = seq(0,1,0.1)) %>%
  mutate(logk = logkwx-S1x*(1+S2x)*fi/(1+S2x*fi)) %>%
  ggplot(aes(x = fi, y = logk, color = as.factor(c), fill = as.factor(c))) +
  ggdist::stat_lineribbon(.width = c(.90), alpha = 1/2) +
  facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))+
  labs(title=paste(dataNames$Name[analyte_ID_sample[i]]),color= " ",fill= " ", x="\u03C6", y="logk (individual)")+
  scale_fill_discrete(labels= c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8")) +
  scale_color_discrete(labels= c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8"))+
  geom_hline(yintercept= c(0,1), linetype="dashed",color="gray")  + 
  coord_cartesian(xlim=c(0,1),ylim=c(-1,2))

print(p)

ggsave(paste0("figures\\izoparam\\isopred\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".individual", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\izoparam\\isopred\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".individual", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

}

# AGG as the graphic backend of RStudio. (Tools -> Global Options -> General -> Graphics)
# https://github.com/tidyverse/ggplot2/issues/4661
# otherwise coord_cartesian does not work
```

Similarly we can quantify the column effects (between column differences in logk using XBridge Shield RP18 as a reference column):

```{r izo-diff-individual}
analyte_ID_sample <-c(9,17,33,58,140,180)


for(i in 1:length(analyte_ID_sample)){

idx_analyte = which(unique(data$METID)==analyte_ID_sample[i])
draws_df_subset <- fit$draws(format = "df", variable = c(
                sprintf("logkwx[%s,1,1]",idx_analyte), 
                sprintf("logkwx[%s,1,2]",idx_analyte), 
                sprintf("logkwx[%s,1,3]",idx_analyte),
                sprintf("logkwx[%s,2,1]",idx_analyte), 
                sprintf("logkwx[%s,2,2]",idx_analyte),
                sprintf("logkwx[%s,2,3]",idx_analyte),
                sprintf("logkwx[%s,3,1]",idx_analyte), 
                sprintf("logkwx[%s,3,2]",idx_analyte),
                sprintf("logkwx[%s,3,3]",idx_analyte),
                sprintf("logkwx[%s,4,1]",idx_analyte), 
                sprintf("logkwx[%s,4,2]",idx_analyte),
                sprintf("logkwx[%s,4,3]",idx_analyte),
                sprintf("logkwx[%s,5,1]",idx_analyte), 
                sprintf("logkwx[%s,5,2]",idx_analyte),
                sprintf("logkwx[%s,5,3]",idx_analyte),
                sprintf("S1x[%s,1,1,1]",idx_analyte), 
                sprintf("S1x[%s,1,1,2]",idx_analyte), 
                sprintf("S1x[%s,1,1,3]",idx_analyte),
                sprintf("S1x[%s,2,1,1]",idx_analyte), 
                sprintf("S1x[%s,2,1,2]",idx_analyte), 
                sprintf("S1x[%s,2,1,3]",idx_analyte),
                sprintf("S1x[%s,1,2,1]",idx_analyte), 
                sprintf("S1x[%s,1,2,2]",idx_analyte), 
                sprintf("S1x[%s,1,2,3]",idx_analyte), 
                sprintf("S1x[%s,2,2,1]",idx_analyte), 
                sprintf("S1x[%s,2,2,2]",idx_analyte), 
                sprintf("S1x[%s,2,2,3]",idx_analyte),
                sprintf("S1x[%s,1,3,1]",idx_analyte), 
                sprintf("S1x[%s,1,3,2]",idx_analyte), 
                sprintf("S1x[%s,1,3,3]",idx_analyte), 
                sprintf("S1x[%s,2,3,1]",idx_analyte), 
                sprintf("S1x[%s,2,3,2]",idx_analyte), 
                sprintf("S1x[%s,2,3,3]",idx_analyte),
                sprintf("S1x[%s,1,4,1]",idx_analyte), 
                sprintf("S1x[%s,1,4,2]",idx_analyte), 
                sprintf("S1x[%s,1,4,3]",idx_analyte), 
                sprintf("S1x[%s,2,4,1]",idx_analyte), 
                sprintf("S1x[%s,2,4,2]",idx_analyte), 
                sprintf("S1x[%s,2,4,3]",idx_analyte),
                sprintf("S1x[%s,1,5,1]",idx_analyte), 
                sprintf("S1x[%s,1,5,2]",idx_analyte), 
                sprintf("S1x[%s,1,5,3]",idx_analyte), 
                sprintf("S1x[%s,2,5,1]",idx_analyte), 
                sprintf("S1x[%s,2,5,2]",idx_analyte), 
                sprintf("S1x[%s,2,5,3]",idx_analyte),
                "S2x[1,1]", 
                "S2x[2,1]"))

p<-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(logkwx[, c, r], S1x[, m, c, r], S2x[m, ]) %>%
  filter(r<=R[idx_analyte]+1) %>% 
  tidyr::expand_grid(fi = seq(0,1,0.05)) %>%
  mutate(k = (logkwx-S1x*(1+S2x)*fi/(1+S2x*fi))) %>%
  select(.draw,c,r,m,k,fi) %>%
  tidyr::pivot_wider(names_from = c, values_from = k) %>%
  mutate(cdk2 = `2`-`1` ) %>%
  mutate(cdk3 = `3`-`1` ) %>%
  mutate(cdk4 = `4`-`1` ) %>%
  mutate(cdk5 = `5`-`1` ) %>%
  tidyr::pivot_longer(cdk2:cdk5,names_to = "names_cdk", values_to = "cdk")%>%
   ggplot(aes(x = fi, y = cdk, color = as.factor(names_cdk), fill = as.factor(names_cdk))) +
   ggdist::stat_lineribbon(.width = c(.90), alpha = 1/2)+
   facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))+
   labs(y = "Between column difference in logk (individual)", title=paste(dataNames$Name[analyte_ID_sample[i]]),color= " ",fill= " ", x="\u03C6")+
  scale_fill_discrete(labels= c("XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8")) +
  scale_color_discrete(labels= c("XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8"))+
   geom_hline(yintercept= c(0), linetype="dashed",color="gray") + 
  coord_cartesian(xlim=c(0,1),ylim=c(-1,1))

 print(p)
 
 ggsave(paste0("figures\\izoparam\\diff\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".individual", ".png"), plot=p, width = 20, height = 20, units = "cm")
 ggsave(paste0("figures\\izoparam\\diff\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".individual", ".pdf"), plot=p, width = 20, height = 20, units = "cm")



}

```

or predict the organic modifier content leading to logk of 1:

```{r izo-logk1-individual}
analyte_ID_sample <-c(9,17,33,58,140,180)


for(i in 1:length(analyte_ID_sample)){

idx_analyte = which(unique(data$METID)==analyte_ID_sample[i])
draws_df_subset <- fit$draws(format = "df", variable = c(
                sprintf("logkwx[%s,1,1]",idx_analyte), 
                sprintf("logkwx[%s,1,2]",idx_analyte), 
                sprintf("logkwx[%s,1,3]",idx_analyte),
                sprintf("logkwx[%s,2,1]",idx_analyte), 
                sprintf("logkwx[%s,2,2]",idx_analyte),
                sprintf("logkwx[%s,2,3]",idx_analyte),
                sprintf("logkwx[%s,3,1]",idx_analyte), 
                sprintf("logkwx[%s,3,2]",idx_analyte),
                sprintf("logkwx[%s,3,3]",idx_analyte),
                sprintf("logkwx[%s,4,1]",idx_analyte), 
                sprintf("logkwx[%s,4,2]",idx_analyte),
                sprintf("logkwx[%s,4,3]",idx_analyte),
                sprintf("logkwx[%s,5,1]",idx_analyte), 
                sprintf("logkwx[%s,5,2]",idx_analyte),
                sprintf("logkwx[%s,5,3]",idx_analyte),
                sprintf("S1x[%s,1,1,1]",idx_analyte), 
                sprintf("S1x[%s,1,1,2]",idx_analyte), 
                sprintf("S1x[%s,1,1,3]",idx_analyte),
                sprintf("S1x[%s,2,1,1]",idx_analyte), 
                sprintf("S1x[%s,2,1,2]",idx_analyte), 
                sprintf("S1x[%s,2,1,3]",idx_analyte),
                sprintf("S1x[%s,1,2,1]",idx_analyte), 
                sprintf("S1x[%s,1,2,2]",idx_analyte), 
                sprintf("S1x[%s,1,2,3]",idx_analyte), 
                sprintf("S1x[%s,2,2,1]",idx_analyte), 
                sprintf("S1x[%s,2,2,2]",idx_analyte), 
                sprintf("S1x[%s,2,2,3]",idx_analyte),
                sprintf("S1x[%s,1,3,1]",idx_analyte), 
                sprintf("S1x[%s,1,3,2]",idx_analyte), 
                sprintf("S1x[%s,1,3,3]",idx_analyte), 
                sprintf("S1x[%s,2,3,1]",idx_analyte), 
                sprintf("S1x[%s,2,3,2]",idx_analyte), 
                sprintf("S1x[%s,2,3,3]",idx_analyte),
                sprintf("S1x[%s,1,4,1]",idx_analyte), 
                sprintf("S1x[%s,1,4,2]",idx_analyte), 
                sprintf("S1x[%s,1,4,3]",idx_analyte), 
                sprintf("S1x[%s,2,4,1]",idx_analyte), 
                sprintf("S1x[%s,2,4,2]",idx_analyte), 
                sprintf("S1x[%s,2,4,3]",idx_analyte),
                sprintf("S1x[%s,1,5,1]",idx_analyte), 
                sprintf("S1x[%s,1,5,2]",idx_analyte), 
                sprintf("S1x[%s,1,5,3]",idx_analyte), 
                sprintf("S1x[%s,2,5,1]",idx_analyte), 
                sprintf("S1x[%s,2,5,2]",idx_analyte), 
                sprintf("S1x[%s,2,5,3]",idx_analyte),
                "S2x[1,1]", 
                "S2x[2,1]"))

p<-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(logkwx[, c, r], S1x[, m, c, r], S2x[m, ]) %>%
  filter(r<=R[idx_analyte]+1)  %>% 
  mutate(foo = (logkwx-1)/S1x/(1+S2x)) %>%
  mutate(fix = foo/(1-S2x*foo)) %>%
  ggplot(aes(x = fix, color = as.factor(c), fill = as.factor(c))) +
  geom_density(alpha = 1/2) +
  #coord_cartesian(xlim=c(0,1))+
  facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))+
  labs(title=paste(dataNames$Name[analyte_ID_sample[i]]),
       color= " ",
       fill= " ",
       x = "\u03C6 leading to logk=1 (individual)")+
  scale_fill_discrete(labels= c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8")) +
  scale_color_discrete(labels= c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8"))+
  facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))

print(p)

 ggsave(paste0("figures\\izoparam\\filogk1\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".individual", ".png"), plot=p, width = 20, height = 20, units = "cm")
  ggsave(paste0("figures\\izoparam\\filogk1\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".individual", ".pdf"), plot=p, width = 20, height = 20, units = "cm")
}
```

## Individual Parameters

Individual parameter are the analyte-specific parameters estimated by the model. The following plots allow to assess the correlations between these parameters.

### Neutral Form

```{r draws_df}
#Extract sample for plots
draws_df <- fit$draws(format = "df")
```

Individual parameters for the reference column (XBridge Shield RP18):

```{r iparam-column-neutral}
param <- apply(draws_df[,which(colnames(draws_df) %in% grep("^param", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
param <- melt(param)
param1 <- param[1:nAnalytes,]
param2 <- param[(nAnalytes+1):(2*nAnalytes),]
param3 <- apply(draws_df[,which(colnames(draws_df) %in% grep("^dS1N", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)

data_to_plot_param <- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,param2,param3)
colnames(data_to_plot_param) <- c(expression('logP'[i]),expression('logkwN'[i]),expression('S1mN'[i]),expression('dS1N'[i]))

p<-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,
        labeller = "label_parsed",upper = list(continuous = "points"))

ggsave(paste0("figures\\iparam\\", "XBridgeShieldRP18.neutral", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "XBridgeShieldRP18.neutral", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

print(p)
```

Individual parameters for column effects:

```{r iparam-columneffects-neutral}
param <- apply(draws_df[,which(colnames(draws_df) %in% grep("^clogkwN", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
param <- melt(param)
param <- matrix(param$value, nrow = nAnalytes, byrow = TRUE)
param1 <- param[,1]
param2 <- param[,2]
param3 <- param[,3]
param4 <- param[,4]

data_to_plot_param <- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,param2,param3,param4)
colnames(data_to_plot_param) <- c(expression('logP'[i]),expression('clogkwN1'[i]),expression('clogkwN2'[i]),expression('clogkwN3'[i]),expression('clogkwN4'[i]))

p1<-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,
        labeller = "label_parsed",upper = list(continuous = "points"))


param <- apply(draws_df[,which(colnames(draws_df) %in% grep("^cS1mN", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
param <- melt(param)
param <- matrix(param$value,nrow = nAnalytes, byrow = TRUE)
param1 <- param[,1]
param2 <- param[,2]
param3 <- param[,3]
param4 <- param[,4]

data_to_plot_param <- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,param2,param3,param4)
colnames(data_to_plot_param) <- c(expression('logP'[i]),expression('cS1mN1'[i]),expression('cS1mN2'[i]),expression('cS1mN3'[i]),expression('cS1mN4'[i]))

p2<-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,
        labeller = "label_parsed",upper = list(continuous = "points"))

param <- apply(draws_df[,which(colnames(draws_df) %in% grep("^cdS1N", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
param <- melt(param)
param <- matrix(param$value,nrow = nAnalytes, byrow = TRUE)
param1 <- param[,1]
param2 <- param[,2]
param3 <- param[,3]
param4 <- param[,4]

data_to_plot_param <- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,param2,param3,param4)
colnames(data_to_plot_param) <- c(expression('logP'[i]),expression('cdS1N1'[i]),expression('cdS1N2'[i]),expression('cdS1N3'[i]),expression('cdS1N4'[i]))

p3<-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,
        labeller = "label_parsed",upper = list(continuous = "points"))

ggsave(paste0("figures\\iparam\\", "columneffects.neutral.clogkwN", ".png"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "columneffects.neutral.cS1mN", ".png"), plot=p2, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "columneffects.neutral.cdS1N", ".png"), plot=p3, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "columneffects.neutral.clogkwN", ".pdf"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "columneffects.neutral.cS1mN", ".pdf"), plot=p2, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "columneffects.neutral.cdS1N", ".pdf"), plot=p3, width = 20, height = 20, units = "cm")

print(p1)
print(p2)
print(p3)
```

### Effects of dissociation

Individual parameters for the reference column (XBridge Shield RP18)

```{r iparam-column-dissociated}
dlogkwA <- apply(draws_df[,which(colnames(draws_df) %in% grep("^dlogkwA", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
dlogkwA <- melt(dlogkwA)[,1]

dlogkwB <- apply(draws_df[,which(colnames(draws_df) %in% grep("^dlogkwB", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
dlogkwB <- melt(dlogkwB)[,1]

dlogkw <- c(dlogkwA,dlogkwB)

dS1mA <- apply(draws_df[,which(colnames(draws_df) %in% grep("^dS1mA", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
dS1mA <- melt(dS1mA)[,1]
dS1mB <- apply(draws_df[,which(colnames(draws_df) %in% grep("^dS1mB", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
dS1mB <- melt(dS1mB)[,1]

dS1m <- c(dS1mA,dS1mB)

dS1A <- apply(draws_df[,which(colnames(draws_df) %in% grep("^dS1A", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
dS1A <- melt(dS1A)[,1]
dS1B <- apply(draws_df[,which(colnames(draws_df) %in% grep("^dS1B", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
dS1B <- melt(dS1B)[,1]

dS1 <- c(dS1A,dS1B)

GroupType = c(rep("Acids", length(dlogkwA)),rep("Bases", length(dlogkwB)))

data_to_plot_diss <- data.frame(dlogkw, dS1m,dS1,GroupType)

p<-ggpairs(data_to_plot_diss,columns = 1:3, columnLabels = c("dlogkw","dS1m","ddS1"),
        labeller = "label_parsed",
        legend =1,
        aes(color = GroupType, alpha = 0.5),
        upper = list(continuous = "points"))+
        scale_alpha(guide = "none")

ggsave(paste0("figures\\iparam\\", "XBridgeShieldRP18.dissociated", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "XBridgeShieldRP18.dissociated", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

print(p)

```

Individual parameters for the particular column (1-4) relative to XBridge Shield RP18

```{r iparam-columneffects-dissociated}
paramA <- apply(draws_df[,which(colnames(draws_df) %in% grep("^cdlogkwA", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
paramA <- melt(paramA)
paramA <- matrix(paramA$value,nrow = datastruct$nGroupsA, byrow = TRUE)
paramA1 <- paramA[,1]
paramA2 <- paramA[,2]
paramA3 <- paramA[,3]
paramA4 <- paramA[,4]

paramB <- apply(draws_df[,which(colnames(draws_df) %in% grep("^cdlogkwB", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
paramB <- melt(paramB)
paramB <- matrix(paramB$value,nrow = datastruct$nGroupsB, byrow = TRUE)
paramB1 <- paramB[,1]
paramB2 <- paramB[,2]
paramB3 <- paramB[,3]
paramB4 <- paramB[,4]

param1 <- c(paramA1,paramB1)
param2 <- c(paramA2,paramB2)
param3 <- c(paramA3,paramB3)
param4 <- c(paramA4,paramB4)

GroupType = c(rep("Acids", length(paramA1)),rep("Bases", length(paramB1)))

data_to_plot_diss <- data.frame(param1,param2,param3,param4,GroupType)

p1<-ggpairs(data_to_plot_diss,columns = 1:4, columnLabels = c("cdlogkw1","cdlogkw2","cdlogkw3","cdlogkw4"),
        labeller = "label_parsed",
        legend =1,
        aes(color = GroupType, alpha = 0.5),
        upper = list(continuous = "points"))+
        scale_alpha(guide = "none")

paramA <- apply(draws_df[,which(colnames(draws_df) %in% grep("^cdS1mA", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
paramA <- melt(paramA)
paramA <- matrix(paramA$value,nrow = datastruct$nGroupsA, byrow = TRUE)
paramA1 <- paramA[,1]
paramA2 <- paramA[,2]
paramA3 <- paramA[,3]
paramA4 <- paramA[,4]

paramB <- apply(draws_df[,which(colnames(draws_df) %in% grep("^cdS1mB", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
paramB <- melt(paramB)
paramB <- matrix(paramB$value,nrow = datastruct$nGroupsB, byrow = TRUE)
paramB1 <- paramB[,1]
paramB2 <- paramB[,2]
paramB3 <- paramB[,3]
paramB4 <- paramB[,4]

param1 <- c(paramA1,paramB1)
param2 <- c(paramA2,paramB2)
param3 <- c(paramA3,paramB3)
param4 <- c(paramA4,paramB4)

GroupType = c(rep("Acids", length(paramA1)),rep("Bases", length(paramB1)))

data_to_plot_diss <- data.frame(param1,param2,param3,param4,GroupType)

p2<-ggpairs(data_to_plot_diss,columns = 1:4, columnLabels = c("cdS1m1","cdS1m2","cdS1m3","cdS1m4"),
        labeller = "label_parsed",
        legend =1,
        aes(color = GroupType, alpha = 0.5),
        upper = list(continuous = "points"))+
        scale_alpha(guide = "none")

paramA <- apply(draws_df[,which(colnames(draws_df) %in% grep("^cdS1A", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
paramA <- melt(paramA)
paramA <- matrix(paramA$value,nrow = datastruct$nGroupsA, byrow = TRUE)
paramA1 <- paramA[,1]
paramA2 <- paramA[,2]
paramA3 <- paramA[,3]
paramA4 <- paramA[,4]

paramB <- apply(draws_df[,which(colnames(draws_df) %in% grep("^cdS1B", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
paramB <- melt(paramB)
paramB <- matrix(paramB$value,nrow = datastruct$nGroupsB, byrow = TRUE)
paramB1 <- paramB[,1]
paramB2 <- paramB[,2]
paramB3 <- paramB[,3]
paramB4 <- paramB[,4]

param1 <- c(paramA1,paramB1)
param2 <- c(paramA2,paramB2)
param3 <- c(paramA3,paramB3)
param4 <- c(paramA4,paramB4)

GroupType = c(rep("Acids", length(paramA1)),rep("Bases", length(paramB1)))

data_to_plot_diss <- data.frame(param1,param2,param3,param4,GroupType)

p3<-ggpairs(data_to_plot_diss,columns = 1:4, columnLabels = c("cdS11","cdS12","cdS13","cdS14"),
        labeller = "label_parsed",
        legend =1,
        aes(color = GroupType, alpha = 0.5),
        upper = list(continuous = "points"))+
        scale_alpha(guide = "none")
ggsave(paste0("figures\\iparam\\", "coleffects.diss.cdlogkw", ".png"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "coleffects.diss.cdS1m", ".png"), plot=p2, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "coleffects.diss.cdS1", ".png"), plot=p3, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "coleffects.diss.cdlogkw", ".pdf"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "coleffects.diss.cdS1m", ".pdf"), plot=p2, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "coleffects.diss.cdS1", ".pdf"), plot=p3, width = 20, height = 20, units = "cm")

print(p1)
print(p2)
print(p3)


```

### pKa-related paraemters

```{r iparam-pKas}

pKawA <- apply(draws_df[,which(colnames(draws_df) %in% grep("^pKawA", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
pKawA <- melt(pKawA)[,1]
pKawB <- apply(draws_df[,which(colnames(draws_df) %in% grep("^pKawB", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
pKawB <- melt(pKawB)[,1]

alphamA <- apply(draws_df[,which(colnames(draws_df) %in% grep("^alphamA", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
alphamA <- melt(alphamA)[,1]
alphamB <- apply(draws_df[,which(colnames(draws_df) %in% grep("^alphamB", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
alphamB <- melt(alphamB)[,1]

dalphaA <- apply(draws_df[,which(colnames(draws_df) %in% grep("^dalphaA", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
dalphaA <- melt(dalphaA)[,1]
dalphaB <- apply(draws_df[,which(colnames(draws_df) %in% grep("^dalphaB", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)
dalphaB <- melt(dalphaB)[,1]

pKapred <- c(pKawA, pKawB)
pKaslit <- c(pKaslitA, pKaslitB)
alpham <- c(alphamA, alphamB)
dalpha <- c(dalphaA, dalphaB)

GroupType = c(rep("Acids", length(alphamA)),rep("Bases", length(alphamB)))


data_to_plot_param <- data.frame(pKapred, pKaslit, alpham, dalpha, GroupType)

p<-ggpairs(data_to_plot_param,columns = 1:4, columnLabels = c("pKalit", "pKapred", "alpham", "dalpha"),
        labeller = "label_parsed",
        legend =1,
        aes(color = GroupType, alpha = 0.5),
        upper = list(continuous = "points"))+
        scale_alpha(guide = "none")

ggsave(paste0("figures\\iparam\\", "pKas", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\iparam\\", "pKas", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

print(p)

```

## Eta plots

Eta plots shows the centered and standardized individual parameters (e.g. $\eta_{logkwN,i} = (logkwN_i-(\hat{logkwN} + \beta_1 \cdot \log P_i))/\omega_1$). They allow to visualize the unexplained between-analyte variability of chromatographic parameters.

```{r etaqq, eval = FALSE}
model_etas <- cmdstan_model("stan/hplc-gra-fivecolumns-etas.stan")
fit_etas  <- model_etas$generate_quantities(fit,
                                         data = datastruct,
                                         seed = 123,
                                         parallel_chains = 4,
                                         output_dir = "stanfiles")
```

```{r etaload}
x<- cmdstanr::read_cmdstan_csv(c(
                                  'stanfiles/hplc-gra-fivecolumns-etas-202308231335-1-45bb77.csv',
                                  'stanfiles/hplc-gra-fivecolumns-etas-202308231335-2-45bb77.csv',
                                  'stanfiles/hplc-gra-fivecolumns-etas-202308231335-3-45bb77.csv',
                                  'stanfiles/hplc-gra-fivecolumns-etas-202308231335-4-45bb77.csv'
                                ))
draws_etas_df <- as_draws_df(x$generated_quantities)

# draws_etas_df <- fit_etas$draws(format = "df")
```

### Neutral Forms

```{r etaplots-neutral}
param1 <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etalogkwN", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)

cparam <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etaclogkwNc", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)
cparam <- melt(cparam)
cparam <- matrix(cparam$value,nrow = nAnalytes, byrow = TRUE)
cparam1 <- cparam[,1]
cparam2 <- cparam[,2]
cparam3 <- cparam[,3]
cparam4 <- cparam[,4]


data_to_plot_param <- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,cparam1,cparam2,cparam3,cparam4)
colnames(data_to_plot_param) <- c(expression('logP'[i]),expression('etalogkwN'),expression('etaclogkwN_1'),expression('etaclogkwN_2'), expression('etaclogkwN_3'),expression('etaclogkwN_4'))

p1<-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,
        labeller = "label_parsed",upper = list(continuous = "points"))


param1 <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etaS1mN", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)

cparam <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etacS1mNc", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)
cparam <- melt(cparam)
cparam <- matrix(cparam$value,nrow = nAnalytes, byrow = TRUE)
cparam1 <- cparam[,1]
cparam2 <- cparam[,2]
cparam3 <- cparam[,3]
cparam4 <- cparam[,4]

data_to_plot_param <- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,cparam1,cparam2,cparam3,cparam4)
colnames(data_to_plot_param) <- c(expression('logP'[i]),expression('etaS1mN'),expression('etacS1mN_1'),expression('etacS1mN_2'), expression('etacS1mN_3'),expression('etacS1mN_4'))

p2<-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,
        labeller = "label_parsed",upper = list(continuous = "points"))

param1 <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etadS1N", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)

cparam <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etacdS1Nc", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)
cparam <- melt(cparam)
cparam <- matrix(cparam$value,nrow = nAnalytes, byrow = TRUE)
cparam1 <- cparam[,1]
cparam2 <- cparam[,2]
cparam3 <- cparam[,3]
cparam4 <- cparam[,4]

data_to_plot_param <- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,cparam1,cparam2,cparam3,cparam4)
colnames(data_to_plot_param) <- c(expression('logP'[i]),expression('etadS1N'),expression('etacdS1N_1'),expression('etacdS1N_2'), expression('etacdS1N_3'),expression('etacdS1N_4'))

p3<-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,
        labeller = "label_parsed",upper = list(continuous = "points"))

ggsave(paste0("figures\\etaplots\\", "neutral.logkwN", ".png"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\etaplots\\", "neutral.S1mN", ".png"), plot=p2, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\etaplots\\", "neutral.dS1N", ".png"), plot=p3, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\etaplots\\", "neutral.logkwN", ".pdf"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\etaplots\\", "neutral.S1mN", ".pdf"), plot=p2, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\etaplots\\", "neutral.dS1N", ".pdf"), plot=p3, width = 20, height = 20, units = "cm")

print(p1)
print(p2)
print(p3)
```

### Effect of dissociation

```{r etaplots-dissociated}
paramA <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etacdlogkwAc", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)
paramA <- melt(paramA)
paramA <- matrix(paramA$value,nrow = datastruct$nGroupsA, byrow = TRUE)
paramA1 <- paramA[,1]
paramA2 <- paramA[,2]
paramA3 <- paramA[,3]
paramA4 <- paramA[,4]

paramB <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etacdlogkwBc", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)
paramB <- melt(paramB)
paramB <- matrix(paramB$value,nrow = datastruct$nGroupsB, byrow = TRUE)
paramB1 <- paramB[,1]
paramB2 <- paramB[,2]
paramB3 <- paramB[,3]
paramB4 <- paramB[,4]

param1 <- c(paramA1,paramB1)
param2 <- c(paramA2,paramB2)
param3 <- c(paramA3,paramB3)
param4 <- c(paramA4,paramB4)

GroupType = c(rep("Acids", length(paramA1)),rep("Bases", length(paramB1)))

data_to_plot_diss <- data.frame(param1,param2,param3,param4,GroupType)


p1<-ggpairs(data_to_plot_diss,columns = 1:4, columnLabels = c("etadlogkw1","etadlogkw2","etadlogkw3", "etadlogkw4"),
        labeller = "label_parsed",
        legend =1,
        aes(color = GroupType, alpha = 0.5),
        upper = list(continuous = "points"))+
        scale_alpha(guide = "none")


paramA <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etacdS1mAc", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)
paramA <- melt(paramA)
paramA <- matrix(paramA$value,nrow = datastruct$nGroupsA, byrow = TRUE)
paramA1 <- paramA[,1]
paramA2 <- paramA[,2]
paramA3 <- paramA[,3]
paramA4 <- paramA[,4]

paramB <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etacdS1mBc", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)
paramB <- melt(paramB)
paramB <- matrix(paramB$value,nrow = datastruct$nGroupsB, byrow = TRUE)
paramB1 <- paramB[,1]
paramB2 <- paramB[,2]
paramB3 <- paramB[,3]
paramB4 <- paramB[,4]

param1 <- c(paramA1,paramB1)
param2 <- c(paramA2,paramB2)
param3 <- c(paramA3,paramB3)
param4 <- c(paramA4,paramB4)

GroupType = c(rep("Acids", length(paramA1)),rep("Bases", length(paramB1)))

data_to_plot_diss <- data.frame(param1,param2,param3,param4,GroupType)


p2<-ggpairs(data_to_plot_diss,columns = 1:4, columnLabels = c("etacdS1m1","etacdS1m2","etacdS1m3", "etacdS1m4"),
        labeller = "label_parsed",
        legend =1,
        aes(color = GroupType, alpha = 0.5),
        upper = list(continuous = "points"))+
        scale_alpha(guide = "none")


paramA <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etacdS1Ac", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)
paramA <- melt(paramA)
paramA <- matrix(paramA$value,nrow = datastruct$nGroupsA, byrow = TRUE)
paramA1 <- paramA[,1]
paramA2 <- paramA[,2]
paramA3 <- paramA[,3]
paramA4 <- paramA[,4]

paramB <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etacdS1Bc", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)
paramB <- melt(paramB)
paramB <- matrix(paramB$value,nrow = datastruct$nGroupsB, byrow = TRUE)
paramB1 <- paramB[,1]
paramB2 <- paramB[,2]
paramB3 <- paramB[,3]
paramB4 <- paramB[,4]

param1 <- c(paramA1,paramB1)
param2 <- c(paramA2,paramB2)
param3 <- c(paramA3,paramB3)
param4 <- c(paramA4,paramB4)

GroupType = c(rep("Acids", length(paramA1)),rep("Bases", length(paramB1)))

data_to_plot_diss <- data.frame(param1,param2,param3,param4,GroupType)


p3<-ggpairs(data_to_plot_diss,columns = 1:4, columnLabels = c("etacdS11","etacdS12","etacdS13", "etacdS14"),
        labeller = "label_parsed",
        legend =1,
        aes(color = GroupType, alpha = 0.5),
        upper = list(continuous = "points"))+
        scale_alpha(guide = "none")
ggsave(paste0("figures\\etaplots\\", "dissociated.dlogkw", ".png"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\etaplots\\", "dissociated.dS1m", ".png"), plot=p2, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\etaplots\\", "dissociated.dS1", ".png"), plot=p3, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\etaplots\\", "dissociated.dlogkw", ".pdf"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\etaplots\\", "dissociated.dS1m", ".pdf"), plot=p2, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\etaplots\\", "dissociated.dS1", ".pdf"), plot=p3, width = 20, height = 20, units = "cm")

print(p1)
print(p2)
print(p3)


```

### Effect of functional groups (exploratory)

The following plots present the relationship between individual eta values for logkwN and number of functional groups. This part is exploratory. Graphs are shown if there are at least 10 functional groups present in the dataset.

```{r functionalgroupseffects}
param1 <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etalogkwN", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)

cparam <- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep("^etaclogkwNc", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)
cparam <- melt(cparam)
cparam <- matrix(cparam$value,nrow = nAnalytes, byrow = TRUE)
cparam1 <- cparam[,1]
cparam2 <- cparam[,2]
cparam3 <- cparam[,3]
cparam4 <- cparam[,4]

for(i in which(totalnrgroups>10)){
nrgroups = as.factor(nrfungroups[,i])

data_to_plot_fungr <- data.frame(param1,cparam1,cparam2,cparam3,cparam4, nrgroups)

p1<-data_to_plot_fungr %>% tidyr::gather("name", "count", 1:5)  %>%
   mutate(etaname = case_when(name == "param1" ~ "etalogkwN",
                        name == "cparam1" ~ "etaclogkwN_1",
                        name == "cparam2" ~ "etaclogkwN_2",
                        name == "cparam3" ~ "etaclogkwN_3",
                        name == "cparam4" ~ "etaclogkwN_4"
                        ))  %>%
   ggplot(., aes(y=count, x=nrgroups))+
   geom_boxplot()+
   facet_wrap(.~etaname)+
   labs(title=paste(functionalgroupsnames[i,2]), x="Nr of functional groups", y="eta")


 ggsave(paste0("figures\\etaplots\\functionalgroupseffects\\", functionalgroupsnames[i,2], ".png"), plot=p1, width = 20, height = 20, units = "cm")
 ggsave(paste0("figures\\etaplots\\functionalgroupseffects\\", functionalgroupsnames[i,2], ".pdf"), plot=p1, width = 20, height = 20, units = "cm")
 print(p1)

}
```

## Comparison of observed and model predicted retention times

The individual and population model predictions were simulated using a more dense design. The individual predictions are based on population-level parameters, predictors, and all of the observed retention time measurements. The population predictions are based on population-level parameters and predictors.

```{r load-fitsim}
fitsim <- cmdstanr::as_cmdstan_fit(c(
                                 #  'stanfiles/output_1.csv',
                                 #  'stanfiles/output_2.csv',
                                 #  'stanfiles/output_3.csv',
                                 #  'stanfiles/output_4.csv',
                                 #  'stanfiles/output_5.csv',
                                 #  'stanfiles/output_6.csv',
                                 #  'stanfiles/output_7.csv',
                                    'stanfiles/output_8.csv'
                                ))

```

```{r load-design}
design <- read.csv('data/hplcparam_design.csv')
design$Mod  = as.character(design$Mod)
design$Mod2 = ifelse(design$Mod=="MeOH",1,2) # MeOH = 1, ACN = 2
design$expid = match(design$expid, unique(design$expid))
nAnalytes <- datastruct$nAnalytes
nColumns <- datastruct$nColumns
nExp <- nrow(design);
datasim <- design %>%
           slice(rep(row_number(), nAnalytes*nColumns)) %>%
           mutate(Column = rep(c(1,2,3,4,5), each = nExp*nAnalytes)) %>%
           mutate(METID = rep(rep(unique(data$METID),each=nExp),nColumns))
datasim$expid = datasim$expid*(2-datasim$Colum) + (length(unique(datasim$expid))+datasim$expid) *(datasim$Colum-1)
datasim$ColumnName = ifelse(datasim$Column==1,"XBridge Shield RP18",
                            ifelse(datasim$Column==2,"XTerra MS C18",
                                   ifelse(datasim$Column==3,"XBridge Phenyl",
                                          ifelse(datasim$Column==4,"XBridge C8", "Xterra MS C8"))))

datasim$to[datasim$Column==1] = 0.532
datasim$to[datasim$Column==2] = 0.542
datasim$to[datasim$Column==3] = 0.542
datasim$to[datasim$Column==4] = 0.552
datasim$to[datasim$Column==5] = 0.566

datastructsim <-datastruct
datastructsim$nObs=length(datasim$METID)
datastructsim$analyte=match(datasim$METID, unique(datasim$METID))
datastructsim$modifier=match(datasim$Mod2, sort(unique(datasim$Mod2)))
datastructsim$steps=4*(2-datasim$Mod2) + 10*(datasim$Mod2-1)
datastructsim$column=match(datasim$Column, unique(datasim$Column))
datastructsim$hplcparam=cbind(datasim$tg,datasim$td,datasim$to,datasim$te,
                              datasim$fio,datasim$fik,datasim$Mod2-1,datasim$pHo,
                              datasim$alpha1,datasim$alpha2,(datasim$Temp-25)/10,
                              datasim$Column-1)
datastructsim$trobs = rep(0,datastructsim$nObs)

```

```{r sim-gg, eval = FALSE}

model_sim <- cmdstan_model("stan/hplc-gra-fivecolumns-sim.stan")

fit_sim  <- model_sim$generate_quantities(fitsim,
                                         data = datastructsim,
                                         seed = 123,
                                         parallel_chains = 4,
                                         output_dir = "stanfiles")
```

```{r sim-load}
x<- cmdstanr::read_cmdstan_csv(c(
                                  'stanfiles/hplc-gra-fivecolumns-sim-202308240900-1-3a5236.csv'
                                ))

draws_sim_df <- as_draws_df(x$generated_quantities)

# draws_sim_df <- fit_sim$draws(format = "df")

tr_sim_Cond <- apply(draws_sim_df[,which(colnames(draws_sim_df) %in% grep("^trCond", names(draws_sim_df), value = TRUE))], MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))
tr_sim_Pred <- apply(draws_sim_df[,which(colnames(draws_sim_df) %in% grep("^trPred", names(draws_sim_df), value = TRUE))], MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))

tr_sim_Cond<-as.data.frame(t(tr_sim_Cond))

datasim$trCond_l=tr_sim_Cond$`5%`
datasim$trCond_m=tr_sim_Cond$`50%`
datasim$trCond_h=tr_sim_Cond$`95%`

tr_sim_Pred<-as.data.frame(t(tr_sim_Pred))

datasim$trPred_l=tr_sim_Pred$`5%`
datasim$trPred_m=tr_sim_Pred$`50%`
datasim$trPred_h=tr_sim_Pred$`95%`

```

### Individual predictions:

```{r individualpred}
analyte_ID_sample <- c(9,17,33,58,140,180)

#analyte_ID_sample <-unique(data$METID)

for(i in 1:length(analyte_ID_sample)){

p <- ggplot()+
     geom_point(data=data[which(data$METID %in% analyte_ID_sample[i]),],
                aes(x = pHs, y = RT, color = as.factor(tg)))+
     geom_line(data=datasim[which(datasim$METID %in% analyte_ID_sample[i]),],
               aes(x = pHs, y = trCond_m, color = as.factor(tg)))+
     geom_ribbon(data=datasim[which(datasim$METID %in% analyte_ID_sample[i]),],
                 aes(x = pHs, ymin = trCond_l, ymax = trCond_h, fill = as.factor(tg)), alpha = 0.25)+
     xlim(2,11)+
     facet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+
      labs(title=paste(dataNames$Name[analyte_ID_sample[i]]),
           x ="pH",
           y = "Retention time (individual), min",
           color = "tg, min",
           fill = "tg, min")

ggsave(paste0("figures\\concordanceplots\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".individual", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\concordanceplots\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".individual", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

print(p)

}

```

### Population predictions:

```{r populationrped}
analyte_ID_sample <- c(9,17,33,58,140,180)

for(i in 1:length(analyte_ID_sample)){
p <- ggplot()+
     geom_point(data=data[which(data$METID %in% analyte_ID_sample[i]),],
                aes(x = pHs, y = RT, color = as.factor(tg)))+
     geom_line(data=datasim[which(datasim$METID %in% analyte_ID_sample[i]),],
               aes(x = pHs, y = trPred_m, color = as.factor(tg)))+
     geom_ribbon(data=datasim[which(datasim$METID %in% analyte_ID_sample[i]),],
                aes(x = pHs, ymin = trPred_l, ymax = trPred_h, fill = as.factor(tg)), alpha = 0.25)+
     xlim(2,11)+
     facet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+
      labs(title=paste(dataNames$Name[analyte_ID_sample[i]]),
           x ="pH",
           y = "Retention time (population), min",
           color = "tg, min",
           fill = "tg, min")

ggsave(paste0("figures\\concordanceplots\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".population", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\concordanceplots\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".population", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

print(p)
}

```

### Uncertainity chromatogram

Below is the example of an uncertainty chromatogram expected for tg = 90 min, pH = 8.9, Temp = $25^oC$ in ACN. The individual and population predictions are shown.

```{r epred-gq, eval = FALSE}

model_epred <- cmdstan_model("stan/hplc-gra-fivecolumns-epred.stan")

fit_epred  <- model_epred$generate_quantities(fitsim,
                                         data = datastructsim,
                                         seed = 123,
                                         parallel_chains = 4,
                                         output_dir = "stanfiles")
```

```{r load-epred-gq}
x<- cmdstanr::read_cmdstan_csv(c(
                                'stanfiles/hplc-gra-fivecolumns-epred-202308240927-1-1ff2c7.csv'
                                ))

draws_epred_df <- as_draws_df(x$generated_quantities)
```

```{r uncertainitychromatogram}
analyte_ID_sample <-c(9,17,33,58,140,180)

col.labs <- c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8")
wpCond= data.frame()
wpPred= data.frame()

for (i in 1:5) {
idx <- which(datasim$METID %in% analyte_ID_sample &
               datasim$tg==90 & # c(30, 90, 270)
               datasim$pH== 7 &   # c(1:9)
               datasim$Column==i &  # c(1, 2)
               datasim$Mod2==2 & # c(1, 2)
               datasim$Temp==25) # c(25, 35)

data_to_plot <- draws_epred_df[,which(colnames(draws_epred_df) %in% paste0("trHatCond[",idx,"]"))]
colnames(data_to_plot) <- paste(dataNames$Name[analyte_ID_sample])
wpCond1 <- melt(data_to_plot)
wpCond1$Column <- unname(col.labs[i])
data_to_plot <- draws_epred_df[,which(colnames(draws_epred_df) %in% paste0("trHatPred[",idx,"]"))]
colnames(data_to_plot) <- paste(dataNames$Name[analyte_ID_sample])
wpPred1 <- melt(data_to_plot)
wpPred1$Column <- unname(col.labs[i])
wpCond= rbind(wpCond,wpCond1)
wpPred= rbind(wpPred,wpPred1)
}

wpCond$Column=as.factor(wpCond$Column)
wpPred$Column=as.factor(wpPred$Column)

p1 <- ggplot(data = wpCond)+
     geom_density(aes(x=value, colour=variable)) +
     labs(title="uncertainty chromatogram (individual predictions)",
          x ="Retention time, min",
          y = "pdf",
          colour="Analyte")+
     xlim(c(0,80))+
     facet_wrap(.~Column, nrow=3,scales = "free")+
     theme(legend.position = c(1, 0),
        legend.justification = c(1, 0))


p2 <- ggplot(data = wpPred)+
     geom_density(aes(x=value, colour=variable)) +
     labs(title="uncertainty chromatogram (population predicitons)",
          x ="Retention time, min",
          y = "pdf",
          colour="Analyte")+
     xlim(c(0,80))+
     facet_wrap(.~Column, nrow=3,scales = "free")+
     theme(legend.position = c(1, 0),
        legend.justification = c(1, 0))

p3 <- ggplot()+
      geom_density(data = wpCond,aes(x=value, colour=variable, fill=variable),linetype = "solid", lwd=0.25) +
      geom_density(data = wpPred,aes(x=value, y = ..density..*100, colour=variable, fill=variable), linetype = "solid",      lwd=0.25,  alpha=0.1) +
        scale_y_continuous(sec.axis = sec_axis(~./100)) +
     labs(title="uncertainty chromatogram (individual and population)",
          x ="Retention time, min",
          y = "pdf",
          colour="Analyte")+
     xlim(c(0,80))+
     facet_wrap(.~Column, nrow=3,scales = "free")+
     theme(legend.position = c(1, 0),
        legend.justification = c(1, 0))+
  guides(fill = "none")

ggsave(paste0("figures\\concordanceplots\\", "uncertainitychromatogram.individual", ".png"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\concordanceplots\\", "uncertainitychromatogram.population", ".png"), plot=p2, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\concordanceplots\\", "uncertainitychromatogram.individual", ".pdf"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\concordanceplots\\", "uncertainitychromatogram.population", ".pdf"), plot=p2, width = 20, height = 20, units = "cm")

ggsave(paste0("figures\\concordanceplots\\", "uncertainitychromatogram.joined", ".png"), plot=p3, width = 20, height = 20, units = "cm")

ggsave(paste0("figures\\concordanceplots\\", "uncertainitychromatogram.joined", ".pdf"), plot=p3, width = 20, height = 20, units = "cm")

print(p3)

ggsave(paste0("figures\\concordanceplots\\", "uncertainitychromatogram.joined-manuscript", ".png"),
       p3,
       device = ragg::agg_png(width = 8.4582, height = 8.4582, units = "cm", res = 300, scaling=0.522))


```

## Isocratic predictions (population predictions)

To better asses the impact of parameters on retention we created graphs presenting the isocratic logarithm of retention factor vs. $\small \varphi$ for selected analytes. Separate graphs are shown for each dissociation form (r=1, r=2, r=3). Here the population predictions are shown:

```{r izo-pred-population}
analyte_ID_sample <-c(9,17,33,58,140,180)

for(i in 1:length(analyte_ID_sample)){

idx_analyte = which(unique(data$METID)==analyte_ID_sample[i])
draws_df_subset <- draws_epred_df[,which(colnames(draws_epred_df) %in% c(
                sprintf("logkwxPred[%s,1,1]",idx_analyte),
                sprintf("logkwxPred[%s,1,2]",idx_analyte),
                sprintf("logkwxPred[%s,1,3]",idx_analyte),
                sprintf("logkwxPred[%s,2,1]",idx_analyte),
                sprintf("logkwxPred[%s,2,2]",idx_analyte),
                sprintf("logkwxPred[%s,2,3]",idx_analyte),
                sprintf("logkwxPred[%s,3,1]",idx_analyte),
                sprintf("logkwxPred[%s,3,2]",idx_analyte),
                sprintf("logkwxPred[%s,3,3]",idx_analyte),
                sprintf("logkwxPred[%s,4,1]",idx_analyte),
                sprintf("logkwxPred[%s,4,2]",idx_analyte),
                sprintf("logkwxPred[%s,4,3]",idx_analyte),
                sprintf("logkwxPred[%s,5,1]",idx_analyte),
                sprintf("logkwxPred[%s,5,2]",idx_analyte),
                sprintf("logkwxPred[%s,5,3]",idx_analyte),
                sprintf("S1xPred[%s,1,1,1]",idx_analyte),
                sprintf("S1xPred[%s,1,1,2]",idx_analyte),
                sprintf("S1xPred[%s,1,1,3]",idx_analyte),
                sprintf("S1xPred[%s,2,1,1]",idx_analyte),
                sprintf("S1xPred[%s,2,1,2]",idx_analyte),
                sprintf("S1xPred[%s,2,1,3]",idx_analyte),
                sprintf("S1xPred[%s,1,2,1]",idx_analyte),
                sprintf("S1xPred[%s,1,2,2]",idx_analyte),
                sprintf("S1xPred[%s,1,2,3]",idx_analyte),
                sprintf("S1xPred[%s,2,2,1]",idx_analyte),
                sprintf("S1xPred[%s,2,2,2]",idx_analyte),
                sprintf("S1xPred[%s,2,2,3]",idx_analyte),
                sprintf("S1xPred[%s,1,3,1]",idx_analyte),
                sprintf("S1xPred[%s,1,3,2]",idx_analyte),
                sprintf("S1xPred[%s,1,3,3]",idx_analyte),
                sprintf("S1xPred[%s,2,3,1]",idx_analyte),
                sprintf("S1xPred[%s,2,3,2]",idx_analyte),
                sprintf("S1xPred[%s,2,3,3]",idx_analyte),
                sprintf("S1xPred[%s,1,4,1]",idx_analyte),
                sprintf("S1xPred[%s,1,4,2]",idx_analyte),
                sprintf("S1xPred[%s,1,4,3]",idx_analyte),
                sprintf("S1xPred[%s,2,4,1]",idx_analyte),
                sprintf("S1xPred[%s,2,4,2]",idx_analyte),
                sprintf("S1xPred[%s,2,4,3]",idx_analyte),
                sprintf("S1xPred[%s,1,5,1]",idx_analyte),
                sprintf("S1xPred[%s,1,5,2]",idx_analyte),
                sprintf("S1xPred[%s,1,5,3]",idx_analyte),
                sprintf("S1xPred[%s,2,5,1]",idx_analyte),
                sprintf("S1xPred[%s,2,5,2]",idx_analyte),
                sprintf("S1xPred[%s,2,5,3]",idx_analyte),
                "S2xPred[1,1]",
                "S2xPred[2,1]",
                ".draw",".iteration",".chain"))]

p<-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(logkwxPred[, c, r], S1xPred[, m, c, r], S2xPred[m, ]) %>%
  filter(r<=R[idx_analyte]+1)  %>%
  tidyr::expand_grid(fi = seq(0,1,0.1)) %>%
  mutate(logkPred = logkwxPred-S1xPred*(1+S2xPred)*fi/(1+S2xPred*fi)) %>%
  ggplot(aes(x = fi, y = logkPred, color = as.factor(c), fill = as.factor(c))) +
  ggdist::stat_lineribbon(.width = c(.90), alpha = 1/2) +
  facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))+
  labs(title=paste(dataNames$Name[analyte_ID_sample[i]]),color= " ",fill= " ", y = "logk (population)", x="\u03C6")+
  scale_fill_discrete(labels= c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8")) +
  scale_color_discrete(labels= c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8"))+
  geom_hline(yintercept= c(0,1), linetype="dashed",color="gray")

ggsave(paste0("figures\\izoparam\\isopred\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".population", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\izoparam\\isopred\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".population", ".pdf"), plot=p, width = 20, height = 20, units = "cm")
print(p)
}

```

Similarly we can quantify the column effects (between column differences in logk using XBridge Shield RP18 as a reference column):

```{r izo-diff-population}
analyte_ID_sample <-c(9,17,33,58,140,180)

for(i in 1:length(analyte_ID_sample)){

idx_analyte = which(unique(data$METID)==analyte_ID_sample[i])

draws_df_subset <- draws_epred_df[,which(colnames(draws_epred_df) %in% c(
                sprintf("logkwxPred[%s,1,1]",idx_analyte),
                sprintf("logkwxPred[%s,1,2]",idx_analyte),
                sprintf("logkwxPred[%s,1,3]",idx_analyte),
                sprintf("logkwxPred[%s,2,1]",idx_analyte),
                sprintf("logkwxPred[%s,2,2]",idx_analyte),
                sprintf("logkwxPred[%s,2,3]",idx_analyte),
                sprintf("logkwxPred[%s,3,1]",idx_analyte),
                sprintf("logkwxPred[%s,3,2]",idx_analyte),
                sprintf("logkwxPred[%s,3,3]",idx_analyte),
                sprintf("logkwxPred[%s,4,1]",idx_analyte),
                sprintf("logkwxPred[%s,4,2]",idx_analyte),
                sprintf("logkwxPred[%s,4,3]",idx_analyte),
                sprintf("logkwxPred[%s,5,1]",idx_analyte),
                sprintf("logkwxPred[%s,5,2]",idx_analyte),
                sprintf("logkwxPred[%s,5,3]",idx_analyte),
                sprintf("S1xPred[%s,1,1,1]",idx_analyte),
                sprintf("S1xPred[%s,1,1,2]",idx_analyte),
                sprintf("S1xPred[%s,1,1,3]",idx_analyte),
                sprintf("S1xPred[%s,2,1,1]",idx_analyte),
                sprintf("S1xPred[%s,2,1,2]",idx_analyte),
                sprintf("S1xPred[%s,2,1,3]",idx_analyte),
                sprintf("S1xPred[%s,1,2,1]",idx_analyte),
                sprintf("S1xPred[%s,1,2,2]",idx_analyte),
                sprintf("S1xPred[%s,1,2,3]",idx_analyte),
                sprintf("S1xPred[%s,2,2,1]",idx_analyte),
                sprintf("S1xPred[%s,2,2,2]",idx_analyte),
                sprintf("S1xPred[%s,2,2,3]",idx_analyte),
                sprintf("S1xPred[%s,1,3,1]",idx_analyte),
                sprintf("S1xPred[%s,1,3,2]",idx_analyte),
                sprintf("S1xPred[%s,1,3,3]",idx_analyte),
                sprintf("S1xPred[%s,2,3,1]",idx_analyte),
                sprintf("S1xPred[%s,2,3,2]",idx_analyte),
                sprintf("S1xPred[%s,2,3,3]",idx_analyte),
                sprintf("S1xPred[%s,1,4,1]",idx_analyte),
                sprintf("S1xPred[%s,1,4,2]",idx_analyte),
                sprintf("S1xPred[%s,1,4,3]",idx_analyte),
                sprintf("S1xPred[%s,2,4,1]",idx_analyte),
                sprintf("S1xPred[%s,2,4,2]",idx_analyte),
                sprintf("S1xPred[%s,2,4,3]",idx_analyte),
                sprintf("S1xPred[%s,1,5,1]",idx_analyte),
                sprintf("S1xPred[%s,1,5,2]",idx_analyte),
                sprintf("S1xPred[%s,1,5,3]",idx_analyte),
                sprintf("S1xPred[%s,2,5,1]",idx_analyte),
                sprintf("S1xPred[%s,2,5,2]",idx_analyte),
                sprintf("S1xPred[%s,2,5,3]",idx_analyte),
                "S2xPred[1,1]",
                "S2xPred[2,1]",
                ".draw",".iteration",".chain"))]

p<-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(logkwxPred[, c, r], S1xPred[, m, c, r], S2xPred[m, ]) %>%
  filter(r<=R[idx_analyte]+1) %>%
  tidyr::expand_grid(fi = seq(0,1,0.05)) %>%
  mutate(logkPred = logkwxPred-S1xPred*(1+S2xPred)*fi/(1+S2xPred*fi)) %>%
  select(.draw,c,r,m,logkPred,fi) %>%
  tidyr::pivot_wider(names_from = c, values_from = logkPred) %>%
  mutate(cdk2 = `2`-`1` ) %>%
  mutate(cdk3 = `3`-`1` ) %>%
  mutate(cdk4 = `4`-`1` ) %>%
  mutate(cdk5 = `5`-`1` ) %>%
  tidyr::pivot_longer(cdk2:cdk5,names_to = "names_cdk", values_to = "cdk")%>%
   ggplot(aes(x = fi, y = cdk, color = as.factor(names_cdk), fill = as.factor(names_cdk))) +
   ggdist::stat_lineribbon(.width = c(.90), alpha = 1/2)+
   facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))+
   labs(y = "Between column difference in logk (population)", title=paste(dataNames$Name[analyte_ID_sample[i]]),color= " ",fill= " ", x="\u03C6")+
  scale_fill_discrete(labels= c("XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8")) +
  scale_color_discrete(labels= c("XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8"))+
   geom_hline(yintercept= c(0), linetype="dashed",color="gray") +
  coord_cartesian(xlim=c(0,1),ylim=c(-1,1))

ggsave(paste0("figures\\izoparam\\diff\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".population", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\izoparam\\diff\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".population", ".pdf"), plot=p, width = 20, height = 20, units = "cm")
  
 print(p)

}

```

or predict the organic modifier content leading to logk of 1:

```{r izo-logk1-population}
analyte_ID_sample <-c(9,17,33,58,140,180)

for(i in 1:length(analyte_ID_sample)){

idx_analyte = which(unique(data$METID)==analyte_ID_sample[i])

draws_df_subset <- draws_epred_df[,which(colnames(draws_epred_df) %in% c(
                sprintf("logkwxPred[%s,1,1]",idx_analyte),
                sprintf("logkwxPred[%s,1,2]",idx_analyte),
                sprintf("logkwxPred[%s,1,3]",idx_analyte),
                sprintf("logkwxPred[%s,2,1]",idx_analyte),
                sprintf("logkwxPred[%s,2,2]",idx_analyte),
                sprintf("logkwxPred[%s,2,3]",idx_analyte),
                sprintf("logkwxPred[%s,3,1]",idx_analyte),
                sprintf("logkwxPred[%s,3,2]",idx_analyte),
                sprintf("logkwxPred[%s,3,3]",idx_analyte),
                sprintf("logkwxPred[%s,4,1]",idx_analyte),
                sprintf("logkwxPred[%s,4,2]",idx_analyte),
                sprintf("logkwxPred[%s,4,3]",idx_analyte),
                sprintf("logkwxPred[%s,5,1]",idx_analyte),
                sprintf("logkwxPred[%s,5,2]",idx_analyte),
                sprintf("logkwxPred[%s,5,3]",idx_analyte),
                sprintf("S1xPred[%s,1,1,1]",idx_analyte),
                sprintf("S1xPred[%s,1,1,2]",idx_analyte),
                sprintf("S1xPred[%s,1,1,3]",idx_analyte),
                sprintf("S1xPred[%s,2,1,1]",idx_analyte),
                sprintf("S1xPred[%s,2,1,2]",idx_analyte),
                sprintf("S1xPred[%s,2,1,3]",idx_analyte),
                sprintf("S1xPred[%s,1,2,1]",idx_analyte),
                sprintf("S1xPred[%s,1,2,2]",idx_analyte),
                sprintf("S1xPred[%s,1,2,3]",idx_analyte),
                sprintf("S1xPred[%s,2,2,1]",idx_analyte),
                sprintf("S1xPred[%s,2,2,2]",idx_analyte),
                sprintf("S1xPred[%s,2,2,3]",idx_analyte),
                sprintf("S1xPred[%s,1,3,1]",idx_analyte),
                sprintf("S1xPred[%s,1,3,2]",idx_analyte),
                sprintf("S1xPred[%s,1,3,3]",idx_analyte),
                sprintf("S1xPred[%s,2,3,1]",idx_analyte),
                sprintf("S1xPred[%s,2,3,2]",idx_analyte),
                sprintf("S1xPred[%s,2,3,3]",idx_analyte),
                sprintf("S1xPred[%s,1,4,1]",idx_analyte),
                sprintf("S1xPred[%s,1,4,2]",idx_analyte),
                sprintf("S1xPred[%s,1,4,3]",idx_analyte),
                sprintf("S1xPred[%s,2,4,1]",idx_analyte),
                sprintf("S1xPred[%s,2,4,2]",idx_analyte),
                sprintf("S1xPred[%s,2,4,3]",idx_analyte),
                sprintf("S1xPred[%s,1,5,1]",idx_analyte),
                sprintf("S1xPred[%s,1,5,2]",idx_analyte),
                sprintf("S1xPred[%s,1,5,3]",idx_analyte),
                sprintf("S1xPred[%s,2,5,1]",idx_analyte),
                sprintf("S1xPred[%s,2,5,2]",idx_analyte),
                sprintf("S1xPred[%s,2,5,3]",idx_analyte),
                "S2xPred[1,1]",
                "S2xPred[2,1]",
                ".draw",".iteration",".chain"))]

p<-draws_df_subset %>%
  slice_sample(n=1000) %>%
  tidybayes::spread_draws(logkwxPred[, c, r], S1xPred[, m, c, r], S2xPred[m, ]) %>%
  filter(r<=R[idx_analyte]+1)  %>%
  mutate(foo = (logkwxPred-1)/S1xPred/(1+S2xPred)) %>%
  mutate(fix = foo/(1-S2xPred*foo)) %>%
  ggplot(aes(x = fix, color = as.factor(c), fill = as.factor(c))) +
  geom_density(alpha = 1/2) +
  coord_cartesian(xlim=c(0,1))+
  facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))+
  labs(title=paste(dataNames$Name[analyte_ID_sample[i]]),color= " ",fill= " ", x = "\u03C6 leading to logk=1 (population)")+
  scale_fill_discrete(labels= c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8")) +
  scale_color_discrete(labels= c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8"))+
  facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))

ggsave(paste0("figures\\izoparam\\filogk1\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".population", ".png"), plot=p, width = 20, height = 20, units = "cm")
 ggsave(paste0("figures\\izoparam\\filogk1\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".population", ".pdf"), plot=p, width = 20, height = 20, units = "cm")
 
print(p)

}

```

## Effect of logP

The following plot show the effect of log P on isocratic retention times (population predictions) for typical neutral (N), basic (B) and acidic (A) analyte. The uncertainties are large and not shown to improve visibility.

```{r logPgq, eval = FALSE}

model_logP <- cmdstan_model("stan/hplc-gra-fivecolumns-logP.stan")

fit_logP  <- model_logP$generate_quantities(fitsim,
                                         data = datastruct,
                                         seed = 123,
                                         parallel_chains = 4,
                                         output_dir = "stanfiles")
```

```{r load-logP}
x<- cmdstanr::read_cmdstan_csv(c(
                                  'stanfiles/hplc-gra-fivecolumns-logP-202308240954-1-6e86d7.csv'
                                ))
draws_logP_df <- as_draws_df(x$generated_quantities)
# draws_epred_df <- fit_epred$draws(format = "df")
```

```{r plot-logP-effects}

logPsim = c(0,1.5,3,4.5,6)
col.labs <- c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8")
names(col.labs) <- c('1','2','3','4','5')
diss2.labs <- c("Basic","Neutral","Acidic")
names(diss2.labs) <- c(1,2,3)
logP.labs <- c("logP=0","logP=3","logP=6")
names(logP.labs) <- c(1,3,5)
mydata <- list()

savetheme <- theme(
        legend.position="bottom",
        legend.box = "vertical",
        axis.text=element_text(size=10),
        axis.text.x = element_text(size = 8),
        axis.text.y = element_text(size = 8),
        legend.text = element_text(size=10),
        strip.text.x = element_text(size = 10),
        strip.text.y = element_text(size = 10))

for(i in 1:3){

idx_analyte =c(1,3,5)[i]
mydata[[i]]<- draws_logP_df[,which(colnames(draws_logP_df) %in% c(
                sprintf("logkwxPred[%s,1,1]",idx_analyte),
                sprintf("logkwxPred[%s,1,2]",idx_analyte),
                sprintf("logkwxPred[%s,1,3]",idx_analyte),
                sprintf("logkwxPred[%s,2,1]",idx_analyte),
                sprintf("logkwxPred[%s,2,2]",idx_analyte),
                sprintf("logkwxPred[%s,2,3]",idx_analyte),
                sprintf("logkwxPred[%s,3,1]",idx_analyte),
                sprintf("logkwxPred[%s,3,2]",idx_analyte),
                sprintf("logkwxPred[%s,3,3]",idx_analyte),
                sprintf("logkwxPred[%s,4,1]",idx_analyte),
                sprintf("logkwxPred[%s,4,2]",idx_analyte),
                sprintf("logkwxPred[%s,4,3]",idx_analyte),
                sprintf("logkwxPred[%s,5,1]",idx_analyte),
                sprintf("logkwxPred[%s,5,2]",idx_analyte),
                sprintf("logkwxPred[%s,5,3]",idx_analyte),
                sprintf("S1xPred[%s,1,1,1]",idx_analyte),
                sprintf("S1xPred[%s,1,1,2]",idx_analyte),
                sprintf("S1xPred[%s,1,1,3]",idx_analyte),
                sprintf("S1xPred[%s,2,1,1]",idx_analyte),
                sprintf("S1xPred[%s,2,1,2]",idx_analyte),
                sprintf("S1xPred[%s,2,1,3]",idx_analyte),
                sprintf("S1xPred[%s,1,2,1]",idx_analyte),
                sprintf("S1xPred[%s,1,2,2]",idx_analyte),
                sprintf("S1xPred[%s,1,2,3]",idx_analyte),
                sprintf("S1xPred[%s,2,2,1]",idx_analyte),
                sprintf("S1xPred[%s,2,2,2]",idx_analyte),
                sprintf("S1xPred[%s,2,2,3]",idx_analyte),
                sprintf("S1xPred[%s,1,3,1]",idx_analyte),
                sprintf("S1xPred[%s,1,3,2]",idx_analyte),
                sprintf("S1xPred[%s,1,3,3]",idx_analyte),
                sprintf("S1xPred[%s,2,3,1]",idx_analyte),
                sprintf("S1xPred[%s,2,3,2]",idx_analyte),
                sprintf("S1xPred[%s,2,3,3]",idx_analyte),
                sprintf("S1xPred[%s,1,4,1]",idx_analyte),
                sprintf("S1xPred[%s,1,4,2]",idx_analyte),
                sprintf("S1xPred[%s,1,4,3]",idx_analyte),
                sprintf("S1xPred[%s,2,4,1]",idx_analyte),
                sprintf("S1xPred[%s,2,4,2]",idx_analyte),
                sprintf("S1xPred[%s,2,4,3]",idx_analyte),
                sprintf("S1xPred[%s,1,5,1]",idx_analyte),
                sprintf("S1xPred[%s,1,5,2]",idx_analyte),
                sprintf("S1xPred[%s,1,5,3]",idx_analyte),
                sprintf("S1xPred[%s,2,5,1]",idx_analyte),
                sprintf("S1xPred[%s,2,5,2]",idx_analyte),
                sprintf("S1xPred[%s,2,5,3]",idx_analyte),
                "S2xPred[1,1]",
                "S2xPred[2,1]",
                ".draw",".iteration",".chain"))]

}

draws_df_subset<-cbind(mydata[[1]][,1:45],mydata[[2]][,1:45],mydata[[3]])

p<-draws_df_subset %>%
  slice_sample(n=500) %>%
  tidybayes::spread_draws(logkwxPred[p, c, r], S1xPred[p, m, c, r], S2xPred[m, ]) %>%
  tidyr::expand_grid(fi = seq(0,1,0.1)) %>%
  mutate(logkPred = logkwxPred-S1xPred*(1+S2xPred)*fi/(1+S2xPred*fi)) %>%
  ungroup() %>%
  group_by(p,m,c,r,fi) %>%
  summarise(mlogkPred=median(logkPred)) %>%
  ggplot(aes(x = fi, y = mlogkPred, size = as.factor(c), color = as.factor(c), fill = as.factor(r), linetype = as.factor(m))) +
  geom_line() +
  facet_grid(r~p,labeller = labeller(r=diss2.labs, p=logP.labs))+
  labs(color= " ", linetype= " ", y="typical logk",x="\u03C6")+
  scale_fill_discrete(labels= c("B", "N", "A")) +
  scale_color_discrete(labels= c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8"))+
  scale_linetype_manual(labels= c("MeOH", "ACN"), values = c("solid","dashed")) +
  scale_size_manual(values = c("1"=1,"2"=0.5, "3"=0.5, "4"=0.5, "5"=0.5))+
  theme(
        legend.position="bottom",
        legend.box = "vertical",
        strip.text.x = element_text(size = 8),
        strip.text.y = element_text(size = 8))+
  coord_cartesian(xlim=c(0,1),ylim=c(-2,4))+
  guides(size="none")

ggsave(paste0("figures\\logPeffects\\logPjoined", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\logPeffects\\logPjoined", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

print(p)

ggsave(paste0("figures\\logPeffects\\logPjoined-manuscript", ".png"),
       p,
       device = ragg::agg_png(width = 8.4582, height = 8.4582, units = "cm", res = 300, scaling=0.55))

# for toc
toc<-draws_df_subset %>%
  slice_sample(n=500) %>%
  tidybayes::spread_draws(logkwxPred[p, c, r], S1xPred[p, m, c, r], S2xPred[m, ]) %>%
  tidyr::expand_grid(fi = seq(0,1,0.1)) %>%
  mutate(logkPred = logkwxPred-S1xPred*(1+S2xPred)*fi/(1+S2xPred*fi)) %>%
  ungroup() %>%
  group_by(p,m,c,r,fi) %>%
  summarise(mlogkPred=median(logkPred)) %>%
  subset(r==2 & p==3) %>%
  ggplot(aes(x = fi, y = mlogkPred, size = as.factor(c), color = as.factor(c), fill = as.factor(r), linetype = as.factor(m))) +
  geom_line() +
  labs(color= " ", linetype= " ", y="typical logk",x="\u03C6",title = "logP = 3, neutral, 25\u00b0C")+
  scale_fill_discrete(labels= c("B", "N", "A")) +
  scale_color_discrete(labels= c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8"))+
  scale_linetype_manual(labels= c("MeOH", "ACN"), values = c("solid","dashed")) +
  scale_size_manual(values = c("1"=1,"2"=0.5, "3"=0.5, "4"=0.5, "5"=0.5))+
  theme(plot.title=element_text(size=8),
        axis.title = element_text(size = 8),
        axis.text.x = element_text(size = 6),
        axis.text.y = element_text(size = 6),
        legend.text = element_text(size=6),
        strip.text.x = element_text(size = 6),
        strip.text.y = element_text(size = 6),
        legend.key.height =  unit(0.4, 'cm'),
        legend.title= element_blank())+
  coord_cartesian(xlim=c(0,1),ylim=c(-2,4))+
  guides(size="none")


ggsave(paste0("figures\\toc\\TOC", ".png"), plot=toc, width = 8.47, height = 4.76, units = "cm")
ggsave(paste0("figures\\toc\\TOC", ".svg"), plot=toc, width = 8.47, height = 4.76, units = "cm")

```
## Goodness of fit plots

Several goodness of fit plots were used to describe how well the model fits our set of observations.

```{r residualsqq, eval = FALSE}

model_restr <- cmdstan_model("stan/hplc-gra-fivecolumns-residuals.stan")

fit_restr  <- model_restr$generate_quantities(fitsim,
                                         data = datastruct,
                                         seed = 123,
                                         parallel_chains = 4,
                                         output_dir = "stanfiles")

```

```{r residuals-load}
x<- cmdstanr::read_cmdstan_csv(c(
                                  'stanfiles/hplc-gra-fivecolumns-residuals-202308240959-1-8d8bd3.csv'
                                ))

draws_restr_df <- as_draws_df(x$generated_quantities)
# draws_restr_df <- fit_restr$draws(format = "df")

trCond <- apply(draws_restr_df[,which(colnames(draws_restr_df) %in% grep("^trHatCond", names(draws_restr_df), value = TRUE))], MARGIN = 2, FUN = mean)

trPred <- apply(draws_restr_df[,which(colnames(draws_restr_df) %in% grep("^trHatPred", names(draws_restr_df), value = TRUE))], MARGIN = 2, FUN = mean)

restrCond <- apply(draws_restr_df[,which(colnames(draws_restr_df) %in% grep("^restrCond", names(draws_restr_df), value = TRUE))], MARGIN = 2, FUN = mean)

restrPred <- apply(draws_restr_df[,which(colnames(draws_restr_df) %in% grep("^restrPred", names(draws_restr_df), value = TRUE))], MARGIN = 2, FUN = mean)

data$trCond = trCond
data$trPred = trPred
data$restrCond = restrCond
data$restrPred = restrPred
```

Individual and population residuals:

```{r plot-residuals}
p1 <- ggplot()+
      geom_jitter(data=data, aes(x = pHs, y = restrCond, color = as.factor(tg), shape=as.factor(ColumnName)),width = 0.1, height = 0)+
      facet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+
      labs(x ="pH", y = "Individual residuals, min", color = "Gradient time, min", shape = 'Column')+
      ylim(-10,10)

p2 <- ggplot()+
      geom_jitter(data=data, aes(x = pHs, y = restrPred, color = as.factor(tg), shape=as.factor(ColumnName)),width = 0.1, height = 0)+
      facet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+
      labs(x ="pH", y = "Population residuals, min", color = "Gradient time, min", shape = 'Column')

ggsave(paste0("figures\\concordanceplots\\", "individualresiduals", ".png"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\concordanceplots\\", "individualresiduals", ".pdf"), plot=p1, width = 20, height = 20, units = "cm")

ggsave(paste0("figures\\concordanceplots\\", "populationresiduals", ".png"), plot=p2, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\concordanceplots\\", "populationresiduals", ".pdf"), plot=p2, width = 20, height = 20, units = "cm")


print(p1)
print(p2)
```

Observed vs. population and individual predictions:

```{r plot-dv-vs-pred}
p1 <- ggplot()+
      geom_point(data=data, aes(x = trCond, y = RT, color = as.factor(tg), shape=as.factor(ColumnName)))+
      facet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+
      labs(y ="Observed retention time, min",
           x = "Individual predicted retention time, min",
           color = "tg, min",
           shape = 'Column')+
      xlim(0,300) +
      ylim(0,300) +
      geom_abline(intercept = 0, slope = 1)

p2 <- ggplot()+
      geom_point(data=data, aes(x = trPred, y = RT, color = as.factor(tg), shape=as.factor(ColumnName)))+
      facet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+
      labs(y ="Observed retention time, min",
           x = "Population predicted retention time, min",
           color = "tg, min",
           shape = 'Column')+
      xlim(0,300) +
      ylim(0,300) +
      geom_abline(intercept = 0, slope = 1)

ggsave(paste0("figures\\concordanceplots\\", "individual", ".png"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\concordanceplots\\", "population", ".png"), plot=p2, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\concordanceplots\\", "individual", ".pdf"), plot=p1, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\concordanceplots\\", "population", ".pdf"), plot=p2, width = 20, height = 20, units = "cm")

print(p1)
print(p2)

```

# Predictions and decision making. Case study 1

Here we want to show applicability of the model to predicting the best chromatogram using all the available data.

```{r casestudy1-fitdata, eval = FALSE}
fit_red1<- cmdstanr::as_cmdstan_fit(c(
                                 # 'stanfiles/output_1.csv',
                                 # 'stanfiles/output_2.csv',
                                 # 'stanfiles/output_3.csv',
                                 # 'stanfiles/output_4.csv',
                                  'stanfiles/output_5.csv',
                                  'stanfiles/output_6.csv',
                                  'stanfiles/output_7.csv',
                                  'stanfiles/output_8.csv'
                                ))

```

## Utility maps

For that purpose, we will use decision theory. We start by specifying a notion of utility to each outcome (uncertainty chromatogram). The Bayesian-based optimal decision is the one that maximizes expected utility. Our utility function is calcualted based on the lowest retention time across analytes ($\small mintr$), the highest retention time across analytes $\small maxtr$, and the difference in retention times between the critical pair of analytes ($\small res$). This utility is zero if at least one of the analytes has retention higher than 40, less than 2 min, or the difference in retention times is less than 2. Otherwise, it favors shorter runs. (.) denotes design variables.

$$
U(.)= I((mintr(.)>2) \ \& \ (res(.)>2)) \cdot (40-maxtr(.)) \cdot I(maxtr(.)<40)
$$

$$
\begin{aligned}
 I(x) = 1 \ if \ condition \ x  \ is \ true, \\
 I(x) = 0 \ if \ condition \ x  \ is \ false
\end{aligned}
$$
To find the maximum we use a grid search over a wide range of chromatographic conditions:

```{r casestudy1-preparedatasim}
upH <- datasim %>%
  select(1:20) %>%
  distinct(Temp,Mod, pHo, alpha1, alpha2) %>%
  group_by(Temp,Mod) %>%
  tidyr::complete(pHo = seq(min(pHo), max(pHo), len = 17)) %>%
  arrange(Temp,Mod,pHo) %>%
  mutate(alpha1 = zoo::na.approx(alpha1,pHo)) %>%
  mutate(alpha2 = zoo::na.approx(alpha2,pHo)) %>%
  group_by(Temp,Mod) %>%
  mutate(pHid = row_number()) %>%
  group_by(pHid)  %>%
  mutate(pHs = round(mean(pHo),2)) %>%
  ungroup()

datasim2 <- datasim %>%
  select(1:20) %>%
  filter(tg==30, Temp==25) %>%
  select(-tg, -fio, -expid, -pHs, -pHo, -alpha1, -alpha2, -pH) %>%
  distinct() %>%
 tidyr::expand_grid(fio = seq(0.05,0.2,0.05),tg = seq(20,260,20), pHs=unique(upH$pHs))%>%
  left_join(upH, by = join_by(pHs, Mod, Temp), relationship = "many-to-one") %>%
  group_by(tg, fio, Mod, Column, pHs) %>%
  mutate(expid = cur_group_id()) %>%
  ungroup()

datastructsim2 <-datastruct
datastructsim2$nObs=length(datasim2$METID)
datastructsim2$analyte=match(datasim2$METID, unique(datasim2$METID))
datastructsim2$modifier=match(datasim2$Mod2, sort(unique(datasim2$Mod2)))
datastructsim2$steps=4*(2-datasim2$Mod2) + 10*(datasim2$Mod2-1)
datastructsim2$column=match(datasim2$Column, unique(datasim2$Column))
datastructsim2$hplcparam=cbind(datasim2$tg,datasim2$td,datasim2$to,datasim2$te,
                              datasim2$fio,datasim2$fik,datasim2$Mod2-1,datasim2$pHo,
                              datasim2$alpha1,datasim2$alpha2,(datasim2$Temp-25)/10,
                              datasim2$Column-1)
datastructsim2$trobs = rep(0,datastructsim2$nObs)
analyte_ID_sample =  c(9,17,33,58,140,180)
idx <- which(datasim2$METID %in% analyte_ID_sample)
datasim_red = datasim2[idx,]
datastructsim_red <-datastructsim2
datastructsim_red$nObs=length(datastructsim_red$analyte[idx])
datastructsim_red$analyte=datastructsim_red$analyte[idx]
datastructsim_red$modifier=datastructsim_red$modifier[idx]
datastructsim_red$steps=datastructsim_red$steps[idx]
datastructsim_red$column=datastructsim_red$column[idx]
datastructsim_red$hplcparam=datastructsim_red$hplcparam[idx,]
datastructsim_red$trobs = rep(0,datastructsim_red$nObs)
datastructsim_red$nexpid=length(unique(datasim_red$expid))
datastructsim_red$expid=match(datasim_red$expid, unique(datasim_red$expid))
datastructsim_red$nAnalytessim=length(unique(datastructsim_red$analyte))
datastructsim_red$analytesim=match(datastructsim_red$analyte, unique(datastructsim_red$analyte))

```

```{r casestudy1-simgg, eval = FALSE}

model_sim_red <- cmdstan_model("stan/hplc-gra-fivecolumns-fixed-sim.stan")

fit_sim_red1  <- model_sim_red$generate_quantities(fit_red1,
                                         data = datastructsim_red,
                                         seed = 123,
                                         parallel_chains = 4,
                                         output_dir = "stanfiles")
```

```{r casestudy1-loaddata}
x<- cmdstanr::read_cmdstan_csv(c(
                                  'stanfiles/hplc-gra-fivecolumns-fixed-sim-202308241032-1-261ea0.csv'
                                ))

draws_sim_red_df <- as_draws_df(x$generated_quantities)
#draws_sim_red_df <- fit_sim_red$draws(format = "df")
```

The results are presented as a utility map for each of the column. The maximum is displayed below as a table

```{r casestudy1-utylitymaps-alldata}
Uresults<-datasim_red[!duplicated(datasim_red$expid),]
x<-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep("^mindifftr", names(draws_sim_red_df), value = TRUE))]
y<-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep("^maxtr", names(draws_sim_red_df), value = TRUE))]
z<-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep("^mintr", names(draws_sim_red_df), value = TRUE))]

u=x;

for (i in 1:ncol(x)){u[,i] <- as.numeric(x[,i]>2 & z[,i] > 2) * (40-y[,i]) * as.numeric(y[,i]<40)}

pr <- apply(u, MARGIN = 2, FUN = mean)
pr<-as.data.frame(pr)

Uresults$EUtility=pr$pr

x <- apply(x, MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))
x<-as.data.frame(t(x))

Uresults$mindifftr_l=x$`5%`
Uresults$mindifftr_m=x$`50%`
Uresults$mindifftr_h=x$`95%`

y <- apply(y, MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))

y<-as.data.frame(t(y))

Uresults$maxtr_l=y$`5%`
Uresults$maxtr_m=y$`50%`
Uresults$maxtr_h=y$`95%`

p11 <- ggplot()+
     geom_contour_filled(data=subset(Uresults,Column==1), aes(x = pHs, y=tg, z = EUtility))+
     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+
     labs(x ="pH",
          y = "tg, min",
          fill = "Expected Utility")

p12 <- ggplot()+
     geom_contour_filled(data=subset(Uresults,Column==2), aes(x = pHs, y=tg, z = EUtility))+
     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+
     labs(x ="pH",
          y = "tg, min",
          fill = "Expected Utility")

p13 <- ggplot()+
     geom_contour_filled(data=subset(Uresults,Column==3), aes(x = pHs, y=tg, z = EUtility))+
     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+
     labs(x ="pH",
          y = "tg, min",
          fill = "Expected Utility")

p14 <- ggplot()+
     geom_contour_filled(data=subset(Uresults,Column==4), aes(x = pHs, y=tg, z = EUtility))+
     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+
     labs(x ="pH",
          y = "tg, min",
          fill = "Expected Utility")

p15 <- ggplot()+
     geom_contour_filled(data=subset(Uresults,Column==5), aes(x = pHs, y=tg, z = EUtility))+
     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+
     labs(x ="pH",
          y = "tg, min",
          fill = "Expected Utility")

ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "utilitymap1", ".png"), plot=p11, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "utilitymap2", ".png"), plot=p12, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "utilitymap3", ".png"), plot=p13, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "utilitymap4", ".png"), plot=p14, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "utilitymap5", ".png"), plot=p15, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "utilitymap1", ".pdf"), plot=p11, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "utilitymap2", ".pdf"), plot=p12, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "utilitymap3", ".pdf"), plot=p13, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "utilitymap4", ".pdf"), plot=p14, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "utilitymap5", ".pdf"), plot=p15, width = 20, height = 20, units = "cm")

print(p11)
print(p12)
print(p13)
print(p14)
print(p15)

Uresults$pHo <-round(Uresults$pHo,1)

cat("1. The best for XBridge Shield RP18:")
 Uresults1<-Uresults[Uresults$Column==1,];
 Uresults1<-Uresults1[which(Uresults1$EUtility==max(Uresults1$EUtility)),]
 kable(Uresults1[,c('ColumnName','tg', 'fio','fik','Mod','pHo','Temp','EUtility')])

cat("2. The best choice for XTerra MS C18:")
 Uresults2<-Uresults[Uresults$Column==2,];
 Uresults2<-Uresults2[which(Uresults2$EUtility==max(Uresults2$EUtility)),]
 kable(Uresults2[,c('ColumnName','tg', 'fio', 'fik','Mod','pHo','Temp','EUtility')])

cat("3. The best choice for XBridge Phenyl:")
 Uresults3<-Uresults[Uresults$Column==3,];
 Uresults3<-Uresults3[which(Uresults3$EUtility==max(Uresults3$EUtility)),]
 kable(Uresults3[,c('ColumnName','tg', 'fio', 'fik','Mod','pHo','Temp','EUtility')])

cat("4. The best choice for XBridge C8:")
 Uresults4<-Uresults[Uresults$Column==4,];
 Uresults4<-Uresults4[which(Uresults4$EUtility==max(Uresults4$EUtility)),]
 kable(Uresults4[,c('ColumnName','tg', 'fio', 'fik','Mod','pHo','Temp','EUtility')])

cat("5. The best choice for Xterra MS C8:")
 Uresults5<-Uresults[Uresults$Column==5,];
 Uresults5<-Uresults5[which(Uresults5$EUtility==max(Uresults5$EUtility)),]
 kable(Uresults5[,c('ColumnName','tg', 'fio', 'fik','Mod','pHo','Temp','EUtility')])

```

The highest utility can be expected for Xterra MS C8. 

### Uncertainity chromatogram

Here, we visualize chromatograms for each column with the highest expected utility given the experimental data.

```{r casestudy1-uncertainity-chrom}
analyte_ID_sample <-c(9,17,33,58,140,180)

datasim_red$fio = as.factor(datasim_red$fio)

wpCond= data.frame()

for (i in 1:5) {
Uresultsi <- Uresults1
if (i==2){Uresultsi <- Uresults2}
if (i==3){Uresultsi <- Uresults3}
if (i==4){Uresultsi <- Uresults4}
if (i==5) {Uresultsi <- Uresults5}

 idx <- which(datasim_red$METID %in% analyte_ID_sample &
               datasim_red$tg == Uresultsi$tg & # c(30, 90, 270)
               datasim_red$pHid == Uresultsi$pHid &   # c(1:9)
               datasim_red$fio == Uresultsi$fio &   # ...
               datasim_red$Column == Uresultsi$Column &  # c(1, 2)
               datasim_red$Mod2 == Uresultsi$Mod2 & # c(1, 2)
               datasim_red$Temp == Uresultsi$Temp) # c(25, 35)
 
data_to_plot <- draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% paste0("trHatCond[",idx,"]"))]

colnames(data_to_plot) <- paste(dataNames$Name[analyte_ID_sample])
wpCond1 <- melt(data_to_plot)
wpCond1$Column <- paste0(Uresultsi$ColumnName,
                         ', ', Uresultsi$Mod,
                         ', Temp= ', Uresultsi$Temp, ',', " \n ",
                         ' fio= ', Uresultsi$fio,
                         ', tg= ', Uresultsi$tg,
                         ', pHo= ', round(Uresultsi$pHo,1))
wpCond= rbind(wpCond,wpCond1)
}

wpCond$Column=as.factor(wpCond$Column)

p <- ggplot(data = wpCond)+
     geom_density(aes(x=value, colour=variable, fill=variable),alpha=0.1, lwd=0.25) +
     labs(title="uncertainty chromatogram (all data)",
          x ="Retention time, min",
          y = "pdf",
          colour="Analyte"
          )+
     xlim(c(0,40))+
     facet_wrap(.~Column, nrow=3,scales = "free")+
     theme(legend.position = c(1, 0),
           legend.justification = c(1, 0))+
  guides(fill = "none")
  
ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "chromatogram", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "chromatogram", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

print(p)

ggsave(paste0("figures\\casestudy1\\utilitymap\\",  "chromatogram-manuscript", ".png"),
       p,
       device = ragg::agg_png(width = 8.4582, height = 8.4582, units = "cm", res = 300, scaling=0.522))

```

# Predictions and decision making. Case study 2

The proposed model can be used for decision making having access to limted data. Here we want to illustrate this by predicting XTerra MS C18, XBridge Phenyl, XBridge C8, Xterra MS C8 retention times based on XBridge Shield RP18 data. We start by restimaing the model using limited data for our 6 analytes.

```{r casestudy2-standata}
analyte_ID_sample = c(9,17,33,58,140,180)

idx <- which(data$METID %in% analyte_ID_sample &
               data$tg %in% c(30, 90, 270) &
               data$pH %in% c(1:9) &
               data$Column %in% c(1) &  # c(1, 2)
               data$Mod2 %in% c(1, 2) &
               data$Temp %in% c(25, 35))

datastruct_red = datastruct;
datastruct_red$idx = idx
datastruct_red$nObs2 = length(datastruct_red$idx)

init_red <- function(){
list(logkwHat=rnorm(1,3.60,0.0793),
S1mHat=rnorm(1,4.96,0.0832),
dS1Hat=rnorm(1,0.612,0.0512),
dlogkwHat=c(rnorm(1,-0.786,0.0718), rnorm(1,-0.970,0.0503)),
dS1mHat=c(rnorm(1,0.176,0.121), rnorm(1,0.110,0.0744)),
ddS1Hat=c(rnorm(1,0.279,0.0865), rnorm(1,-0.651,0.0564)),
logS2mHat=rnorm(1,-0.308,0.0143),
dlogS2Hat=rnorm(1,0.420,0.00760),
beta=c(rnorm(1,0.831,0.0407), rnorm(1,0.483,0.0449)),
alphamHat=c(rnorm(1,2.23,0.155),rnorm(1,-1.36,0.102)),
dalphaHat=c(rnorm(1,0.212,0.0981),rnorm(1,-0.188,0.0744)),
dlogkTHat=rnorm(1,-0.0898,0.00292),
apH=c(rnorm(1,-0.0275,0.00118), rnorm(1,0.0806,0.000800)),
omega=c(rnorm(1,0.925,0.0549), rnorm(1,0.941,0.0590),rnorm(1,0.565,0.0343)),
omegaT=rnorm(1,0.0337,0.00212),
kappa=c(rnorm(1,0.584,0.0350), rnorm(1,0.694,0.0475), rnorm(1,0.57,0.0378)),
msigma=rnorm(1,0.386,0.0263),
ssigma=rnorm(1,0.813,0.0496),
tau=c(rnorm(1,0.882,0.0494),rnorm(1,0.958,0.0584),rnorm(1,0.793,0.0506)),
rho = matrix(c(1, 0.864, 0.864, 1), nrow=2),
clogkwHat=c(rnorm(1,0.424,0.0115),rnorm(1,0.173,0.0132),rnorm(1,0.105,0.0118),rnorm(1,0.166,0.0101)),
cS1mHat=c(rnorm(1,0.588,0.0198),rnorm(1,-0.122,0.0218), rnorm(1,0.362,0.0180), rnorm(1,0.479,0.0167)),
cdS1Hat=c(rnorm(1,0.151,0.0134),rnorm(1,0.828,0.0278),rnorm(1,0.552,0.0535),rnorm(1,0.0308,0.0157)),
cdlogkTHat=c(rnorm(1,-0.00595,0.00125),rnorm(1,-0.0208,0.00160),rnorm(1,-0.00605,0.00105),rnorm(1,-0.00302,0.00104)),
cdlogkwHat = matrix(c(rnorm(1,0.0412,0.0154),
rnorm(1,-0.0515,0.0208),
rnorm(1,-0.0321,0.0167),
rnorm(1,0.0426,0.0164),
rnorm(1,0.00532,0.0135),
rnorm(1,-0.0312,0.0154),
rnorm(1,-0.0578,0.0127),
rnorm(1,-0.0205,0.0137)),nrow=(nColumns-1)),
cdS1mHat= matrix(c(rnorm(1,-0.0240,0.0454),
rnorm(1,-0.202,0.0633),
rnorm(1,-0.501,0.0471),
rnorm(1,-0.218,0.0439),
rnorm(1,0.375,0.0352),
rnorm(1,-0.394,0.0392),
rnorm(1,-0.0862,0.0304),
rnorm(1,0.313,0.0333)),nrow=(nColumns-1)),
cddS1Hat= matrix(c(rnorm(1,0.0505,0.0269),
rnorm(1,0.134,0.0531),
rnorm(1,0.457,0.111),
rnorm(1,0.00183,0.0252),
rnorm(1,0.170,0.0154),
rnorm(1,0.573,0.033),
rnorm(1,0.504,0.0743),
rnorm(1,-0.0301,0.0157)),nrow=(nColumns-1)),
cbeta= matrix(c(rnorm(1,0.00719,0.0064),
rnorm(1,-0.00576,0.00755),
rnorm(1,-0.0241,0.00768),
rnorm(1,-0.0102,0.00588),
rnorm(1,-0.0664,0.0109),
rnorm(1,0.113,0.0126),
rnorm(1,-0.0198,0.0111),
rnorm(1,-0.00871,0.00984)),nrow=(nColumns-1)),
capH= matrix(c(rnorm(1,-0.0149,0.00157),
rnorm(1,-0.0219,0.00169),
rnorm(1,0.00482,0.00148),
rnorm(1,-0.0226,0.00146),
rnorm(1,-0.0336,0.00118),
rnorm(1,-0.0440,0.00106),
rnorm(1,-0.0506,0.000901),
rnorm(1,-0.0130,0.00103)),nrow=(nColumns-1)),
comega= abs(matrix(c(rnorm(1,0.107,0.00778),
rnorm(1,0.129,0.00891),
rnorm(1,0.114,0.00751),
rnorm(1,0.0966,0.00638),
rnorm(1,0.0971,0.0196),
rnorm(1,0.146,0.017),
rnorm(1,0.0901,0.0156),
rnorm(1,0.0713,0.0189),
rnorm(1,0.141,0.011),
rnorm(1,0.309,0.0205),
rnorm(1,0.608,0.0403),
rnorm(1,0.172,0.0123)),nrow=(nColumns-1))),
ckappa= abs(matrix(c(rnorm(1,0.0688,0.00622),
rnorm(1,0.116,0.00872),
rnorm(1,0.0855,0.00668),
rnorm(1,0.0873,0.00625),
rnorm(1,0.0714,0.0362),
rnorm(1,0.199,0.0311),
rnorm(1,0.0932,0.0322),
rnorm(1,0.0334,0.0252),
rnorm(1,0.0738,0.0197),
rnorm(1,0.277,0.0253),
rnorm(1,0.717,0.0502),
rnorm(1,0.0861,0.0164)),nrow=(nColumns-1))),
corr_L = matrix(c(1,0.568,0.781,0.719,0,0.819,0.129,0.176,0,0,0.604,0.541,0,0,0,0.384), nrow=4),
comegaT=abs(c(rnorm(1,0.00230,0.00159),rnorm(1,0.0115,0.00123),rnorm(1,0.00179,0.00116),rnorm(1,0.00114,0.000878))),
          paramN =  cbind(2+0.75*(logPobs-2.2), 4*matrix(1,nAnalytes,1)+0.5*(logPobs-2.2)),
          dS1N   =  matrix(0,nAnalytes,1),
          dlogkT = rnorm(nAnalytes,-0.0868,0.0217),
          dlogkwA = matrix(-1,nGroupsA,1),
          dlogkwB = matrix(-1,nGroupsB,1),
          dS1mA = matrix(0,nGroupsA,1),
          dS1mB = matrix(0,nGroupsB,1),
          dS1A = matrix(0,nGroupsA,1),
          dS1B = matrix(0,nGroupsB,1),
          clogkwN = matrix(0,nColumns-1,nAnalytes),
          cS1mN = matrix(0,nColumns-1,nAnalytes),
          cdS1N = matrix(0,nColumns-1,nAnalytes),
          etacdlogkT = matrix(0,nColumns-1,nAnalytes),
          etacdlogkwA = matrix(0,nColumns-1,nGroupsA),
          etacdlogkwB = matrix(0,nColumns-1,nGroupsB),
          etacdS1mA = matrix(0,nColumns-1,nGroupsA),
          etacdS1mB = matrix(0,nColumns-1,nGroupsB),
          etacdS1A = matrix(0,nColumns-1,nGroupsA),
          etacdS1B = matrix(0,nColumns-1, nGroupsB),
          pKawA = pKaslitA,
          pKawB = pKaslitB,
          etaalphamA = matrix(0,nGroupsA,1),
          etaalphamB = matrix(0,nGroupsB,1),
          etadalphaA = matrix(0,nGroupsA,1),
          etadalphaB = matrix(0,nGroupsB,1),
logsigma   = rnorm(nAnalytes,log(0.386),0.813),
clogmsigma=c(rnorm(1,0.2,0.0170),
rnorm(1,-0.0170,0.0207),
rnorm(1,-0.260,0.0205),
rnorm(1,-0.100,0.0170)),
cssigma=abs(c(rnorm(1,0.0927,0.0236),
rnorm(1,0.169,0.0200),
rnorm(1,0.161,0.019),
rnorm(1,0.0854,0.0245))),
etaclogsigma   = matrix(rnorm(nAnalytes*(nColumns-1),0,0.125),nrow=(nColumns-1))
  )
}

```

```{r casestudy2-sampling, eval = FALSE}

mod_fixed <- cmdstan_model("stan/hplc-gra-fivecolumns-fixed.stan",
                      stanc_options = list("O1"))

fit_red <- mod_fixed$sample(
  data = datastruct_red,
  output_dir = "stanfiles",
  init = init_red,
  iter_warmup = 1000,
  iter_sampling = 500,
  chains = 4,
  parallel_chains = 4,
  refresh = 100,
  adapt_delta=0.9
)

```

```{r casestudy2-load-fitdata}
fit_red <- cmdstanr::as_cmdstan_fit(c(
                                  'stanfiles/hplc-gra-fivecolumns-fixed-202308241051-1-738454.csv',
                                  'stanfiles/hplc-gra-fivecolumns-fixed-202308241051-2-738454.csv',
                                  'stanfiles/hplc-gra-fivecolumns-fixed-202308241051-3-738454.csv',
                                  'stanfiles/hplc-gra-fivecolumns-fixed-202308241051-4-738454.csv'

                                ))

```

## Summary of individual parameters

Here shown for analyte 9 (`r dataNames$Name[9]`)

```{r casestudy2-summary}
# which(unique(data$METID)==9) - 3rd compound in stan

fit_red$print(c("logkwx[3,1,1]", "logkwx[3,1,2]", "logkwx[3,1,3]",
                "logkwx[3,2,1]", "logkwx[3,2,2]", "logkwx[3,2,3]",
                "S1x[3,1,1,1]", "S1x[3,1,1,2]", "S1x[3,1,1,3]",
                "S1x[3,2,1,1]", "S1x[3,2,1,2]", "S1x[3,2,1,3]",
                "S1x[3,1,2,1]", "S1x[3,1,2,2]", "S1x[3,1,2,3]",
                "S1x[3,2,2,1]", "S1x[3,2,2,2]", "S1x[3,2,2,3]",
                "apHx[3,1,1]", "apHx[3,1,2]", "apHx[3,1,3]",
                "pKawx[3,1]", "pKawx[3,2]",
                "alphax[3,1,1]", "alphax[3,1,2]",
                "alphax[3,2,1]", "alphax[3,2,2]",
                "S2x[1,1]", "S2x[2,1]",
                "sigmax[3,1]", "sigmax[3,2]"), max_rows = 31)

```

## Predicted retention times

```{r  casestudy2-datasim}
analyte_ID_sample =  c(9,17,33,58,140,180)
idx <- which(datasim$METID %in% analyte_ID_sample)
datasim_red = datasim[idx,1:20]
datastructsim_red <-datastructsim
datastructsim_red$nObs=length(datastructsim_red$analyte[idx])
datastructsim_red$analyte=datastructsim_red$analyte[idx]
datastructsim_red$modifier=datastructsim_red$modifier[idx]
datastructsim_red$steps=datastructsim_red$steps[idx]
datastructsim_red$column=datastructsim_red$column[idx]
datastructsim_red$hplcparam=datastructsim_red$hplcparam[idx,]
datastructsim_red$trobs = rep(0,datastructsim_red$nObs)
datastructsim_red$nexpid=length(unique(datasim_red$expid))
datastructsim_red$expid=match(datasim_red$expid, unique(datasim_red$expid))
datastructsim_red$nAnalytessim=length(unique(datastructsim_red$analyte))
datastructsim_red$analytesim=match(datastructsim_red$analyte, unique(datastructsim_red$analyte))

```

```{r casestudy2-datasim-gq, eval = FALSE}
model_sim_red <- cmdstan_model("stan/hplc-gra-fivecolumns-fixed-sim.stan")
fit_sim_red  <- model_sim_red$generate_quantities(fit_red,
                                         data = datastructsim_red,
                                         seed = 123,
                                         parallel_chains = 4,
                                         output_dir = "stanfiles")
```

```{r casestudy2-datasim-dataload}
x<- cmdstanr::read_cmdstan_csv(c(
                                  'stanfiles/hplc-gra-fivecolumns-fixed-sim-202308241208-1-66415a.csv',
                                  'stanfiles/hplc-gra-fivecolumns-fixed-sim-202308241208-2-66415a.csv',
                                  'stanfiles/hplc-gra-fivecolumns-fixed-sim-202308241208-3-66415a.csv',
                                  'stanfiles/hplc-gra-fivecolumns-fixed-sim-202308241208-4-66415a.csv'
                                ))

draws_sim_red_df <- as_draws_df(x$generated_quantities)
#draws_sim_red_df <- fit_sim_red$draws(format = "df")
```

### Plot the predicted vs. observed:

```{r casestudy2-pred}
tr_sim_red_Cond <- apply(draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep("^trCond", names(draws_sim_red_df), value = TRUE))], MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))

tr_sim_Cond<-as.data.frame(t(tr_sim_red_Cond))

datasim_red$trCond_l=tr_sim_Cond$`5%`
datasim_red$trCond_m=tr_sim_Cond$`50%`
datasim_red$trCond_h=tr_sim_Cond$`95%`

idx <- which(data$METID %in% analyte_ID_sample &
               data$tg %in% c(30, 90, 270) &
               data$pH %in% c(1:9) &
               data$Column %in% c(1) &  # c(1, 2)
               data$Mod2 %in% c(1, 2) &
               data$Temp %in% c(25, 35))

data_red = data[idx,]

for(i in 1:length(analyte_ID_sample)){

pi <- ggplot()+
      geom_point(data=data[which(data$METID %in% analyte_ID_sample[i]),], aes(x = pHs, y = RT, color = as.factor(tg)), shape = 1)+
      geom_point(data=data_red[which(data_red$METID %in% analyte_ID_sample[i]),], aes(x = pHs, y = RT, color = as.factor(tg)))+
     geom_line(data=datasim_red[which(datasim_red$METID %in% analyte_ID_sample[i]),], aes(x = pHs, y = trCond_m, color = as.factor(tg)))+
     geom_ribbon(data=datasim_red[which(datasim_red$METID %in% analyte_ID_sample[i]),], aes(x = pHs, ymin = trCond_l, ymax = trCond_h, fill = as.factor(tg)), alpha = 0.25)+
  xlim(2,11)+
facet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+
      labs(title=paste(dataNames$Name[analyte_ID_sample[i]]), x ="pH", y = "Retention time, min", color = "tg, min", fill = "tg, min")

ggsave(paste0("figures\\casestudy2\\concordanceplots\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".png"), plot=pi, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy2\\concordanceplots\\", paste(dataNames$Name[analyte_ID_sample[i]]), ".pdf"), plot=pi, width = 20, height = 20, units = "cm")
print(pi)

}

```

### Uncertainity chromatogram

Below is the example of a chromatogram (along with uncertainty) expected for tg = 90 min, pH = 8.9, Temp = $25^oC$ in ACN.

```{r  casestudy2-uncertainity-chrom}
analyte_ID_sample <-c(9,17,33,58,140,180)
col.labs <- c("XBridge Shield RP18","XTerra MS C18", "XBridge Phenyl", "XBridge C8", "Xterra MS C8")

wpCond= data.frame()

for (i in 1:5) {
idx <- which(datasim_red$METID %in% analyte_ID_sample &
               datasim_red$tg==90 & # c(30, 90, 270)
               datasim_red$pH== 7 &   # c(1:9)
               datasim_red$Column==i &  # c(1, 2)
               datasim_red$Mod2==2 & # c(1, 2)
               datasim_red$Temp==25) # c(25, 35)

data_to_plot <- draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% paste0("trHatCond[",idx,"]"))]

colnames(data_to_plot) <- paste(dataNames$Name[analyte_ID_sample])

wpCond1 <- melt(data_to_plot)
wpCond1$Column <- col.labs[i]
wpCond= rbind(wpCond,wpCond1)
}

wpCond$Column=as.factor(wpCond$Column)
p <- ggplot(data = wpCond)+
     geom_density(aes(x=value, colour=variable, fill=variable),alpha=0.1) +
     labs(title="uncertainty chromatogram (limited data preditions)",
          x ="Retention time, min",
          y = "pdf",
          colour="Analyte")+
     xlim(c(0,80))+
     facet_wrap(.~Column, nrow=3,scales = "free")+
     theme(legend.position = c(1, 0),
     legend.justification = c(1, 0)) +
  guides(fill = "none")

ggsave(paste0("figures\\casestudy2\\concordanceplots\\",  "chromatogram", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy2\\concordanceplots\\",  "chromatogram", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

print(p)

ggsave(paste0("figures\\casestudy2\\concordanceplots\\",  "chromatogram-manuscript", ".png"),
       p,
       device = ragg::agg_png(width = 8.4582, height = 8.4582, units = "cm", res = 300, scaling=0.522))

```

## Utility maps

We can also determine more detailed graph presenting relationship between the expected utility and design variables:

```{r casestudy2-preparedata}
upH <- datasim %>%
  select(1:20) %>%
  distinct(Temp,Mod, pHo, alpha1, alpha2) %>%
  group_by(Temp,Mod) %>%
  tidyr::complete(pHo = seq(min(pHo), max(pHo), len = 17)) %>%
  arrange(Temp,Mod,pHo) %>%
  mutate(alpha1 = zoo::na.approx(alpha1,pHo)) %>%
  mutate(alpha2 = zoo::na.approx(alpha2,pHo)) %>%
  group_by(Temp,Mod) %>%
  mutate(pHid = row_number()) %>%
  group_by(pHid)  %>%
  mutate(pHs = round(mean(pHo),2)) %>%
  ungroup()

datasim2 <- datasim %>%
  select(1:20) %>%
  filter(tg==30, Temp==25) %>%
  select(-tg, -fio, -expid, -pHs, -pHo, -alpha1, -alpha2, -pH) %>%
  distinct() %>%
 tidyr::expand_grid(fio = seq(0.05,0.2,0.05),tg = seq(20,260,20), pHs=unique(upH$pHs))%>%
  left_join(upH, by = join_by(pHs, Mod, Temp), relationship = "many-to-one") %>%
  group_by(tg, fio, Mod, Column, pHs) %>%
  mutate(expid = cur_group_id()) %>%
  ungroup()
datastructsim2 <-datastruct
datastructsim2$nObs=length(datasim2$METID)
datastructsim2$analyte=match(datasim2$METID, unique(datasim2$METID))
datastructsim2$modifier=match(datasim2$Mod2, sort(unique(datasim2$Mod2)))
datastructsim2$steps=4*(2-datasim2$Mod2) + 10*(datasim2$Mod2-1)
datastructsim2$column=match(datasim2$Column, unique(datasim2$Column))
datastructsim2$hplcparam=cbind(datasim2$tg,datasim2$td,datasim2$to,datasim2$te,
                              datasim2$fio,datasim2$fik,datasim2$Mod2-1,datasim2$pHo,
                              datasim2$alpha1,datasim2$alpha2,(datasim2$Temp-25)/10,
                              datasim2$Column-1)
datastructsim2$trobs = rep(0,datastructsim2$nObs)
analyte_ID_sample =  c(9,17,33,58,140,180)
idx <- which(datasim2$METID %in% analyte_ID_sample)
datasim_red = datasim2[idx,]
datastructsim_red <-datastructsim2
datastructsim_red$nObs=length(datastructsim_red$analyte[idx])
datastructsim_red$analyte=datastructsim_red$analyte[idx]
datastructsim_red$modifier=datastructsim_red$modifier[idx]
datastructsim_red$steps=datastructsim_red$steps[idx]
datastructsim_red$column=datastructsim_red$column[idx]
datastructsim_red$hplcparam=datastructsim_red$hplcparam[idx,]
datastructsim_red$trobs = rep(0,datastructsim_red$nObs)
datastructsim_red$nexpid=length(unique(datasim_red$expid))
datastructsim_red$expid=match(datasim_red$expid, unique(datasim_red$expid))
datastructsim_red$nAnalytessim=length(unique(datastructsim_red$analyte))
datastructsim_red$analytesim=match(datastructsim_red$analyte, unique(datastructsim_red$analyte))

```

```{r casestudy2-qq, eval = FALSE}
model_sim_red <- cmdstan_model("stan/hplc-gra-fivecolumns-fixed-sim.stan")
fit_sim_red  <- model_sim_red$generate_quantities(fit_red,
                                         data = datastructsim_red,
                                         seed = 123,
                                         parallel_chains = 4,
                                         output_dir = "stanfiles")

```

```{r casestudy2-loaddata}
x<- cmdstanr::read_cmdstan_csv(c(
                                  'stanfiles/hplc-gra-fivecolumns-fixed-sim-202308241235-1-3ef502.csv'
                                ))

draws_sim_red_df <- as_draws_df(x$generated_quantities)
#draws_sim_red_df <- fit_sim_red$draws(format = "df")

```

The results are presented as a utility map for each of the column. The maximum is displayed below as a table:

```{r casestudy2-utylitymaps-danse}
Uresults<-datasim_red[!duplicated(datasim_red$expid),]

x<-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep("^mindifftr", names(draws_sim_red_df), value = TRUE))]
y<-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep("^maxtr", names(draws_sim_red_df), value = TRUE))]
z<-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep("^mintr", names(draws_sim_red_df), value = TRUE))]

u=x;

for (i in 1:ncol(x)){u[,i] <- as.numeric(x[,i]>2 & z[,i] > 2) * (40-y[,i]) * as.numeric(y[,i]<40)}

pr <- apply(u, MARGIN = 2, FUN = mean)

pr<-as.data.frame(pr)

Uresults$EUtility=pr$pr

x <- apply(x, MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))

x<-as.data.frame(t(x))

Uresults$mindifftr_l=x$`5%`
Uresults$mindifftr_m=x$`50%`
Uresults$mindifftr_h=x$`95%`

y <- apply(y, MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))

y<-as.data.frame(t(y))

Uresults$maxtr_l=y$`5%`
Uresults$maxtr_m=y$`50%`
Uresults$maxtr_h=y$`95%`

p11 <- ggplot()+
     geom_contour_filled(data=subset(Uresults,Column==1), aes(x = pHs, y=tg, z = EUtility))+
     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+
     labs(x ="pH",
          y = "tg, min",
          fill = "Expected Utility")

p12 <- ggplot()+
     geom_contour_filled(data=subset(Uresults,Column==2), aes(x = pHs, y=tg, z = EUtility))+
     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+
     labs(x ="pH",
          y = "tg, min",
          fill = "Expected Utility")

p13 <- ggplot()+
     geom_contour_filled(data=subset(Uresults,Column==3), aes(x = pHs, y=tg, z = EUtility))+
     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+
     labs(x ="pH",
          y = "tg, min",
          fill = "Expected Utility")

p14 <- ggplot()+
     geom_contour_filled(data=subset(Uresults,Column==4), aes(x = pHs, y=tg, z = EUtility))+
     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+
     labs(x ="pH",
          y = "tg, min",
          fill = "Expected Utility")

p15 <- ggplot()+
     geom_contour_filled(data=subset(Uresults,Column==5), aes(x = pHs, y=tg, z = EUtility))+
     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+
     labs(x ="pH",
          y = "tg, min",
          fill = "Expected Utility")

ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "utilitymap1", ".png"), plot=p11, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "utilitymap2", ".png"), plot=p12, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "utilitymap3", ".png"), plot=p13, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "utilitymap4", ".png"), plot=p14, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "utilitymap5", ".png"), plot=p15, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "utilitymap1", ".pdf"), plot=p11, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "utilitymap2", ".pdf"), plot=p12, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "utilitymap3", ".pdf"), plot=p13, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "utilitymap4", ".pdf"), plot=p14, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "utilitymap5", ".pdf"), plot=p15, width = 20, height = 20, units = "cm")

print(p11)
print(p12)
print(p13)
print(p14)
print(p15)

Uresults$pHo <-round(Uresults$pHo,1)
cat("1. The best for XBridge Shield RP18:")
 Uresults1<-Uresults[Uresults$Column==1,];
 Uresults1<-Uresults1[which(Uresults1$EUtility==max(Uresults1$EUtility)),]
 kable(Uresults1[,c('ColumnName','tg', 'fio', 'fik','Mod','pHo','Temp','EUtility')])

cat("2. The best choice for XTerra MS C18:")
 Uresults2<-Uresults[Uresults$Column==2,];
 Uresults2<-Uresults2[which(Uresults2$EUtility==max(Uresults2$EUtility)),]
 kable(Uresults2[,c('ColumnName','tg', 'fio', 'fik','Mod','pHo','Temp','EUtility')])

cat("3. The best choice for XBridge Phenyl:")
 Uresults3<-Uresults[Uresults$Column==3,];
 Uresults3<-Uresults3[which(Uresults3$EUtility==max(Uresults3$EUtility)),]
 kable(Uresults3[,c('ColumnName','tg', 'fio', 'fik','Mod','pHo','Temp','EUtility')])

cat("4. The best choice for XBridge C8:")
 Uresults4<-Uresults[Uresults$Column==4,];
 Uresults4<-Uresults4[which(Uresults4$EUtility==max(Uresults4$EUtility)),]
 kable(Uresults4[,c('ColumnName','tg', 'fio', 'fik','Mod','pHo','Temp','EUtility')])

cat("5. The best choice for Xterra MS C8:")
 Uresults5<-Uresults[Uresults$Column==5,];
 Uresults5<-Uresults5[which(Uresults5$EUtility==max(Uresults5$EUtility)),]
 kable(Uresults5[,c('ColumnName','tg', 'fio', 'fik','Mod','pHo','Temp','EUtility')])
   
```

### Uncertainity chromatogram

Here, we visualize chromatograms for each column with the highest expected utility given the experimental data. The XBridge Shield RP18 data adds predictive value if compared to population predictions, however, the uncertainties are still high to unequivocally choose the best column and chromatographic conditions. Still some additional experiments are required.

```{r casestudy2-chromatogram-dense}
analyte_ID_sample <-c(9,17,33,58,140,180)

datasim_red$fio = as.factor(datasim_red$fio)

wpCond= data.frame()
 
for (i in 1:5) {

Uresultsi <- Uresults1
if (i==2){Uresultsi <- Uresults2}
if (i==3){Uresultsi <- Uresults3}
if (i==4){Uresultsi <- Uresults4}
if (i==5) {Uresultsi <- Uresults5}

 idx <- which(datasim_red$METID %in% analyte_ID_sample &
               datasim_red$tg == Uresultsi$tg & # c(30, 90, 270)
               datasim_red$pHid == Uresultsi$pHid &   # c(1:9)
               datasim_red$fio == Uresultsi$fio &   # ...
               datasim_red$Column == Uresultsi$Column &  # c(1, 2)
               datasim_red$Mod2 == Uresultsi$Mod2 & # c(1, 2)
               datasim_red$Temp == Uresultsi$Temp) # c(25, 35)

 data_to_plot <- draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% paste0("trHatCond[",idx,"]"))]
 colnames(data_to_plot) <- paste(dataNames$Name[analyte_ID_sample])
 wpCond1 <- melt(data_to_plot)
wpCond1$Column <- paste0(Uresultsi$ColumnName,
                         ', ', Uresultsi$Mod,
                         ', Temp= ', Uresultsi$Temp, ',', " \n ",
                         ' fio= ', Uresultsi$fio,
                         ', tg= ', Uresultsi$tg,
                         ', pHo= ', round(Uresultsi$pHo,1))
wpCond= rbind(wpCond,wpCond1)

}

wpCond$Column=as.factor(wpCond$Column)

p <- ggplot(data = wpCond)+
     geom_density(aes(x=value, colour=variable, fill=variable), alpha=0.1, lwd=0.25) +
     labs(title="uncertainty chromatogram (limited data predictions)",
          x ="Retention time, min",
          y = "pdf",
          colour="Analyte")+
     xlim(c(0,40))+
     facet_wrap(.~Column, nrow=3,scales = "free")+
     theme(legend.position = c(1, 0),
        legend.justification = c(1, 0))+
  guides(fill = "none")

 
ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "chromatogram", ".png"), plot=p, width = 20, height = 20, units = "cm")
ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "chromatogram", ".pdf"), plot=p, width = 20, height = 20, units = "cm")

print(p)

ggsave(paste0("figures\\casestudy2\\utilitymap\\",  "chromatogram-manuscript", ".png"),
       p,
       device = ragg::agg_png(width = 8.4582, height = 8.4582, units = "cm", res = 300, scaling=0.522))
```

# Conclusions

This work demonstrates the application of a Bayesian multilevel model to compare various stationary phases using large datasets of retention time collected for a wide range of chromatographic conditions.

# References {.unnumbered}

::: {#refs}
:::

# Licenses {.unnumbered}

-   Code & copy; 2023, Paweł Wiczling, licensed under BSD-3.
-   Text & copy; 2023, Paweł Wiczling, licensed under CC-BY-NC 4.0.

# Original Computing Environment {.unnumbered}

```{r sessionInfo}
sessionInfo()
```
