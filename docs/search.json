[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "",
    "text": "In this work we applied the previously developed Bayesian multilevel framework [1-4] to characterize chromatographic gradient retention time datasets collected using a multicomponent mixtures of analytes, five stationary phases, and a wide range of chromatographic conditions (pH, organic modifier, temperature, gradient program). Such datasets carry much information about chromatographic retention that, if extracted, can provide useful predictive information, i.e. a detailed multidimensional characterization of chromatographic stationary phases and ability to predict retention (along with uncertainty) based on various number of preliminary experiments (e.g. to predict retention time for a set of analytes given no, or several measurements collected using a different stationary phase).\nIn this case study, we compared five RP-HPLC stationary phases (XBridge Shield RP18, XTerra MS C18, XBridge Phenyl, XBridge C8, Xterra MS C8) based on LC-MS/TOF data."
  },
  {
    "objectID": "index.html#load-data",
    "href": "index.html#load-data",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Load data",
    "text": "Load data\nData can be accessed via github or osf.io repository [5-10]:\n\n\nCode\ndata1 = read.csv('data/1-X_Bridge_Shield_C18_5cm.csv')\ndata2 = read.csv('data/1-XTerra_MS_C18.csv')\ndata3 = read.csv('data/1-X_Bridge_Phenyl.csv')\ndata4 = read.csv('data/1-XBridge_C8.csv')\ndata5 = read.csv('data/1-Xterra_C8.csv')\n\ndataNames = read.csv('data/4-compounds-names.csv')\ndataACD = read.csv('data/2-ACD-pKas-logP.csv')\ndataACD$R = rowSums(dataACD[,3:7]&lt;14) # No of dissociation steps\n\nfunctional_groups = read.csv('data/6-checkmol-functional-groups.csv')\nfunctional_groups_names = read.csv('data/Legend-checkmol-functional-group-names.csv')\n\n# marge the data:\n\ndata1['Column'] &lt;- 1\ndata2['Column'] &lt;- 2\ndata3['Column'] &lt;- 3\ndata4['Column'] &lt;- 4\ndata5['Column'] &lt;- 5\n\ndata1['ColumnName'] &lt;- 'XBridge Shield RP18'\ndata2['ColumnName'] &lt;- 'XTerra MS C18'\ndata3['ColumnName'] &lt;- 'XBridge Phenyl'\ndata4['ColumnName'] &lt;- 'XBridge C8'\ndata5['ColumnName'] &lt;- 'Xterra MS C8'\n\ndata = rbind(data1, data2, data3, data4, data5)\n\ndata$Mod  = as.character(data$Mod)\ndata$Mod2 = ifelse(data$Mod==\"MeOH\",1,2)   \n\ndata&lt;-data %&gt;% \n  left_join(select(dataACD,METID,R))\n  \nrm(data1, data2, data3, data4, data5)"
  },
  {
    "objectID": "index.html#prepare-data",
    "href": "index.html#prepare-data",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Prepare data",
    "text": "Prepare data\nSome data wrangling is needed to go any further:\n\nwe removed measurements with low score, analytes with less than 42 measurements per column, analytes with less than 210 measurements out of total 420, and used measurements with the highest score (If several were present)\n\n\n\nCode\ndata &lt;- data  %&gt;%\n  subset(Score&gt;95) %&gt;%\n  group_by(METID,EXPID,Column) %&gt;%\n  slice(which.max(Score)) %&gt;%\n  group_by(METID,Column) %&gt;%\n  add_count() %&gt;%\n  subset(n&gt;42) %&gt;%\n  group_by(METID) %&gt;%\n  add_count() %&gt;%\n  subset(nn&gt;210) %&gt;%\n  select(-n,-nn) %&gt;%\n  ungroup()\n\n\n\nwe removed some outlying measurements (mismatch between literature pKa and observed data)\n\n\n\nCode\ndata &lt;- data %&gt;%  \n  subset(METID!=72) %&gt;%  # dilevalol is repeated in the dataset\n  subset(!(tg==270 & Temp==25 & Mod2==1 & pH==5)) %&gt;% \n  subset(!(tg==270 & Temp==25 & Mod2==1 & pH==9)) %&gt;% \n  subset(R&lt;=2) %&gt;%\n  subset(!(METID %in% c(11,91,154,204,227,274,102,235,131,158,257,138,281,248,110,135,78,201,264,31,293,8,25,176)))%&gt;%\n # subset(!(METID %in% c(11,91,154,204,227,274,102,235,131,158,257,138,281,248,110,135,78,201,264,31,293,8,25,176,246)))%&gt;%\n  select(-R)\n\n\n\nwe prepared predictors: pKa, logP and functional_groups\n\n\n\nCode\npKaslit = dataACD[,3:7]           # pKa values as predicted by ACD\npKasliterror = dataACD[,25:29]    # pKa error as predicted by ACD\nchargesA = abs(dataACD[,13:18])   # number of ionized groups (anions)\nchargesB = abs(dataACD[,19:24])   # number of ionized groups (cations)\ncharges = chargesA+chargesB                         # absolute charge\ngroupsA = (chargesA[,2:5] - chargesA[,1:4])         # acidic group\ngroupsB = -(chargesB[,2:5] - chargesB[,1:4])        # basic group\nR = dataACD$R                      # number of dissociation steps\ngroups = groupsB-groupsA\nlogPobs = dataACD$logP \n\nfunctional_groups=functional_groups[,2:ncol(functional_groups)]\n\n# combine nr of caroboxylic acid and carboxyalic acid salt functional groups\n# heterocyclic compounds with more than 6 heterocycles are treated as if they have six\nfunctional_groups[,76]=functional_groups[,76]+functional_groups[,77]       \nfunctional_groups[which(functional_groups[,202]&gt;5.5),202] = 6; \n\n# exclude some functional groups\nidx_included &lt;- c(4,5,9,11,14,18,19,20,21,24,26,29,30,31,32,33,34,38,39,40,41,45,49,50,52,53,54,56,57,59,63,64,68,69,70,71,76,78,79,81,82,83,84,85,88,90,106,108,113,114,115,127,131,133,137,138,150,164,166,167)\nfunctional_groups_names &lt;- functional_groups_names[idx_included,]\nfunctional_groups &lt;- functional_groups[,idx_included]\n\nrm(idx_included)\n\n\n\nwe selected analytes with two or less dissociation steps\n\n\n\nCode\nmaxR &lt;- 2         \nidx &lt;- which(dataACD$METID %in% data$METID)\n # max two dissociation steps        \npKaslit &lt;- pKaslit[idx,1:maxR]           # pKa values as predicted by ACD\npKasliterror &lt;- pKasliterror[idx,1:maxR] # pKa error as predicted by ACD\nchargesA &lt;- chargesA[idx,1:(maxR+1)]     # number of ionized groups (anions)\nchargesB &lt;- chargesB[idx,1:(maxR+1)]     # number of ionized groups (cations)\ncharges &lt;- charges[idx,1:(maxR+1)]       # absolute charge\ngroupsA &lt;- groupsA[idx,1:maxR]           # acidic group\ngroupsB &lt;- groupsB[idx,1:maxR]           # basic group\nR &lt;- R[idx]                              # number of dissociation steps\nlogPobs &lt;- logPobs[idx]                     # logP\nnrfungroups=functional_groups[idx,]\ntotalnrgroups &lt;- summarise_each(nrfungroups, funs(sum))\n\n# remove functional groups not present in the dataset:\nnrfungroups &lt;- nrfungroups[,which(totalnrgroups!=0)]\nfunctionalgroupsnames&lt;- functional_groups_names[which(totalnrgroups!=0),]\ntotalnrgroups &lt;- summarise_each(nrfungroups, funs(sum))\nK &lt;- ncol(nrfungroups)\n\n# identify acidic groups\nidxGroupsA &lt;-which(groupsA!=0,arr.ind = T)\nnGroupsA &lt;- nrow(idxGroupsA)\npKaslitA&lt;-pKaslit[idxGroupsA]\n# identify basic groups\nidxGroupsB &lt;-which(groupsB!=0,arr.ind = T)\nnGroupsB &lt;- nrow(idxGroupsB)\npKaslitB&lt;-pKaslit[idxGroupsB]\n\n# groups dissociated in the whole pH range\n\nidxB = which(chargesB[,3]==1)\nidxA = which(chargesA[,1]==1)\n\nnObs &lt;- length(data$METID)\nnAnalytes &lt;- length(unique(data$METID))\nnColumns&lt;-length(unique(data$Column))\n                \n#  variables used later to annotate graphs legend\ntemp.labs &lt;- c(\"25\\u00b0C\",\"35\\u00b0C\")\nnames(temp.labs) &lt;- c('25','35')\n\nmod.labs &lt;- c(\"ACN\",\"MeOH\")\nnames(mod.labs) &lt;- c('2','1')\n\n\ncol.labs &lt;- c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\")\nnames(col.labs) &lt;- c('1','2','3','4','5')\n\ndiss.labs &lt;- c(\"r=1\",\"r=2\",\"r=3\")\nnames(diss.labs) &lt;- c('1','2','3')"
  },
  {
    "objectID": "index.html#plot-data",
    "href": "index.html#plot-data",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Plot data",
    "text": "Plot data\nThe following graphs present retention time profiles for 6 analytes:\n\nacridine (monoprotic acid)\nbaclofen (zwitterion: acidic and basic group)\nhydrocortison (neutral)\npioglitazone (zwitterion: basic and acidic group)\nquinine (diprotic: 2 basic groups),\ntolbutamide (monoprotic base).\n\nThe vertical lines show ACD-based pKa values (solid line: acidic group; dotted line: basic group)\n\n\nCode\nanalyte_ID_sample &lt;- c(9,17,33,58,140,180)\n#analyte_ID_sample &lt;-unique(data$METID) # if all\n\nidx &lt;- which(unique(data$METID) %in% analyte_ID_sample)\ngroups &lt;- groupsB-groupsA\n\nfor(i in 1:length(analyte_ID_sample)){\np &lt;- ggplot(data[which(data$METID %in% analyte_ID_sample[i]),])+\n      geom_jitter(aes(x = pHs, y = RT, color = as.factor(tg), shape=as.factor(ColumnName)), width =0.1, height=0.1)+ \n      facet_grid(Temp~Mod2, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+\n      geom_vline(xintercept = pKaslit[idx[i],1],linetype=groups[idx[i],1]+2)+\n      geom_vline(xintercept = pKaslit[idx[i],2],linetype=groups[idx[i],2]+2)+\n      labs(title=paste(dataNames$Name[analyte_ID_sample[i]], 'METID =', analyte_ID_sample[i]), \n           x =\"pH\", y = \"Retention time, min\", \n           color =    \"tg, min\", \n           shape = 'Column')+ \n  xlim(2,11)\nprint(p)\n\nggsave(paste0(\"figures\\\\rawdata\\\\\", paste(dataNames$Name[analyte_ID_sample[i]]), \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n\n}"
  },
  {
    "objectID": "index.html#summary-of-the-data",
    "href": "index.html#summary-of-the-data",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Summary of the data",
    "text": "Summary of the data\n\nNumber of identified analytes: 141\nNumber of observations: 51530\n\\(\\small logP\\): 2.5 \\(\\pm\\) 1.82\nNumber of analytes with 0, 1 and 2 dissociation steps: 14, 88, 39\nNumber of acidic and basic groups: 46 and 120\nNumber of functional groups across all analytes included in the analysis:\n\n\n\nCode\np&lt;-totalnrgroups %&gt;% tidyr::gather(\"Name\", \"count\", 1:54)  %&gt;% \n   ggplot(., aes(x=count, y=reorder(Name,count)))+\n   geom_point()+\n   labs(x=\"Number of functional groups\", y=\"Functional group name\")\n\nprint(p)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\predictors\\\\\", \"functionalgroups\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")"
  },
  {
    "objectID": "index.html#model",
    "href": "index.html#model",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Model",
    "text": "Model\nIn this work \\(\\small z\\) = 1..51915 denotes observation, \\(\\small i\\)=1..142 denotes analyte, \\(\\small c\\)=1..5 denotes column, \\(\\small m\\)=1..2 denotes organic modifier and \\(\\small r\\)=1..\\(\\small R[i]\\) denotes dissociation step for \\(\\small i\\)-th analyte. The observed retention times (\\(\\small t_{Robs,z}\\)) were described using the following model:\n\\[\nt_{Robs,z} \\sim student_t(\\nu, t_{R,z} ,\\sigma_{i[z],c[z]})\n\\]\nwhere z denotes z-th observation and student_t denotes the Student’s t-distribution with the mean given by the predicted retention time \\(\\small t_{R,z}\\), scale \\(\\small \\sigma_{i,c}\\) (analyte and column-specific), and normality parameter \\(\\small \\nu\\).\nGradient retention time \\(\\small t_{R,z}\\) was calculated utilizing the well-known integral equation:\n\\[\n\\int_0^{t_{R,z}-t_{0,z}-t_e}\\frac{dt}{t_{0,z}\\cdot ki_z(t) }=1,\n\\]\nwhere \\(\\small ki_z(t)\\) denotes instantaneous isocratic retention factor corresponding to the mobile phase composition at time t at column inlet for analyte and conditions corresponding to the z-th observation, \\(\\small t_{0,z}\\) denotes column hold-up (dead) time and \\(\\small t_e\\) denotes extra column-time. The numerical solution of this integral equation was carried out using method of steps with 4 and 10 steps for methanol and acetonitrile gradients using method proposed by Nikitas et al. [11] The following function described the relationship between the isocratic retention factor and pH for an ith-analyte with \\(\\small R[i]\\) dissociation steps and \\(\\small R[i]+1\\) forms.\n\\[\nki_z(t)=\\frac{k_{z,i[z],1}(t)+\\sum_{r=1}^{R[i[z]]} k_{z,i[z],r+1}(t) \\cdot 10^{r\\cdot pH_z(t)-\\sum_{r=1}^{R[i]} pKa_{z,i[z],r}(t)} }{1+\\sum_{r=1}^R 10^{r\\cdot pH_z(t)-\\sum_{r=1}^{R[i[z]]} pKa_{z,i[z],r}(t) } }\n\\]\n\\(\\small log(k_{z,i,r})\\) was assumed to depend on the organic modifier content based on the Neue equation, on temperature assuming linear equation, and on the pH of the mobiles phase (for ionized forms of analytes).\n\\[\n\\begin{aligned}\n& log(k_{z,i,r}(t)) = logkw_{c[z],i,r} - \\frac{S1_{m[z],c[z],i,r} \\cdot (1+S2_{m[z]}) \\cdot \\varphi_z(t)}{1+S2_{m[z]} \\cdot \\varphi_z(t)} + ... \\\\\n& apH_{c,[z],m[z],i,r} \\cdot (pH_z(t)-7) + dlogkT_{i} \\cdot (T_z-25)/10\n\\end{aligned}\n\\]\nwhere \\(\\small logkw_{c,i,r}\\) represents logarithm of retention factors extrapolated to 0% of organic modifier content for column \\(\\small c\\), \\(\\small i\\)-th analyte and \\(\\small r\\)-th analyte form; \\(\\small S1_{i,m,c,r}\\) and \\(\\small S2_m\\) are the slopes in the Neue equation for column \\(\\small c\\), modifier \\(\\small m\\), \\(\\small i\\)-th analyte and \\(\\small r\\)-th analyte form. In this parametrization of the Neue equation, \\(\\small S1\\) reflects the difference between logarithm of retention factors corresponding to water (0% of organic modifier content) and MeOH or ACN (100% of organic modifier content) as eluents. \\(\\small dlogkT_i\\) denotes the change in \\(\\small logkw\\) due to the increase in temperature by \\(\\small 10^oC\\). \\(\\small apH_{c,m,i,r}\\) denotes the pH effects on \\(\\small logkw\\);\nFurther a linear relationship between \\(\\small pKa\\) values and the organic modifier content was assumed:\n\\[\npKa_{z,i,r}(t)=pKaw_{i,r}+\\alpha_{m[z],i,r}\\cdot\\varphi_z(t)\n\\]\nwhere \\(\\small pKa_{z,i,r}(t)\\) denotes dissociation constant of an \\(\\small i\\)-th analyte and \\(\\small r\\)-th dissociation step form and chromatographic conditions corresponding the z-th observation, \\(\\small pKaw_{i,r}\\) denotes aqueous \\(\\small pKa\\), and \\(\\alpha_{m,i,r}\\) denotes the slope for \\(\\small m-th\\) modifier, \\(\\small i\\)-th analyte and \\(\\small r\\)-th form. The linear relationships is generally valid for \\(\\small \\varphi\\) &lt; 0.8.\nThe relationship between pH and the organic modifier content for various combinations of organic modifier and buffer was experimentally determined prior to the chromatographic analysis. The obtained relationships was then described using quadratic equations for each nominal pH, temperature and organic modifier:\n\\[\npH_z(t)=pHo_z+\\alpha 1_z\\cdot \\varphi_z(t)+\\alpha2_z\\cdot {\\varphi_z(t)}^2\n\\]\nFirst, individual values of \\(\\small logkw\\), \\(\\small S1\\) were described for the neutral form of an analyte in MeOH (denoted as \\(\\small logkwN_i\\) and \\(\\small S1mN_i\\)) for the Xbridge Sheld RP18 column. The effect of ACN was described as \\(\\small dS1N_i\\)), the effect of column was described by \\(\\small clogkwN_i\\), \\(\\small cS1mN_i\\), and \\(\\small cdS1N_i\\)). The individual parametes for the neutral forms were described using the following equations:\n\\[\n\\begin{aligned}\n& \\begin{bmatrix}\nlogkwN_i \\\\\nS1mN_i\\\\\n\\end{bmatrix} \\sim\nMVN([\\hat{logkw}+\\beta_1 \\cdot (logP_i-2.2), \\hat{S1m}+\\beta_2 \\cdot (logP_i-2.2)]^T,  \\Omega) \\\\\n& dS1N_i \\sim N(\\hat{dS1}, \\omega_3)\\\\\n& \\Omega =\ndiag(\\omega_{1:2}) \\cdot \\begin{bmatrix}\n1 & \\rho \\\\\n\\rho & 1  \\\\\n\\end{bmatrix} \\cdot diag(\\omega_{1:2}) \\\\\n& clogkwN_{i,c} \\sim N(\\hat{clogkw_c}+c\\beta_{1,c} \\cdot (logP_i-2.2), c\\omega_{1,c}) \\\\\n& cS1mN_{i,c} \\sim N(\\hat{cS1m}+c\\beta_{2,c}\\cdot (logP_i-2.2), c\\omega_{2,c}) \\\\\n& cdS1N_{i,c} \\sim N(\\hat{cdS1_c}, c\\omega_{3,c}) \\\\\n& dlogkT_{i,c} \\sim N(\\hat{dlogkT_c},\\omega_{T,c}) \\\\\n\\end{aligned}\n\\]\nwere MVN denotes the multivariate normal distribution; \\(\\small \\hat{logkw}\\), \\(\\small \\hat{S1m}\\), \\(\\small \\hat{dS1}\\) are the mean values of individual chromatographic parameters that correspond to a typical nautral analyte with \\(\\small logP\\) =2.2 at \\(\\small 25^oC\\) on Xbridge Shield RP18 stationary phase. \\(\\small \\beta s\\) are regression coefficients between the individual chromatographic parameters and the \\(\\small logP_i\\). \\(\\small \\omega\\) denotes the standard deviation for between analyte variability (BAV). \\(\\small \\hat{dlogkT}\\) denotes the effect of temperature for a typical analyte and \\(\\small \\omega_T\\) the standard deviation for between analyte variability for temperature effects. Similar set of equations was used for column effects.\nThe difference in retention between the ionized form of an analyte and the neutral form of an analyte was separately estimated for acids and bases for \\(\\small logkw\\), \\(\\small S1m\\), \\(\\small dS1\\) parameters.\n\\[\n\\begin{aligned}\n& dlogkwA_a \\sim N(\\hat{dlogkw_1}, \\kappa_1), cdlogkwA_a \\sim N(\\hat{cdlogkw_1}, c\\kappa_1), \\\\\n& dlogkwB_b \\sim N(\\hat{dlogkw_2}, \\kappa_1), cdlogkwB_b \\sim N(\\hat{cdlogkw_2}, c\\kappa_1), \\\\\n& dS1mA_a \\sim N(\\hat{dS1m_1}, \\kappa_2), cdS1mA_a \\sim N(\\hat{cdS1m_1}, c\\kappa_2), \\\\\n& dS1mB_b \\sim N(\\hat{dS1m_2}, \\kappa_2), cdS1mB_b \\sim N(\\hat{cdS1m_2}, c\\kappa_2), \\\\\n& ddS1A_a \\sim N(\\hat{ddS1_1}, \\kappa_3), cddS1A_a \\sim N(\\hat{cddS1_1}, c\\kappa_3), \\\\\n& ddS1B_b \\sim N(\\hat{ddS1_2}, \\kappa_3), cddS1B_b \\sim N(\\hat{cddS1_2}, c\\kappa_3).\n\\end{aligned}\n\\] where a=1..46 and b=1..121 denote the indexes of acidic and basic groups.\nSimilarly \\(\\small pKa\\) an \\(\\small \\alpha\\) parameters were described separately for acids and based:\n\\[\n\\begin{aligned}\n& pKawA_{a} \\sim N(pKaAlit_{a}, \\tau_1), \\\\\n& pKawB_{b} \\sim N(pKaBlit_{b}, \\tau_1), \\\\\n& \\alpha mA_{a} \\sim N(\\hat{\\alpha m_1},\\tau_2), \\\\\n& \\alpha mB_{b} \\sim N(\\hat{\\alpha m_2},\\tau_2), \\\\\n& d\\alpha A_{a} \\sim N(\\hat{d\\alpha_1},\\tau_3), \\\\\n& d\\alpha B_{b} \\sim N(\\hat{d\\alpha_2},\\tau_3).\n\\end{aligned}\n\\]\nFurther, we created the matrices containing the value of parameters for i-th analyte, c-th column, m-th modifier an r-th dissociation step based on the value of neutral form and effects of column, organic modifier, and dissociation. This transformation was denoted as f(.). The exact procedure can be found in the model code (displayed later).\n\\[\n\\begin{aligned}\n& logkw_{c,i,r}= f(logkwN_i,clogkwN_i,dlogkwA_{a},cdlogkwA_{a}, dlogkwB_{b}, cdlogkwB_{b}) \\\\\n& S1_{m,c,i,r}  = f(S1mN_i,cS1mN_i, dS1mA_a, cdS1mA_a, S1mB_b, cdS1mB_b, ...\\\\\n& dS1N_i, cdS1N_i, ddS1A_a, cddS1A_a, ddS1B_b, cddS1B_b) \\\\\n& apH_{m,c,i,r} = f(\\hat{apH_1},\\hat{capH_1},\\hat{apH_2},\\hat{capH_2}) \\\\\n& S2_{m} = 10^{f(\\hat{logS2m},\\hat{dlogS2})} \\\\\n& pKaw_{i,r} = f(pKawA_{a},pKawB_{b}) \\\\\n& \\alpha_{m,i,r} = f(\\alpha mA_{a}, d\\alpha A_{a}, \\alpha mB_{b},d\\alpha B_{b})\n\\end{aligned}\n\\]\nResidual error model assumes different parameters for each column and analyte:\n\\[\n\\begin{aligned}\n& log(\\sigma_{i,c}) = f(log\\sigma_i, clog\\sigma_{i,c}) \\\\\n& log\\sigma_i  \\sim N(log(m\\sigma),s\\sigma) \\\\\n& clog\\sigma_{i,c} \\sim N(clogm\\sigma,s\\sigma_c);\n\\end{aligned}\n\\]\nThe detailed description of parameters is provided in the following table (BAV denotes between analyte variability):\n\n\nCode\n# to properly render in quarto: https://github.com/quarto-dev/quarto-cli/issues/3340\n\nName = c('$\\\\hat{logkw}$',\n         '$\\\\hat{S1m}$',\n         '$\\\\hat{dS1}$',\n         '$\\\\beta_1$',\n         '$\\\\beta_2$',\n         '$\\\\hat{dlogkw_1}$',\n         '$\\\\hat{dlogkw_2}$',\n         '$\\\\hat{dS1m_1}$',\n         '$\\\\hat{dS1m_2}$',\n         '$\\\\hat{ddS1_1}$',\n         '$\\\\hat{ddS1_2}$',\n         '$\\\\hat{apH_1}$',\n         '$\\\\hat{apH_2}$',\n         '$\\\\hat{dlogkT}$',\n         '$\\\\omega_1$',\n         '$\\\\omega_2$',\n         '$\\\\omega_3$',\n         '$\\\\rho$',\n         '$\\\\omega_T$',\n         '$\\\\kappa_1$',\n         '$\\\\kappa_2$',\n         '$\\\\kappa_3$',\n         '$\\\\hat{clogkw_c}$',\n         '$\\\\hat{cS1m_c}$',\n         '$\\\\hat{cdS1_c}$',\n         '$c\\\\beta_{c,1}$',\n         '$c\\\\beta_{c,2}$',\n         '$\\\\hat{cdlogkw_{c,1}}$',\n         '$\\\\hat{cdlogkw_{c,2}}$',\n         '$\\\\hat{cdS1m_{c,1}}$',\n         '$\\\\hat{cdS1m_{c,2}}$',\n         '$\\\\hat{cddS1_{c,1}}$',\n         '$\\\\hat{cddS1_{c,2}}$',\n         '$\\\\hat{cdlogkT_c}$',\n         '$capH_{c,1}$',\n         '$capH_{c,2}$',\n         '$c\\\\omega_{c,1}$',\n         '$c\\\\omega_{c,2}$',\n         '$c\\\\omega_{c,3}$',\n         '$c\\\\kappa_{c,1}$',\n         '$c\\\\kappa_{c,2}$',\n         '$c\\\\kappa_{c,3}$',\n         '$c\\\\omega_{T,c}$',\n         '$\\\\hat{logS2m}$',\n         '$\\\\hat{dlogS2}$',\n         '$\\\\hat{\\\\alpha m_1}$',\n         '$\\\\hat{\\\\alpha m_2}$',\n         '$\\\\hat{d\\\\alpha_1}$',\n         '$\\\\hat{d\\\\alpha_2}$',\n         '$\\\\tau_1$',\n         '$\\\\tau_2$',\n         '$\\\\tau_3$',\n         '$m\\\\sigma$',\n         '$s\\\\sigma$',\n         '$clogmsigma_c$',\n         '$c\\\\sigma_c$')\n\nNamecode = c('logkwHat',\n         'S1mHat',\n         'dS1Hat',\n         'beta[1]',\n         'beta[2]',\n         'dlogkwHat[1]',\n         'dlogkwHat[2]',\n         'dS1mHat[1]',\n         'dS1mHat[2]',\n         'ddS1Hat[1]',\n         'ddS1Hat[2]',\n         'apH[1]',\n         'apH[2]',\n         'dlogkTHat',\n         'omega[1]',\n         'omega[2]',\n         'omega[3]',\n         'rho[2,1]',\n         'omegaT',\n         'kappa[1]',\n         'kappa[2]',\n         'kappa[3]',\n         'clogkwHat[c]',\n         'cS1mHat[c]',\n         'cdS1Hat[c]',\n         'cbeta[c,1]',\n         'cbeta[c,2]',\n         'cdlogkwHat[c,1]',\n         'cdlogkwHat[c,2]',\n         'cdS1mHat[c,1]',\n         'cdS1mHat[c,2]',\n         'cddS1Hat[c,1]',\n         'cddS1Hat[c,2]',\n         'cdlogkTHat[c]',\n         'capH[c,1]',\n         'capH[c,2]',\n         'comega[c,1]',\n         'comega[c,2]',\n         'comega[c,3]',\n         'ckappa[c,1]',\n         'ckappa[c,2]',\n         'ckappa[c,3]',\n         'comegaT[c]',\n         'logS2mHat',\n         'dlogS2Hat',\n         'alphamHat[1]',\n         'alphamHat[2]',\n         'dalphaHat[1]',\n         'dalphaHat[2]',\n         'tau[1]',\n         'tau[2]',\n         'tau[3]',\n         'msigma',\n         'ssigma',\n         'clogmsigma[c]',\n         'cssigma[c]')\n\nDescription = c('typical logkw [Neutral]',\n                'effect of MeOH on logkw [Neutral]',\n                'effect of ACN on S1m [Neutral]',\n                'effect of logP on logkw [Neutral]',\n                'effect of logP on S1m [Neutral]',\n                'effect of dissociation on logkw [Acids]',\n                'effect of dissociation on logkw [Bases]',\n                'effect of dissociation on S1m [Acids]',\n                'effect of dissociation on S1m [Bases]',\n                'effect of dissociation on dS1 [Acids]',\n                'effect of dissociation on dS1 [Bases]',\n                'effect of pH on logkw [Acids]',\n                'effect of pH on logkw [Bases]',\n                'effect of temperature on logkw',\n                'sd of BAV for logkw [Neutral]',\n                'sd of BAV for S1 [Neutral]',\n                'sd of BAV for dS1 [Neutral]',\n                'correlation logkw vs S1 [Neutral]',\n                'sd of BAV for dlogkT [Neutral]',\n                'sd of BAV for dlogkw [Acids and Bases]',\n                'sd of BAV for dS1m [Acids and Bases]',\n                'sd of BAV for ddS1 [Acids and Bases]',\n                'effect of column c on logkw [Neutral]',\n                'effect of column c on S1m [Neutral]',\n                'effect of column c on dS1 [Neutral]',\n                'effect of column c on beta[1] [Neutral]',\n                'effect of column c on beta[2] [Neutral]',\n                'effect of column c on dlogkw [Acids]',\n                'effect of column c on dlogkw [Bases]',\n                'effect of column c on dS1m [Acids]',\n                'effect of column c on dS1m [Bases]',\n                'effect of column c on ddS1 [Acids]',\n                'effect of column c on ddS1 [Bases]',\n                'effect of column c on dlogkwT',\n                'effect of column c on apH [Acids]',\n                'effect of column c on apH [Bases]',\n                'sd of BAV for clogkw [Neutral]',\n                'sd of BAV for cS1 [Neutral]',\n                'sd of BAV for cdS1 [Neutral]',\n                'sd of BAV for cdlogkw [Acids and Bases]',\n                'sd of BAV for cdS1m [Acids and Bases]',\n                'sd of BAV for cddS1 [Acids and Bases]',\n                'sd of BAV for dlogkT',\n                'typical value of S2m (log10 scale)',\n                'effect of ACN on logS2m',\n                'effect of MeOH on pKa [Acids]',\n                'effect of MeOH on pKa [Bases]',\n                'effect of ACN on alpham [Acids]',\n                'effect of ACN on alpham [Bases]',\n                'sd of BAV for pKalit',\n                'sd of BAV for alpham',\n                'sd of BAV for dalpha',\n                'typical sd of residuals for XBridge',\n                'sd of BAV of residuals for XBridge',\n                'effect of column c on msigma (log scale)',\n                'sd of BAV of residuals for column c'\n                )\n\n\nPriors = c('N(2.2,2)',\n         'N(4, 1)',\n         'N(1, 1)',\n         'N(1, 0.125)',\n         'N(0.5, 0.5)',\n         'N(-1, 0.125)',\n         'N(-1, 0.125)',\n         'N(0, 0.5)',\n         'N(0, 0.5)',\n         'N(0, 0.25)',\n         'N(0, 0.25)',\n         'N(0, 0.1)',\n         'N(0, 0.1)',\n         'N(-0.087, 0.022)',\n         'N+(0, 2)',\n         'N+(0, 2)',\n         'N+(0, 2)',\n         'LKJ_CORR_N(0.75, 0.125)',\n         'N+(0, 0.022)',\n         'N+(0, 0.25)',\n         'N+(0, 0.25)',\n         'N+(0, 0.25)',\n         'N(0, 1)',\n         'N(0, 0.5)',\n         'N(0, 0.5)',\n         'N(0, 0.25)',\n         'N(0, 0.25)',\n         'N(0, 0.0625)',\n         'N(0, 0.0625)',\n         'N(0, 0.25)',\n         'N(0, 0.25)',\n         'N(0, 0.125)',\n         'N(0, 0.125)',\n         'N(0, 0.011)',\n         'N(0, 0.05)',\n         'N(0, 0.05)',\n         'N+(0, 1)',\n         'N+(0, 1)',\n         'N+(0, 1)',\n         'N+(0, 0.125)',\n         'N+(0, 0.125)',\n         'N+(0, 0.125)',\n         'N+(0, 0.011)',\n         'N(-0.7, 0.125);',\n         'N(1, 0.125);',\n         'N(2, 0.25)',\n         'N(-1, 0.25)',\n         'N(0, 0.125)',\n         'N(0, 0.125)',\n         'N+(0, 0.25)',\n         'N+(0, 0.125)',\n         'N+(0, 0.125)',\n         'N+(0,1)',\n         'N(0,1)',\n         'N+(0,125)',\n         'N+(0,125)')\n\ntable_of_parameters = data.frame(Name,Namecode,Description,Priors)\n\n\ntable_of_parameters %&gt;%\nkableExtra::kbl(caption = \"Desciption of model paramters\", escape = FALSE) %&gt;%\nkableExtra::kable_classic(full_width = F, html_font = \"Cambria\") %&gt;%\n kableExtra::pack_rows(\"XBridge Shield RP18 parameters\", 1, 22) %&gt;%\n kableExtra::pack_rows(\"between column differences\", 23, 43) %&gt;%\n kableExtra::pack_rows(\"S2\", 44, 45) %&gt;%\n kableExtra::pack_rows(\"pKa\", 46, 52) %&gt;%\n kableExtra::pack_rows(\"Residuals\", 53, 56) %&gt;%\n unclass() %&gt;%\n cat()\n\n\n\n\nDesciption of model paramters\n\n\n\n\nName\n\n\nNamecode\n\n\nDescription\n\n\nPriors\n\n\n\n\n\n\nXBridge Shield RP18 parameters\n\n\n\n\n\\(\\hat{logkw}\\)\n\n\nlogkwHat\n\n\ntypical logkw [Neutral]\n\n\nN(2.2,2)\n\n\n\n\n\\(\\hat{S1m}\\)\n\n\nS1mHat\n\n\neffect of MeOH on logkw [Neutral]\n\n\nN(4, 1)\n\n\n\n\n\\(\\hat{dS1}\\)\n\n\ndS1Hat\n\n\neffect of ACN on S1m [Neutral]\n\n\nN(1, 1)\n\n\n\n\n\\(\\beta_1\\)\n\n\nbeta[1]\n\n\neffect of logP on logkw [Neutral]\n\n\nN(1, 0.125)\n\n\n\n\n\\(\\beta_2\\)\n\n\nbeta[2]\n\n\neffect of logP on S1m [Neutral]\n\n\nN(0.5, 0.5)\n\n\n\n\n\\(\\hat{dlogkw_1}\\)\n\n\ndlogkwHat[1]\n\n\neffect of dissociation on logkw [Acids]\n\n\nN(-1, 0.125)\n\n\n\n\n\\(\\hat{dlogkw_2}\\)\n\n\ndlogkwHat[2]\n\n\neffect of dissociation on logkw [Bases]\n\n\nN(-1, 0.125)\n\n\n\n\n\\(\\hat{dS1m_1}\\)\n\n\ndS1mHat[1]\n\n\neffect of dissociation on S1m [Acids]\n\n\nN(0, 0.5)\n\n\n\n\n\\(\\hat{dS1m_2}\\)\n\n\ndS1mHat[2]\n\n\neffect of dissociation on S1m [Bases]\n\n\nN(0, 0.5)\n\n\n\n\n\\(\\hat{ddS1_1}\\)\n\n\nddS1Hat[1]\n\n\neffect of dissociation on dS1 [Acids]\n\n\nN(0, 0.25)\n\n\n\n\n\\(\\hat{ddS1_2}\\)\n\n\nddS1Hat[2]\n\n\neffect of dissociation on dS1 [Bases]\n\n\nN(0, 0.25)\n\n\n\n\n\\(\\hat{apH_1}\\)\n\n\napH[1]\n\n\neffect of pH on logkw [Acids]\n\n\nN(0, 0.1)\n\n\n\n\n\\(\\hat{apH_2}\\)\n\n\napH[2]\n\n\neffect of pH on logkw [Bases]\n\n\nN(0, 0.1)\n\n\n\n\n\\(\\hat{dlogkT}\\)\n\n\ndlogkTHat\n\n\neffect of temperature on logkw\n\n\nN(-0.087, 0.022)\n\n\n\n\n\\(\\omega_1\\)\n\n\nomega[1]\n\n\nsd of BAV for logkw [Neutral]\n\n\nN+(0, 2)\n\n\n\n\n\\(\\omega_2\\)\n\n\nomega[2]\n\n\nsd of BAV for S1 [Neutral]\n\n\nN+(0, 2)\n\n\n\n\n\\(\\omega_3\\)\n\n\nomega[3]\n\n\nsd of BAV for dS1 [Neutral]\n\n\nN+(0, 2)\n\n\n\n\n\\(\\rho\\)\n\n\nrho[2,1]\n\n\ncorrelation logkw vs S1 [Neutral]\n\n\nLKJ_CORR_N(0.75, 0.125)\n\n\n\n\n\\(\\omega_T\\)\n\n\nomegaT\n\n\nsd of BAV for dlogkT [Neutral]\n\n\nN+(0, 0.022)\n\n\n\n\n\\(\\kappa_1\\)\n\n\nkappa[1]\n\n\nsd of BAV for dlogkw [Acids and Bases]\n\n\nN+(0, 0.25)\n\n\n\n\n\\(\\kappa_2\\)\n\n\nkappa[2]\n\n\nsd of BAV for dS1m [Acids and Bases]\n\n\nN+(0, 0.25)\n\n\n\n\n\\(\\kappa_3\\)\n\n\nkappa[3]\n\n\nsd of BAV for ddS1 [Acids and Bases]\n\n\nN+(0, 0.25)\n\n\n\n\nbetween column differences\n\n\n\n\n\\(\\hat{clogkw_c}\\)\n\n\nclogkwHat[c]\n\n\neffect of column c on logkw [Neutral]\n\n\nN(0, 1)\n\n\n\n\n\\(\\hat{cS1m_c}\\)\n\n\ncS1mHat[c]\n\n\neffect of column c on S1m [Neutral]\n\n\nN(0, 0.5)\n\n\n\n\n\\(\\hat{cdS1_c}\\)\n\n\ncdS1Hat[c]\n\n\neffect of column c on dS1 [Neutral]\n\n\nN(0, 0.5)\n\n\n\n\n\\(c\\beta_{c,1}\\)\n\n\ncbeta[c,1]\n\n\neffect of column c on beta[1] [Neutral]\n\n\nN(0, 0.25)\n\n\n\n\n\\(c\\beta_{c,2}\\)\n\n\ncbeta[c,2]\n\n\neffect of column c on beta[2] [Neutral]\n\n\nN(0, 0.25)\n\n\n\n\n\\(\\hat{cdlogkw_{c,1}}\\)\n\n\ncdlogkwHat[c,1]\n\n\neffect of column c on dlogkw [Acids]\n\n\nN(0, 0.0625)\n\n\n\n\n\\(\\hat{cdlogkw_{c,2}}\\)\n\n\ncdlogkwHat[c,2]\n\n\neffect of column c on dlogkw [Bases]\n\n\nN(0, 0.0625)\n\n\n\n\n\\(\\hat{cdS1m_{c,1}}\\)\n\n\ncdS1mHat[c,1]\n\n\neffect of column c on dS1m [Acids]\n\n\nN(0, 0.25)\n\n\n\n\n\\(\\hat{cdS1m_{c,2}}\\)\n\n\ncdS1mHat[c,2]\n\n\neffect of column c on dS1m [Bases]\n\n\nN(0, 0.25)\n\n\n\n\n\\(\\hat{cddS1_{c,1}}\\)\n\n\ncddS1Hat[c,1]\n\n\neffect of column c on ddS1 [Acids]\n\n\nN(0, 0.125)\n\n\n\n\n\\(\\hat{cddS1_{c,2}}\\)\n\n\ncddS1Hat[c,2]\n\n\neffect of column c on ddS1 [Bases]\n\n\nN(0, 0.125)\n\n\n\n\n\\(\\hat{cdlogkT_c}\\)\n\n\ncdlogkTHat[c]\n\n\neffect of column c on dlogkwT\n\n\nN(0, 0.011)\n\n\n\n\n\\(capH_{c,1}\\)\n\n\ncapH[c,1]\n\n\neffect of column c on apH [Acids]\n\n\nN(0, 0.05)\n\n\n\n\n\\(capH_{c,2}\\)\n\n\ncapH[c,2]\n\n\neffect of column c on apH [Bases]\n\n\nN(0, 0.05)\n\n\n\n\n\\(c\\omega_{c,1}\\)\n\n\ncomega[c,1]\n\n\nsd of BAV for clogkw [Neutral]\n\n\nN+(0, 1)\n\n\n\n\n\\(c\\omega_{c,2}\\)\n\n\ncomega[c,2]\n\n\nsd of BAV for cS1 [Neutral]\n\n\nN+(0, 1)\n\n\n\n\n\\(c\\omega_{c,3}\\)\n\n\ncomega[c,3]\n\n\nsd of BAV for cdS1 [Neutral]\n\n\nN+(0, 1)\n\n\n\n\n\\(c\\kappa_{c,1}\\)\n\n\nckappa[c,1]\n\n\nsd of BAV for cdlogkw [Acids and Bases]\n\n\nN+(0, 0.125)\n\n\n\n\n\\(c\\kappa_{c,2}\\)\n\n\nckappa[c,2]\n\n\nsd of BAV for cdS1m [Acids and Bases]\n\n\nN+(0, 0.125)\n\n\n\n\n\\(c\\kappa_{c,3}\\)\n\n\nckappa[c,3]\n\n\nsd of BAV for cddS1 [Acids and Bases]\n\n\nN+(0, 0.125)\n\n\n\n\n\\(c\\omega_{T,c}\\)\n\n\ncomegaT[c]\n\n\nsd of BAV for dlogkT\n\n\nN+(0, 0.011)\n\n\n\n\nS2\n\n\n\n\n\\(\\hat{logS2m}\\)\n\n\nlogS2mHat\n\n\ntypical value of S2m (log10 scale)\n\n\nN(-0.7, 0.125);\n\n\n\n\n\\(\\hat{dlogS2}\\)\n\n\ndlogS2Hat\n\n\neffect of ACN on logS2m\n\n\nN(1, 0.125);\n\n\n\n\npKa\n\n\n\n\n\\(\\hat{\\alpha m_1}\\)\n\n\nalphamHat[1]\n\n\neffect of MeOH on pKa [Acids]\n\n\nN(2, 0.25)\n\n\n\n\n\\(\\hat{\\alpha m_2}\\)\n\n\nalphamHat[2]\n\n\neffect of MeOH on pKa [Bases]\n\n\nN(-1, 0.25)\n\n\n\n\n\\(\\hat{d\\alpha_1}\\)\n\n\ndalphaHat[1]\n\n\neffect of ACN on alpham [Acids]\n\n\nN(0, 0.125)\n\n\n\n\n\\(\\hat{d\\alpha_2}\\)\n\n\ndalphaHat[2]\n\n\neffect of ACN on alpham [Bases]\n\n\nN(0, 0.125)\n\n\n\n\n\\(\\tau_1\\)\n\n\ntau[1]\n\n\nsd of BAV for pKalit\n\n\nN+(0, 0.25)\n\n\n\n\n\\(\\tau_2\\)\n\n\ntau[2]\n\n\nsd of BAV for alpham\n\n\nN+(0, 0.125)\n\n\n\n\n\\(\\tau_3\\)\n\n\ntau[3]\n\n\nsd of BAV for dalpha\n\n\nN+(0, 0.125)\n\n\n\n\nResiduals\n\n\n\n\n\\(m\\sigma\\)\n\n\nmsigma\n\n\ntypical sd of residuals for XBridge\n\n\nN+(0,1)\n\n\n\n\n\\(s\\sigma\\)\n\n\nssigma\n\n\nsd of BAV of residuals for XBridge\n\n\nN(0,1)\n\n\n\n\n\\(clogmsigma_c\\)\n\n\nclogmsigma[c]\n\n\neffect of column c on msigma (log scale)\n\n\nN+(0,125)\n\n\n\n\n\\(c\\sigma_c\\)\n\n\ncssigma[c]\n\n\nsd of BAV of residuals for column c\n\n\nN+(0,125)"
  },
  {
    "objectID": "index.html#stan",
    "href": "index.html#stan",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Stan",
    "text": "Stan\nMultilevel modeling was performed in Stan software linked with R/ cmdstanr. For the inference we used the follwoing settings: number of iterations = 500, warmup = 1000, and number of Markov chains = 8. The reduce_sum function, which was selected to accelerate the calculations, works by parallelizing the execution of a single Stan chain across multiple cores. Convergence diagnostics were checked using Gelman−Rubin statistics and trace plots.\n\nInitialize variables and parameters\n\n\nCode\n# create Stan data set:\n\ndatastruct &lt;- with(data,\n                  list(nAnalytes=length(unique(data$METID)),\n                       nModifiers=length(unique(data$Mod2)),\n                       nColumns=length(unique(data$Column)),\n                       nObs=length(data$METID),\n                       analyte=match(data$METID, unique(data$METID)),\n                       modifier=match(data$Mod2, sort(unique(data$Mod2))),\n                       column=match(data$Column, unique(data$Column)),\n                       steps=4*(2-data$Mod2) + 10*(data$Mod2-1),\n                       hplcparam=cbind(data$tg,data$td,data$to,data$te,data$fio,data$fik,data$Mod2-1,data$pHo,\n                                       data$alpha1,data$alpha2,(data$Temp-25)/10,data$Column-1),\n                       logPobs=logPobs, \n                       maxR=maxR,\n                       R=R,\n                       nGroupsA=nGroupsA,\n                       nGroupsB=nGroupsB,\n                       pKaslitA=pKaslitA,\n                       pKaslitB=pKaslitB,\n                       idxGroupsA=idxGroupsA,\n                       idxGroupsB=idxGroupsB,\n                       trobs=data$RT,\n                       run_estimation=1))\n\n# initialize the values for each variable in each chain:\n\ninit &lt;- function(){\n  list(   logkwHat  = rnorm(1,2.2,2),\n          S1mHat    = rnorm(1,4,1),\n          dS1Hat    = rnorm(1,1,0.5),\n          dlogkwHat = rnorm(2,-1,0.125),\n          dS1mHat   = rnorm(2,0,0.5),\n          ddS1Hat   = rnorm(2,0,0.25),\n          logS2mHat = rnorm(1,-0.7,0.125),\n          dlogS2Hat = rnorm(1,1,0.125),\n          beta  = rnorm(2,c(1,0.5),c(0.125,0.5)),\n          dlogkTHat    = rnorm(1,-0.087,0.0022),\n          apH  = rnorm(2,0,0.1),\n          alphamHat  = rnorm(2,c(2,-1),0.25),\n          dalphaHat = rnorm(2,0,0.125),\n          tau   = c(0.25,0.125,0.125)*exp(rnorm(3, 0, 0.2)),\n          omega = c(1,1,1)*exp(rnorm(3, 0, 0.5)),\n          rho = matrix(c(1, 0.75, 0.75, 1), nrow=2),\n          omegaT  = rlnorm(1,log(0.022),0.2), \n          kappa = 0.25* exp(rnorm(3, 0, 0.2)),\n          \n          clogkwHat  =  rnorm(nColumns-1,0,1),\n          cS1mHat  =  rnorm(nColumns-1,0,0.5),\n          cdS1Hat  =  rnorm(nColumns-1,0,0.25),\n          cdlogkwHat = matrix(rnorm(2*(nColumns-1),0,0.0625),nrow=(nColumns-1)),\n          cdS1mHat = matrix(rnorm(2*(nColumns-1),0,0.25),nrow=(nColumns-1)),\n          cddS1Hat = matrix(rnorm(2*(nColumns-1),0,0.125),nrow=(nColumns-1)),\n          cbeta  = matrix(rnorm(2*(nColumns-1),0,0.25),nrow=(nColumns-1)),\n          cdlogkTHat = rnorm(nColumns-1,0,0.011),\n          \n          capH   = matrix(rnorm(2*(nColumns-1),0,0.05),nrow=(nColumns-1)),\n          comega = 0.1 * exp(matrix(rnorm(3*(nColumns-1),0,1),nrow=(nColumns-1))),\n          ckappa = 0.1 * exp(matrix(rnorm(3*(nColumns-1),0,0.125),nrow=(nColumns-1))),\n          comegaT = 0.1 * exp(matrix(rnorm(1*(nColumns-1),0,0.011),nrow=(nColumns-1))),\n          corr_L = diag(nColumns-1),\n          paramN =  cbind(2+0.75*(logPobs-2.2), 4*matrix(1,nAnalytes,1)+0.5*(logPobs-2.2)),\n          dS1N   =  matrix(0,nAnalytes,1),\n          dlogkT = rnorm(nAnalytes,-0.0868,0.0217),\n          dlogkwA = matrix(-1,nGroupsA,1),\n          dlogkwB = matrix(-1,nGroupsB,1),\n          dS1mA = matrix(0,nGroupsA,1),\n          dS1mB = matrix(0,nGroupsB,1),\n          dS1A = matrix(0,nGroupsA,1),\n          dS1B = matrix(0,nGroupsB,1),\n          \n          etaclogkwNStd = matrix(0,nColumns-1,nAnalytes),\n          etacS1mN = matrix(0,nColumns-1,nAnalytes),\n          etacdS1N = matrix(0,nColumns-1,nAnalytes),\n          etacdlogkT = matrix(0,nColumns-1,nAnalytes),\n          etacdlogkwA = matrix(0,nColumns-1,nGroupsA),\n          etacdlogkwB = matrix(0,nColumns-1,nGroupsB),\n          etacdS1mA = matrix(0,nColumns-1,nGroupsA),\n          etacdS1mB = matrix(0,nColumns-1,nGroupsB),\n          etacdS1A = matrix(0,nColumns-1,nGroupsA),\n          etacdS1B = matrix(0,nColumns-1, nGroupsB),\n          pKawA = pKaslitA,\n          pKawB = pKaslitB,\n          etaalphamA = matrix(0,nGroupsA,1),\n          etaalphamB = matrix(0,nGroupsB,1),\n          etadalphaA = matrix(0,nGroupsA,1),\n          etadalphaB = matrix(0,nGroupsB,1),\n          \n          msigma  = rlnorm(1,log(1),0.2),\n          ssigma  = rlnorm(1,log(0.2),0.2),\n          logsigma   = rnorm(nAnalytes,0,0.2),\n          \n          clogmsigma  = rnorm(nColumns-1,0,0.125),\n          cssigma     = rlnorm(nColumns-1,log(0.125),0.125),\n          etaclogsigma   = matrix(rnorm(nAnalytes*(nColumns-1),0,0.125),nrow=(nColumns-1))\n          \n  )\n}\n\n\n\n\nThe Stan model:\n\n\nCode\nwriteLines(readLines(\"stan/hplc-gra-fivecolumns.stan\"))\n\n\nfunctions {\n  // credit http://srmart.in/informative-priors-for-correlation-matrices-an-easy-approach/\n  real lkj_corr_point_lower_tri_lpdf(matrix rho, real point_mu_lower,\n                                     real point_scale_lower) {\n    // works only for [2x2 matrix]\n    real lpdf = lkj_corr_lpdf(rho | 1)\n                + normal_lpdf(rho[2, 1] | point_mu_lower, point_scale_lower);\n    return lpdf;\n  }\n  \n\n  // pH and fi at a given time at column inlet\n  vector gra_state(real t, vector hplcparam) {\n    vector[2] sol;\n    real tg = hplcparam[1];\n    real td = hplcparam[2];\n    real fio = hplcparam[5];\n    real fik = hplcparam[6];\n    real pHo = hplcparam[8];\n    real alpha1 = hplcparam[9];\n    real alpha2 = hplcparam[10];\n    real fi;\n    \n    fi = fio + (fik - fio) / tg * (t - td);\n    \n    if (t &lt; td) {\n      fi = fio;\n    } else if (t &gt; tg + td) {\n      fi = fik;\n    }\n    \n    sol[1] = fi;\n    sol[2] = pHo + alpha1 * fi + alpha2 * fi ^ 2;\n    \n    return sol;\n  }\n  \n real funlnki(vector logkw, vector apH, vector S1, real S2, vector pKaw, vector alpha,\n                  int nDiss, real fi, real pH) {\n    real lnki;\n    vector[3] logkix;\n    vector[2] pHmpKa;\n    \n    logkix = log(10) *(logkw - S1*(1+S2) * fi / (1 + S2 * fi) + apH * (pH - 7));\n    pHmpKa = log(10) *(pH - (pKaw + alpha * fi));\n    \n    if (nDiss == 0) {\n      lnki = logkix[1];\n    } else if (nDiss == 1) {\n      lnki = logkix[1] +\n             log1p_exp(pHmpKa[1] + logkix[2] - logkix[1]) -\n             log1p_exp(pHmpKa[1]);\n    } else if (nDiss == 2) {\n      lnki = logkix[1] +\n             log1p_exp(pHmpKa[1]+logkix[2]-logkix[1] + log1p_exp(pHmpKa[2]+logkix[3]-logkix[2])) -\n             log1p_exp(pHmpKa[1] + log1p_exp(pHmpKa[2]));\n    }\n    \n    return lnki;\n  }  \n \n  vector areaandslope(real dt, real lnki1, real lnki2, real invki1, real invki2) {\n    vector[2] cki_b;\n    real bo;\n    real cki;\n    \n    if (invki2 &gt; 1.001 * invki1) {\n      bo = (lnki1 - lnki2) / dt;\n      cki = (invki2 - invki1) / bo;\n    }\n    \n    else if (invki1 &gt; 1.001 * invki2) {\n      bo = (lnki2 - lnki1) / dt;\n      cki = (invki1 - invki2) / bo;\n    }\n    else {\n      bo = 0.001 / dt;\n      cki = dt * (invki2 + invki1) / 2;\n    }\n    \n    cki_b[1] = cki;\n    cki_b[2] = bo;\n    \n    return cki_b;\n  }\n  \n  real chromgratrapz(int steps, vector logkw, vector apH, vector S1,  real S2, vector pKaw,\n                     vector alpha, int nDiss, vector hplcparam) {\n                       \n    real tg = hplcparam[1];\n    real td = hplcparam[2];\n    real to = hplcparam[3];\n    real te = hplcparam[4];\n    \n    vector[1] sol;\n    real time1;\n    real time2;\n    vector[2] fipH1;\n    vector[2] fipH2;\n    real lnki1;\n    real lnki2;\n    real invki1;\n    real invki2;\n    vector[2] cki_b;\n    real cumki1;\n    real cumki2;\n    real bo;\n    real tr;\n    real dt;\n    \n    dt = tg / steps;\n    \n    time1 = 0;\n    time2 = td;\n    \n    fipH1 = gra_state(time1, hplcparam);\n    lnki1 = funlnki(logkw, apH, S1, S2, pKaw, alpha, nDiss, fipH1[1], fipH1[2]);\n    lnki2=lnki1;\n    \n    invki1 = exp(-lnki1)/to;\n    invki2 = invki1;\n    \n    cumki1 = 0;\n    cumki2 = td*invki1; \n    \n    bo = 0.001 / td;\n    \n    for (x in 1 : steps) {\n      if (cumki2 &gt;= 1) {\n        continue;\n      }\n      time1 = time2;\n      time2 += dt;\n      fipH2 = gra_state(time2, hplcparam);\n      lnki1 = lnki2;\n      lnki2 = funlnki(logkw, apH, S1, S2, pKaw, alpha, nDiss, fipH2[1], fipH2[2]);\n      invki1 = invki2;\n      invki2 = exp(-lnki2)/to;\n      cki_b = areaandslope(dt, lnki1, lnki2, invki1, invki2);\n      cumki1 = cumki2;\n      cumki2 += cki_b[1];\n      bo = cki_b[2];\n    }\n    \n    if (cumki2 &gt;= 1 && cumki1==0) {\n      tr = te+to+1/invki2;\n    } else if (cumki2 &gt;= 1) {\n      tr = te+to+time1+log1p_exp(log((1-cumki1)*bo*to) + lnki1)/bo;\n    } else if (cumki2 &lt; 1) {\n      tr = te+to+time2+(1-cumki2)/invki2;\n    }\n            \n    return tr;\n            \n  }\n  \n  real partial_sum(array[] int ind, int start, int end, \n                   vector trobs,\n                   array[] int steps,\n                   array[] vector hplcparam,\n                   array[] int analyte,\n                   array[] int column,\n                   array[] int modifier,\n                   array[] int R,\n                   array[,] vector logkw,\n                   array[,] vector apH,\n                   array[, ,] vector S1,\n                   array[,] real S2,\n                   array[] vector pKaw,\n                   array[,] vector alpha,\n                   array[,] real dlogkT,\n                   array[] vector sigma) {\n                     \n    real lp = 0;\n\n    for (z in start : end) {\n      \n    real y_hat = chromgratrapz(steps[z], \n                                logkw[analyte[z], column[z],  : ] + dlogkT[analyte[z],column[z]]  * hplcparam[z, 11],\n                                apH[analyte[z], column[z], : ],\n                                S1[analyte[z], modifier[z], column[z],  : ],\n                                S2[modifier[z], column[z]],\n                                pKaw[analyte[z],  : ],\n                                alpha[analyte[z],modifier[z],  : ],\n                                R[analyte[z]],\n                                hplcparam[z]);\n\n     lp = lp + student_t_lpdf(trobs[z] | 3, y_hat,  sigma[analyte[z],column[z]]);\n      \n    }\n    return lp;\n  }\n}\n\ndata {\n  int nAnalytes;            // number of analytes\n  int nColumns;             // number of columns\n  int nModifiers;           // number of org. modifiers\n  int nObs;                 // number of observations\n  array[nObs] int analyte;   // analyte indexes\n  array[nObs] int column;   // column indexes\n  array[nObs] int modifier;  // modifier indexes\n  array[nObs] int&lt;lower=1&gt; steps;  // steps for gradient retention time aproximation\n  array[nObs] vector[12] hplcparam; // [tg, td, to, te, fio, fik, org modifier, pHo, alpha1, alpha2, (temp-25)/10, column]\n  vector[nAnalytes] logPobs;\n  int&lt;lower=0, upper=2&gt; maxR; //\n  array[nAnalytes] int&lt;lower=0, upper=2&gt; R;\n  int&lt;lower=1&gt; nGroupsA;\n  int&lt;lower=1&gt; nGroupsB;\n  vector[nGroupsA] pKaslitA;\n  vector[nGroupsB] pKaslitB;\n  array[nGroupsA,2] int idxGroupsA;\n  array[nGroupsB,2] int idxGroupsB;\n  \n  vector[nObs] trobs;                   // observed retention factors \n  int&lt;lower=0, upper=1&gt; run_estimation; // 0 for prior predictive, 1 for estimation\n}\ntransformed data {\n  int grainsize = 1;\n  array[nObs] int ind = rep_array(1, nObs);\n}\n\nparameters {\n  \n  real logkwHat; // typical logkw [Neutral]\n  real S1mHat;   // effect of MeOH on logkw [Neutral]\n  real dS1Hat;   // effect of ACN on S1m [Neutral]\n  array[2] real dlogkwHat; // effect of dissociation on logkw [Acids, Bases]\n  array[2] real dS1mHat;   // effect of dissociation on S1m [Acids, Bases]\n  array[2] real ddS1Hat;   // effect of dissociation on dS1 [Acids, Bases] \n  real logS2mHat; // typical value of S2m (log10 scale)\n  real dlogS2Hat; // effect of ACN on logS2m\n  vector[2] beta; // effect of logP on logkw and S1m\n  real dlogkTHat; // effect of temperature on logkw\n  vector[2] apH;  // effect of pH on logkw [Acids, Bases]\n  array[2] real alphamHat;   // effect of MeOH on pKa [Acids, Bases]\n  array[2] real dalphaHat;   // effect of ACN on alpham [Acids, Bases]\n  vector&lt;lower=0&gt;[3] tau;   // sd for between analyte variability of pKa's\n  vector&lt;lower=0&gt;[3] omega; // sd of BAV [logkw,S1m, dS1]\n  corr_matrix[2] rho;      // correlation matrix [logkw vs. S1m] \n  real&lt;lower=0&gt; omegaT;     // sd of BAV [dlogkT]\n  vector&lt;lower=0&gt;[3] kappa; // sd of BAV [dlogkw,dS1m,ddS1]\n  \n  // 2nd column\n  vector[nColumns-1] clogkwHat;          // effect of column on logkw [Neutral]\n  vector[nColumns-1] cS1mHat;            // effect of column on S1m [Neutral]\n  vector[nColumns-1] cdS1Hat;            // effect of column on dS1 [Neutral]\n  matrix[nColumns-1,2] cdlogkwHat;      // effect of column on logkw [Acids, Bases]\n  matrix[nColumns-1,2] cdS1mHat;        // effect of column on dS1m [Acids, Bases]\n  matrix[nColumns-1,2] cddS1Hat;        // effect of column on ddS1 [Acids, Bases] \n  matrix[nColumns-1,2]  cbeta;\n  vector[nColumns-1]   cdlogkTHat;       // effect of column on dlogkTHat\n  matrix[nColumns-1,2] capH;             // effect of column on apH  [Acids, Bases]\n  matrix&lt;lower=0&gt;[nColumns-1,3] comega;  // sd of BAV [clogkw,cS1m,cdS1]\n  vector&lt;lower=0&gt;[nColumns-1]  comegaT;  // sd of BAV [cdlogkT]\n  matrix&lt;lower=0&gt;[nColumns-1,3] ckappa;  // sd of BAV [cdlogkw,cdS1m,cddS1]\n  cholesky_factor_corr[nColumns-1] corr_L;   // cholesky factor correlation matrix \n  \n  // 1st column\n  array[nAnalytes] vector[2] paramN;\n  vector[nAnalytes] dS1N;\n  vector[nAnalytes] dlogkT;\n  vector[nGroupsA] dlogkwA;\n  vector[nGroupsB] dlogkwB;\n  vector[nGroupsA] dS1mA;\n  vector[nGroupsB] dS1mB;\n  vector[nGroupsA] dS1A;\n  vector[nGroupsB] dS1B;\n\n  // 2nd column\n  matrix[nColumns-1, nAnalytes] etaclogkwNStd;\n  array[nColumns-1] vector[nAnalytes] etacS1mN;\n  array[nColumns-1] vector[nAnalytes] etacdS1N;\n  array[nColumns-1] vector[nAnalytes] etacdlogkT;\n  array[nColumns-1] vector[nGroupsA] etacdlogkwA;\n  array[nColumns-1] vector[nGroupsB] etacdlogkwB;\n  array[nColumns-1] vector[nGroupsA] etacdS1mA;\n  array[nColumns-1] vector[nGroupsB] etacdS1mB;\n  array[nColumns-1] vector[nGroupsA] etacdS1A;\n  array[nColumns-1] vector[nGroupsB] etacdS1B;\n   \n  // Dissociation\n  vector[nGroupsA] pKawA;\n  vector[nGroupsB] pKawB;\n  vector[nGroupsA] etaalphamA;\n  vector[nGroupsB] etaalphamB;\n  vector[nGroupsA] etadalphaA;\n  vector[nGroupsB] etadalphaB;\n  \n  // residual variability for the 1st and 2nd column\n  real&lt;lower=0&gt; msigma;   // typical sigma for the 1st column]\n  real&lt;lower=0&gt; ssigma;\n  vector[nAnalytes] logsigma; \n    \n  vector[nColumns-1] clogmsigma; // effect of column on log(msigma)]\n  vector&lt;lower=0&gt;[nColumns-1] cssigma; ; //sd of residual [1st,2nd column]\n  array[nColumns-1] vector[nAnalytes] etaclogsigma;\n}\ntransformed parameters {\n  \n  cov_matrix[2] Omega;\n  \n  array[nAnalytes] vector[3] miu;\n  array[nAnalytes,3] vector[nColumns-1] cmiu;\n  array[nAnalytes,nColumns]   vector[maxR + 1] logkwx;\n  array[nAnalytes,nModifiers, nColumns] vector[maxR + 1] S1x;\n  array[nModifiers,nColumns]  real S2x;\n  array[nAnalytes,nColumns]   vector[maxR + 1] apHx;\n  array[nAnalytes,nModifiers] vector[maxR] alphax;\n  array[nAnalytes, nColumns]  real dlogkTx;\n  array[nAnalytes] vector[maxR] pKawx;\n  array[nAnalytes] vector[nColumns] sigmax;\n  \n  array[nColumns-1] vector[nAnalytes] clogkwN;\n  matrix[nColumns-1, nAnalytes] etaclogkwN;\n  array[nColumns-1] vector[nAnalytes] cS1mN;\n  array[nColumns-1] vector[nAnalytes] cdS1N;\n  array[nColumns-1] vector[nGroupsA] cdlogkwA;\n  array[nColumns-1] vector[nGroupsB] cdlogkwB;\n  array[nColumns-1] vector[nGroupsA] cdS1mA;\n  array[nColumns-1] vector[nGroupsB] cdS1mB;\n  array[nColumns-1] vector[nGroupsA] cdS1A;\n  array[nColumns-1] vector[nGroupsB] cdS1B;\n   array[nColumns-1] vector[nAnalytes] cdlogkT;\n   array[nColumns-1] vector[nAnalytes] clogsigma;\n  vector[nGroupsA] alphamA;\n  vector[nGroupsB] alphamB;\n  vector[nGroupsA] dalphaA;\n  vector[nGroupsB] dalphaB;\n  \n  Omega = quad_form_diag(rho, omega[1 : 2]); // diag_matrix(omega) * rho * diag_matrix(omega)\n  \n  for (i in 1 : nAnalytes) {\n    miu[i, 1] = logkwHat + beta[1] * (logPobs[i] - 2.2);\n    miu[i, 2] = S1mHat   + beta[2] * (logPobs[i] - 2.2);\n    miu[i, 3] = dS1Hat;\n  }\n  \n   for (i in 1 : nAnalytes) {\n    for (c in 1 : (nColumns-1)) {\n    cmiu[i, 1, c] = clogkwHat[c] + cbeta[c,1] * (logPobs[i] - 2.2);\n    cmiu[i, 2, c] = cS1mHat[c]   + cbeta[c,2] * (logPobs[i] - 2.2);\n    cmiu[i, 3, c] = cdS1Hat[c];\n  }}\n   \n  // Matt's trick to use unit scale \n  etaclogkwN = diag_pre_multiply(comega[,1], corr_L * etaclogkwNStd); \n  \n  for (i in 1 : nAnalytes) { \n   logkwx[i, 1, : ]  =  paramN[i,1]*[1,1,1]';\n  for (c in 1 : (nColumns-1)) {\n   clogkwN[c,i] = cmiu[i, 1, c]  + etaclogkwN[c,i];\n   logkwx[i, c+1, : ]  =  (paramN[i,1]+clogkwN[c,i])*[1,1,1]'; \n  }}\n   \n  for (d in 1 : nGroupsA) {\n    logkwx[idxGroupsA[d,1], 1, 1+idxGroupsA[d,2]] += dlogkwA[d];\n    if (idxGroupsA[d,2]==1) {\n   logkwx[idxGroupsA[d,1], 1, 3] += dlogkwA[d];\n   }\n    for (c in 1 : (nColumns-1)) {\n   cdlogkwA[c,d] = cdlogkwHat[c,1] + ckappa[c,1]*etacdlogkwA[c,d];\n   logkwx[idxGroupsA[d,1], c+1, 1+idxGroupsA[d,2]] += dlogkwA[d]+cdlogkwA[c,d];\n   if (idxGroupsA[d,2]==1) {\n   logkwx[idxGroupsA[d,1], c+1, 3] += dlogkwA[d]+cdlogkwA[c,d];\n   }}}\n  \n  for (d in 1 : nGroupsB) {\n    logkwx[idxGroupsB[d,1], 1, idxGroupsB[d,2]] += dlogkwB[d];\n    if (idxGroupsB[d,2]==2) {\n    logkwx[idxGroupsB[d,1], 1, 1] += dlogkwB[d];\n    }\n    for (c in 1 : (nColumns-1)) {\n    cdlogkwB[c,d] = cdlogkwHat[c,2]+ ckappa[c,1]*etacdlogkwB[c,d];\n    logkwx[idxGroupsB[d,1], c+1, idxGroupsB[d,2]] += dlogkwB[d]+cdlogkwB[c,d];\n    if (idxGroupsB[d,2]==2) {\n    logkwx[idxGroupsB[d,1], c+1, 1] += dlogkwB[d]+cdlogkwB[c,d];\n    }}}\n   \n  for (i in 1 : nAnalytes) { \n    apHx[i, 1, : ] = [0,0,0]';\n    for (c in 1 : (nColumns-1)) {\n    apHx[i, c+1, : ] = [0,0,0]'; \n  }}\n   \n  for (d in 1 : nGroupsA) {\n    apHx[idxGroupsA[d,1], 1, 1+idxGroupsA[d,2]] += apH[1];\n  if (idxGroupsA[d,2]==1) {\n   apHx[idxGroupsA[d,1], 1, 3] += apH[1];\n   }\n  for (c in 1 : (nColumns-1)) {\n   apHx[idxGroupsA[d,1], c+1, 1+idxGroupsA[d,2]] += apH[1]+capH[c,1];\n  if (idxGroupsA[d,2]==1) {\n   apHx[idxGroupsA[d,1], c+1, 3] += apH[1]+capH[c,1];\n   }}}\n  \n  for (d in 1 : nGroupsB) {\n    apHx[idxGroupsB[d,1], 1, idxGroupsB[d,2]] += apH[2];\n         if (idxGroupsB[d,2]==2) {\n    apHx[idxGroupsB[d,1], 1, 1] += apH[2];\n   }\n   for (c in 1 : (nColumns-1)) {\n    apHx[idxGroupsB[d,1], c+1, idxGroupsB[d,2]] += apH[2]+capH[c,2];\n    if (idxGroupsB[d,2]==2) {\n    apHx[idxGroupsB[d,1], c+1, 1] += apH[2]+capH[c,2];\n   }}}\n   \n  \n  for (i in 1 : nAnalytes) { \n   S1x[i, 1, 1, : ]  =  paramN[i,2]*[1,1,1]';\n   S1x[i, 2, 1, : ]  =  paramN[i,2]*[1,1,1]' + dS1N[i]; \n  for (c in 1 : (nColumns-1)) {\n   cS1mN[c,i] = cmiu[i,2,c] + comega[c,2]*etacS1mN[c,i];\n   cdS1N[c,i] = cmiu[i,3,c] + comega[c,3]*etacdS1N[c,i];\n   S1x[i, 1, c+1, : ]  =  (paramN[i,2]+cS1mN[c,i])*[1,1,1]' ;\n   S1x[i, 2, c+1, : ]  =  (paramN[i,2]+cS1mN[c,i])*[1,1,1]' + (dS1N[i]+cdS1N[c,i]); \n  }}\n   \n  for (d in 1 : nGroupsA) {\n   S1x[idxGroupsA[d,1], 1, 1, 1+idxGroupsA[d,2]] += dS1mA[d];\n   S1x[idxGroupsA[d,1], 2, 1, 1+idxGroupsA[d,2]] += dS1mA[d]+dS1A[d]; \n    \n  if (idxGroupsA[d,2]==1) {\n   S1x[idxGroupsA[d,1], 1, 1, 3] += dS1mA[d];\n   S1x[idxGroupsA[d,1], 2, 1, 3] += dS1mA[d]+dS1A[d];\n   }\n   \n  for (c in 1 : (nColumns-1)) {  \n   cdS1mA[c,d]= cdS1mHat[c,1] + ckappa[c,2]*etacdS1mA[c,d];\n   cdS1A[c,d] = cddS1Hat[c,1] + ckappa[c,3]*etacdS1A[c,d];\n   S1x[idxGroupsA[d,1], 1, c+1, 1+idxGroupsA[d,2]] += dS1mA[d]        +cdS1mA[c,d];\n   S1x[idxGroupsA[d,1], 2, c+1, 1+idxGroupsA[d,2]] += dS1mA[d]+dS1A[d]+cdS1mA[c,d]+cdS1A[c,d];\n  if (idxGroupsA[d,2]==1) {\n   S1x[idxGroupsA[d,1], 1, c+1, 3] += dS1mA[d]        +cdS1mA[c,d];\n   S1x[idxGroupsA[d,1], 2, c+1, 3] += dS1mA[d]+dS1A[d]+cdS1mA[c,d]+cdS1A[c,d];\n   }}}\n  \n  for (d in 1 : nGroupsB) {\n    S1x[idxGroupsB[d,1], 1, 1, idxGroupsB[d,2]] += dS1mB[d];\n    S1x[idxGroupsB[d,1], 2, 1, idxGroupsB[d,2]] += dS1mB[d]+dS1B[d];\n    if (idxGroupsB[d,2]==2) {\n    S1x[idxGroupsB[d,1], 1, 1, 1] += dS1mB[d];\n    S1x[idxGroupsB[d,1], 2, 1, 1] += dS1mB[d]+dS1B[d];\n   }\n    for (c in 1 : (nColumns-1)) {\n    cdS1mB[c,d]= cdS1mHat[c,2] + ckappa[c,2]*etacdS1mB[c,d];\n    cdS1B[c,d] = cddS1Hat[c,2] + ckappa[c,3]*etacdS1B[c,d];\n\n    S1x[idxGroupsB[d,1], 1, c+1, idxGroupsB[d,2]] += dS1mB[d]        +cdS1mB[c,d];\n    S1x[idxGroupsB[d,1], 2, c+1, idxGroupsB[d,2]] += dS1mB[d]+dS1B[d]+cdS1mB[c,d]+cdS1B[c,d];\n  if (idxGroupsB[d,2]==2) {\n    S1x[idxGroupsB[d,1], 1, c+1, 1] += dS1mB[d]        +cdS1mB[c,d];\n    S1x[idxGroupsB[d,1], 2, c+1, 1] += dS1mB[d]+dS1B[d]+cdS1mB[c,d]+cdS1B[c,d];\n   }}} \n  \n   S2x[1,1] = 10^(logS2mHat);\n   S2x[2,1] = 10^(logS2mHat + dlogS2Hat);\n   \n   for (c in 1 : (nColumns-1)) {\n   S2x[1,c+1] = S2x[1,1];\n   S2x[2,c+1] = S2x[2,1];\n   }\n   \n  for (i in 1 : nAnalytes) { \n   dlogkTx[i, 1]  = dlogkT[i];\n  for (c in 1 : (nColumns-1)) {\n   cdlogkT[c,i] = cdlogkTHat[c]+comegaT[c]*etacdlogkT[c,i];\n   dlogkTx[i, c+1]  =  dlogkT[i] + cdlogkT[c,i];\n  }}\n  \n  for (i in 1 : nAnalytes) { \n   pKawx[i, : ]  = [0,0]';\n   alphax[i, 1, : ]  = [0,0]'; \n   alphax[i, 2, : ]  = [0,0]'; \n  }\n  \n  for (d in 1 : nGroupsA) {\n    \n  alphamA[d] = alphamHat[1] + tau[2]*etaalphamA[d];\n  dalphaA[d] = dalphaHat[1] + tau[3]*etadalphaA[d];\n   \n  pKawx[idxGroupsA[d,1], idxGroupsA[d,2]] = pKawA[d];\n  alphax[idxGroupsA[d,1], 1, idxGroupsA[d,2]]= alphamA[d];\n  alphax[idxGroupsA[d,1], 2, idxGroupsA[d,2]]= alphamA[d]+dalphaA[d];\n   }\n  \n  for (d in 1 : nGroupsB) {\n    alphamB[d] = alphamHat[2] + tau[2]*etaalphamB[d];\n    dalphaB[d] = dalphaHat[2] + tau[3]*etadalphaB[d];\n    pKawx[idxGroupsB[d,1], idxGroupsB[d,2]] = pKawB[d];\n    alphax[idxGroupsB[d,1], 1, idxGroupsB[d,2]]= alphamB[d];\n    alphax[idxGroupsB[d,1], 2, idxGroupsB[d,2]]= alphamB[d]+dalphaB[d];\n   }\n   \n  for (i in 1 : nAnalytes) { \n   sigmax[i, 1] = exp(logsigma[i]);\n   for (c in 1 : (nColumns-1)) {\n   clogsigma[c,i] = clogmsigma[c] + cssigma[c]*etaclogsigma[c,i];\n   sigmax[i, c+1] = exp(logsigma[i]+clogsigma[c,i]); \n  }}\n}\n\nmodel {\n  logkwHat ~ normal(2.2, 2);\n  S1mHat ~ normal(4, 1);\n  dS1Hat ~ normal(1, 0.5);\n  dlogkwHat ~ normal(-1, 0.125);\n  dS1mHat   ~ normal(0, 0.5);\n  ddS1Hat   ~ normal(0, 0.25);\n  logS2mHat ~ normal(-0.7, 0.125);\n  dlogS2Hat ~ normal(1, 0.125);\n  beta[{1}] ~ normal(1, 0.125);\n  beta[{2}] ~ normal(0.5, 0.5);\n  dlogkTHat ~ normal(-0.087, 0.022);\n  apH       ~ normal(0, 0.1);\n  \n  alphamHat[{1}] ~ normal(2, 0.25);\n  alphamHat[{2}] ~ normal(-1, 0.25);\n  dalphaHat ~ normal(0, 0.125);\n  tau[{1}] ~ normal(0, 0.25);\n  tau[{2,3}] ~ normal(0, 0.125);\n  omega ~ normal(0, 2);\n  rho ~ lkj_corr_point_lower_tri(0.75, 0.125);\n  omegaT ~ normal(0, 0.022);\n  kappa ~ normal(0, 0.25);\n    \n  clogkwHat ~ normal(0, 1);\n  cS1mHat ~ normal(0, 0.5);\n  cdS1Hat ~ normal(0, 0.25);\n  to_vector(cdlogkwHat) ~ normal(0, 0.0625);\n  to_vector(cdS1mHat) ~ normal(0, 0.25);\n  to_vector(cddS1Hat) ~ normal(0, 0.125); \n  to_vector(cbeta) ~ normal(0, 0.25);\n  cdlogkTHat ~ normal(0, 0.011);\n  to_vector(capH) ~ normal(0, 0.05);\n  to_vector(comega) ~ normal(0, 0.5);\n  comegaT ~ normal(0, 0.011);\n  to_vector(ckappa) ~ normal(0, 0.125);\n   \n  corr_L~lkj_corr_cholesky(2.0);\n  \n  for (i in 1 : nAnalytes) {\n  paramN[i] ~ multi_normal(miu[i,1:2], Omega);\n  }\n  \n  dS1N ~ normal(miu[,3], omega[3]);\n  dlogkT ~ normal(dlogkTHat, omegaT);\n  dlogkwA ~ normal(dlogkwHat[1], kappa[1]);\n  dlogkwB ~ normal(dlogkwHat[2], kappa[1]);\n  dS1mA ~ normal(dS1mHat[1], kappa[2]);\n  dS1mB ~ normal(dS1mHat[2], kappa[2]);\n  dS1A ~ normal(ddS1Hat[1], kappa[3]);\n  dS1B ~ normal(ddS1Hat[2], kappa[3]);\n  \n  to_vector(etaclogkwNStd) ~ normal(0, 1);\n  \n for (c in 1 : (nColumns-1)) { \n  etacS1mN[c] ~ normal(0,1);\n  etacdS1N[c] ~ normal(0,1);\n  etacdlogkT[c] ~ normal(0,1);\n  etacdlogkwA[c] ~ normal(0,1);\n  etacdlogkwB[c] ~ normal(0,1);\n  etacdS1mA[c] ~ normal(0,1);\n  etacdS1mB[c] ~ normal(0,1);\n  etacdS1A[c] ~ normal(0,1);\n  etacdS1B[c] ~ normal(0,1);\n }\n \n  pKawA ~ normal(pKaslitA, tau[1]);\n  pKawB ~ normal(pKaslitB, tau[1]);\n  etaalphamA ~ normal(0,1);\n  etaalphamB ~ normal(0,1);\n  etadalphaA ~ normal(0,1);\n  etadalphaB ~ normal(0,1);\n  \n  msigma ~ normal(0,1);\n  ssigma ~ normal(0,1);\n  logsigma  ~ normal(log(msigma),ssigma); \n  \n  clogmsigma ~ normal(0,0.125);\n  cssigma ~ normal(0,0.125);\n  \n  for (c in 1 : (nColumns-1)) { \n  etaclogsigma[c]  ~ normal(0,1); \n  }\n  \n  if (run_estimation == 1) {\n\n    target += reduce_sum(partial_sum, ind, grainsize, trobs, steps,\n                         hplcparam, analyte, column, modifier, R, logkwx, apHx,\n                         S1x, S2x, pKawx, alphax, dlogkTx, sigmax);\n  }\n}\n\ngenerated quantities {\n   corr_matrix[nColumns-1] crho;\n   crho = corr_L * corr_L';\n}\n\n\n\n\nFitting the model\nCompile the model:\n\n\nCode\nmod1 &lt;- cmdstan_model(\"stan/hplc-gra-fivecolumns.stan\", \n                      stanc_options = list(\"O1\"), \n                      cpp_options = list(stan_threads = TRUE))\n# for optimization\nmodode &lt;- cmdstan_model(\"stan/hplc-gra-fivecolumns.stan\", \n                      stanc_options = list(\"O1\"))\n\n\nThe optimization was used for initial testing:\n\n\nCode\nfit_ode &lt;- modode$optimize(\n  data = datastruct,\n  output_dir = \"stanfiles\",\n  init = init\n)\n\nfit_ode$print(max_rows=100)\n\n\nFor local computations one can use cmdstanr:\n\n\nCode\n# fit &lt;- mod1$sample(\n#   data = datastruct,\n#   output_dir = \"stanfiles\",\n#   init = init,\n#   iter_warmup = 1000,\n#   iter_sampling = 1000,\n#   chains = 4,\n#   parallel_chains = 4,\n#   threads_per_chain = 6,\n#   refresh = 100,\n#   adapt_delta=0.9\n# )\n\n\nWe performed computations at the Academic Computer Center in Gdańsk, Tryton Cluster. In this case:\n\nwe dumped the necessary data to .json format\n\n\n\nCode\nwrite_stan_json(datastruct, \"stan/standata.json\", always_decimal = FALSE)\nwrite_stan_json(init(), \"stan/init-1.json\", always_decimal = FALSE)\nwrite_stan_json(init(), \"stan/init-2.json\", always_decimal = FALSE)\nwrite_stan_json(init(), \"stan/init-3.json\", always_decimal = FALSE)\nwrite_stan_json(init(), \"stan/init-4.json\", always_decimal = FALSE)\nwrite_stan_json(init(), \"stan/init-5.json\", always_decimal = FALSE)\nwrite_stan_json(init(), \"stan/init-6.json\", always_decimal = FALSE)\nwrite_stan_json(init(), \"stan/init-7.json\", always_decimal = FALSE)\nwrite_stan_json(init(), \"stan/init-8.json\", always_decimal = FALSE)\n\n\n\nwe created the batch file:\n\n \n#!/bin/bash -l\n#SBATCH --job-name=cmdstan_conda\n#SBATCH -N 1\n#SBATCH -n 24\n#SBATCH -p batch\n#SBATCH --time=48:00:00\n#SBATCH --mem=64gb\n#SBATCH --array=1-8%8\n\nmodule load tryton/cmdstan/2.30.1-conda\nexport STAN_THREADS=true\nexport CMDSTAN_MODEL_NAME=\"hplc-gra-twocolumns\"\nexport MODEL_SRC_DIR=${TASK_USER_WORK}\ncd ${MODEL_SRC_DIR}\n[ -f ${CMDSTAN_MODEL_NAME} ] && echo \"Model \"${CMDSTAN_MODEL_NAME}\" exists\" || cmdstan_model ${CMDSTAN_MODEL_NAME}\nwait\n${PWD}/${CMDSTAN_MODEL_NAME} sample num_samples=500 num_warmup=1000 algorithm=hmc engine=nuts max_depth=10 stepsize=0.01 adapt delta=0.9 data file=$PWD/standata.json init=$PWD/init-${SLURM_ARRAY_TASK_ID}.json  num_threads=${SLURM_NTASKS} output file=$PWD/output_${SLURM_ARRAY_TASK_ID}.csv \n\n\nAfter calculations, we loaded the output files using cmdstanr:\n\n\n\nCode\nfit &lt;- cmdstanr::as_cmdstan_fit(c(\n                                  'stanfiles/output_1.csv',\n                                  'stanfiles/output_2.csv',\n                                  'stanfiles/output_3.csv',\n                                  'stanfiles/output_4.csv',\n                                  'stanfiles/output_5.csv',\n                                  'stanfiles/output_6.csv',\n                                  'stanfiles/output_7.csv',\n                                  'stanfiles/output_8.csv'\n                                ))\n\n\n\n\nCode\n# saved_rds_file &lt;- 'save/lc-ms-main'\n# fit$save_object(file = saved_rds_file)\n# fit &lt;- readRDS(saved_rds_file)\n\n\n\nfinally we checked the diagnostics\n\nThe diagnostics are reasonable given model complexity\n\n\nCode\n #fit$cmdstan_diagnose()\n setwd(\"stanfiles\")\n str = paste0(cmdstan_path(), \"/bin/diagnose  output_*.csv\")\n system(str,intern=TRUE)\n\n\nOutput copied here to save time:\n [1] \"Processing csv files: output_1.csv, output_2.csv, output_3.csv, output_4.csv, output_5.csv, output_6.csv, output_7.csv, output_8.csv\"\n [2] \"\"\n [3] \"Checking sampler transitions treedepth.\" \n [4] \"4000 of 4000 (100.00%) transitions hit the maximum treedepth limit of 10, or 2^10 leapfrog steps.\" \n [5] \"Trajectories that are prematurely terminated due to this limit will result in slow exploration.\" \n [6] \"For optimal performance, increase this limit.\" \n [7] \"\"\n [8] \"Checking sampler transitions for divergences.\" \n [9] \"No divergent transitions found.\" \n[10] \"\"\n[11] \"Checking E-BFMI - sampler transitions HMC potential energy.\" \n[12] \"E-BFMI satisfactory.\"\n[13] \"\"\n[14] \"Effective sample size satisfactory.\" \n[15] \"\"\n[16] \"The following parameters had split R-hat greater than 1.05:\" \n[17] \"etacdS1N[3,38], etaalphamB[92]\"\n[18] \"Such high values indicate incomplete mixing and biased estimation.\"\n[19] \"You should consider regularizating your model with additional prior information or a more effective parameterization.\" \n[20] \"\"\n[21] \"Processing complete.\""
  },
  {
    "objectID": "index.html#summary-of-model-parameters-table",
    "href": "index.html#summary-of-model-parameters-table",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Summary of model parameters (table):",
    "text": "Summary of model parameters (table):\n\n\nCode\n# fit$print(max_rows=200) # for first 200 parameters\n\nfit$print(c(\"logkwHat\",\"S1mHat\",\"dS1Hat\",\n            \"dlogkwHat\",\"dS1mHat\",\"ddS1Hat\",\n            \"logS2mHat\",\"dlogS2Hat\",\n            \"beta\",\n            \"dlogkTHat\",\"apH\",\n            \"omega\",\"omegaT\", \"kappa\",\n            \"rho[2,1]\",\n            \"msigma\",\"ssigma\"), max_rows = 26)\n\n\n     variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n logkwHat      3.60   3.60 0.08 0.08  3.47  3.72 1.00     5947     3030\n S1mHat        4.92   4.92 0.08 0.08  4.79  5.05 1.00     5251     3063\n dS1Hat        0.61   0.61 0.05 0.05  0.53  0.69 1.00     3259     2365\n dlogkwHat[1] -0.79  -0.79 0.07 0.07 -0.91 -0.67 1.00     7672     3143\n dlogkwHat[2] -0.97  -0.97 0.05 0.05 -1.05 -0.88 1.00     5300     2998\n dS1mHat[1]    0.17   0.17 0.12 0.12 -0.03  0.36 1.00     4231     3375\n dS1mHat[2]    0.12   0.11 0.07 0.07  0.00  0.24 1.00     2482     2783\n ddS1Hat[1]    0.28   0.28 0.08 0.08  0.15  0.41 1.00     6200     3217\n ddS1Hat[2]   -0.67  -0.67 0.05 0.06 -0.76 -0.58 1.00     6993     3444\n logS2mHat    -0.31  -0.31 0.01 0.01 -0.33 -0.28 1.02      432      986\n dlogS2Hat     0.42   0.42 0.01 0.01  0.41  0.43 1.01      552     1093\n beta[1]       0.84   0.84 0.04 0.04  0.77  0.91 1.00     7278     3170\n beta[2]       0.51   0.51 0.05 0.05  0.43  0.58 1.00     3976     2814\n dlogkTHat    -0.09  -0.09 0.00 0.00 -0.09 -0.08 1.00     4047     2966\n apH[1]       -0.03  -0.03 0.00 0.00 -0.03 -0.03 1.00     4583     3724\n apH[2]        0.08   0.08 0.00 0.00  0.08  0.08 1.00     3114     3288\n omega[1]      0.92   0.92 0.06 0.06  0.83  1.02 1.00     5132     2669\n omega[2]      0.93   0.93 0.06 0.06  0.84  1.03 1.00     4993     3096\n omega[3]      0.55   0.55 0.03 0.03  0.50  0.61 1.00     8536     3214\n omegaT        0.03   0.03 0.00 0.00  0.03  0.04 1.00     7750     3273\n kappa[1]      0.59   0.58 0.03 0.03  0.53  0.65 1.00     4404     3301\n kappa[2]      0.69   0.69 0.05 0.05  0.62  0.77 1.00     3416     3502\n kappa[3]      0.55   0.55 0.04 0.04  0.49  0.61 1.00     3604     3242\n rho[2,1]      0.87   0.87 0.02 0.02  0.83  0.91 1.00     3500     3223\n msigma        0.39   0.39 0.03 0.03  0.35  0.44 1.00     9144     3009\n ssigma        0.81   0.81 0.05 0.05  0.74  0.90 1.00    12125     2859\n\n\nCode\nfit$print(c(\"alphamHat\",\"dalphaHat\",\n            \"tau\"), max_rows = 7)\n\n\n     variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n alphamHat[1]  2.22   2.22 0.15 0.15  1.96  2.47 1.00     1721     2559\n alphamHat[2] -1.35  -1.35 0.10 0.10 -1.51 -1.18 1.01     1282     2346\n dalphaHat[1]  0.22   0.22 0.10 0.10  0.06  0.38 1.00     2171     2544\n dalphaHat[2] -0.20  -0.20 0.07 0.07 -0.32 -0.08 1.01     1514     2412\n tau[1]        0.88   0.88 0.05 0.05  0.81  0.97 1.00     6372     3337\n tau[2]        0.96   0.96 0.06 0.06  0.87  1.06 1.00     2193     2683\n tau[3]        0.79   0.79 0.05 0.05  0.71  0.88 1.00     1967     2870\n\n\nCode\nfit$print(c(\"clogkwHat\",\"cS1mHat\",\"cdS1Hat\",\n            \"cdlogkwHat\",\"cdS1mHat\",\"cddS1Hat\",\n            \"cbeta\",\n            \"cdlogkTHat\",\n            \"capH\",\n            \"comega\", \"ckappa\", \"comegaT\",\n            \"crho\",\n            \"clogmsigma\",\"cssigma\"), max_rows = 108)\n\n\n        variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n clogkwHat[1]     0.43   0.43 0.01 0.01  0.41  0.45 1.01      554     1048\n clogkwHat[2]     0.18   0.18 0.01 0.01  0.16  0.21 1.01      734     1437\n clogkwHat[3]     0.11   0.11 0.01 0.01  0.09  0.13 1.01      612     1192\n clogkwHat[4]     0.18   0.18 0.01 0.01  0.16  0.19 1.01      726     1350\n cS1mHat[1]       0.59   0.59 0.02 0.02  0.56  0.62 1.00     2127     2781\n cS1mHat[2]      -0.10  -0.10 0.02 0.02 -0.14 -0.06 1.00     2010     2704\n cS1mHat[3]       0.37   0.37 0.02 0.02  0.34  0.40 1.00     1308     3004\n cS1mHat[4]       0.50   0.50 0.02 0.02  0.47  0.52 1.00     1837     3007\n cdS1Hat[1]       0.15   0.15 0.01 0.01  0.13  0.17 1.01      928     1643\n cdS1Hat[2]       0.81   0.81 0.03 0.02  0.77  0.85 1.01      379      872\n cdS1Hat[3]       0.51   0.51 0.04 0.04  0.44  0.58 1.05      153      462\n cdS1Hat[4]       0.04   0.04 0.02 0.02  0.01  0.06 1.00      607     1094\n cdlogkwHat[1,1]  0.04   0.04 0.02 0.02  0.02  0.07 1.00     2224     2870\n cdlogkwHat[2,1] -0.05  -0.05 0.02 0.02 -0.08 -0.02 1.00     1549     2160\n cdlogkwHat[3,1] -0.03  -0.03 0.02 0.02 -0.06  0.00 1.00     1668     2740\n cdlogkwHat[4,1]  0.04   0.04 0.02 0.02  0.02  0.07 1.00     1319     2124\n cdlogkwHat[1,2]  0.00   0.00 0.01 0.01 -0.02  0.02 1.00     1667     2364\n cdlogkwHat[2,2] -0.04  -0.04 0.02 0.02 -0.07 -0.01 1.01     1538     2256\n cdlogkwHat[3,2] -0.06  -0.06 0.01 0.01 -0.08 -0.04 1.01     1175     1869\n cdlogkwHat[4,2] -0.03  -0.03 0.01 0.01 -0.05 -0.01 1.00     1137     2304\n cdS1mHat[1,1]   -0.01  -0.01 0.04 0.04 -0.09  0.06 1.00     3059     3209\n cdS1mHat[2,1]   -0.19  -0.19 0.06 0.06 -0.29 -0.10 1.00     2963     2774\n cdS1mHat[3,1]   -0.49  -0.49 0.05 0.05 -0.56 -0.41 1.00     2231     2921\n cdS1mHat[4,1]   -0.23  -0.23 0.04 0.04 -0.30 -0.16 1.00     2450     3229\n cdS1mHat[1,2]    0.36   0.36 0.03 0.03  0.31  0.41 1.00     2707     3167\n cdS1mHat[2,2]   -0.41  -0.41 0.04 0.04 -0.47 -0.35 1.00     2232     3005\n cdS1mHat[3,2]   -0.09  -0.09 0.03 0.03 -0.14 -0.04 1.00     1905     2758\n cdS1mHat[4,2]    0.29   0.29 0.03 0.03  0.24  0.34 1.00     2106     2691\n cddS1Hat[1,1]    0.05   0.05 0.03 0.03  0.01  0.09 1.00     4704     3379\n cddS1Hat[2,1]    0.13   0.13 0.05 0.05  0.06  0.21 1.00     2515     2663\n cddS1Hat[3,1]    0.46   0.46 0.09 0.09  0.32  0.61 1.00      847     1433\n cddS1Hat[4,1]    0.00   0.00 0.02 0.02 -0.04  0.04 1.00     4056     3302\n cddS1Hat[1,2]    0.17   0.17 0.02 0.02  0.14  0.19 1.00     2144     3206\n cddS1Hat[2,2]    0.57   0.57 0.03 0.03  0.52  0.62 1.00     1653     2285\n cddS1Hat[3,2]    0.50   0.51 0.06 0.06  0.41  0.60 1.03      359      938\n cddS1Hat[4,2]   -0.04  -0.04 0.02 0.01 -0.06 -0.01 1.00     3877     3310\n cbeta[1,1]       0.00   0.00 0.01 0.01 -0.01  0.01 1.01      886     1478\n cbeta[2,1]      -0.02  -0.02 0.01 0.01 -0.03  0.00 1.01     1160     1953\n cbeta[3,1]      -0.03  -0.03 0.01 0.01 -0.04 -0.02 1.01      945     1688\n cbeta[4,1]      -0.02  -0.02 0.01 0.01 -0.03 -0.01 1.01     1001     1807\n cbeta[1,2]      -0.07  -0.07 0.01 0.01 -0.09 -0.05 1.00     2265     2809\n cbeta[2,2]       0.10   0.10 0.01 0.01  0.08  0.12 1.00     2647     2838\n cbeta[3,2]      -0.03  -0.03 0.01 0.01 -0.04 -0.01 1.00     2162     2837\n cbeta[4,2]      -0.02  -0.02 0.01 0.01 -0.03  0.00 1.00     2452     2849\n cdlogkTHat[1]   -0.01  -0.01 0.00 0.00 -0.01  0.00 1.00     3880     3363\n cdlogkTHat[2]   -0.02  -0.02 0.00 0.00 -0.02 -0.02 1.00     4513     3484\n cdlogkTHat[3]   -0.01  -0.01 0.00 0.00 -0.01  0.00 1.00     3368     3541\n cdlogkTHat[4]    0.00   0.00 0.00 0.00 -0.01  0.00 1.00     4096     3513\n capH[1,1]       -0.01  -0.01 0.00 0.00 -0.02 -0.01 1.00     4697     3790\n capH[2,1]       -0.02  -0.02 0.00 0.00 -0.02 -0.02 1.00     5050     3925\n capH[3,1]        0.00   0.00 0.00 0.00  0.00  0.01 1.00     4877     3408\n capH[4,1]       -0.02  -0.02 0.00 0.00 -0.02 -0.02 1.00     4981     3932\n capH[1,2]       -0.03  -0.03 0.00 0.00 -0.04 -0.03 1.00     3850     3894\n capH[2,2]       -0.04  -0.04 0.00 0.00 -0.05 -0.04 1.00     3629     3707\n capH[3,2]       -0.05  -0.05 0.00 0.00 -0.05 -0.05 1.00     3402     3568\n capH[4,2]       -0.01  -0.01 0.00 0.00 -0.02 -0.01 1.00     3709     3544\n comega[1,1]      0.12   0.12 0.01 0.01  0.10  0.13 1.01      862     1591\n comega[2,1]      0.13   0.13 0.01 0.01  0.12  0.15 1.00     1315     2135\n comega[3,1]      0.12   0.12 0.01 0.01  0.11  0.13 1.00     1157     2056\n comega[4,1]      0.10   0.10 0.01 0.01  0.09  0.11 1.00     1212     1998\n comega[1,2]      0.06   0.06 0.02 0.02  0.02  0.09 1.03      315      289\n comega[2,2]      0.15   0.15 0.02 0.02  0.12  0.18 1.00     2256     2851\n comega[3,2]      0.05   0.05 0.01 0.01  0.03  0.07 1.01      426      343\n comega[4,2]      0.02   0.02 0.01 0.01  0.00  0.04 1.00      760     1516\n comega[1,3]      0.14   0.14 0.01 0.01  0.13  0.16 1.01     1387     2315\n comega[2,3]      0.29   0.29 0.02 0.02  0.26  0.32 1.00      864     1617\n comega[3,3]      0.47   0.47 0.03 0.03  0.42  0.52 1.02      701     1289\n comega[4,3]      0.16   0.16 0.01 0.01  0.15  0.19 1.00     1393     1907\n ckappa[1,1]      0.07   0.07 0.01 0.01  0.06  0.08 1.00     1256     2247\n ckappa[2,1]      0.11   0.11 0.01 0.01  0.10  0.13 1.00     1718     2961\n ckappa[3,1]      0.08   0.08 0.01 0.01  0.07  0.09 1.01     1764     2733\n ckappa[4,1]      0.08   0.08 0.01 0.01  0.07  0.09 1.00     1491     2505\n ckappa[1,2]      0.07   0.07 0.03 0.04  0.02  0.13 1.01      417      852\n ckappa[2,2]      0.20   0.20 0.03 0.03  0.15  0.25 1.00     1664     2343\n ckappa[3,2]      0.11   0.11 0.03 0.03  0.06  0.15 1.01      862      830\n ckappa[4,2]      0.04   0.03 0.02 0.03  0.00  0.08 1.03      479     1426\n ckappa[1,3]      0.07   0.07 0.02 0.02  0.04  0.11 1.00      865     1522\n ckappa[2,3]      0.27   0.27 0.02 0.02  0.24  0.31 1.00     1741     2782\n ckappa[3,3]      0.72   0.72 0.04 0.04  0.65  0.78 1.01     1281     2450\n ckappa[4,3]      0.09   0.09 0.02 0.02  0.06  0.11 1.01      745      676\n comegaT[1]       0.00   0.00 0.00 0.00  0.00  0.00 1.00     1656     2300\n comegaT[2]       0.01   0.01 0.00 0.00  0.01  0.01 1.00     2194     2711\n comegaT[3]       0.00   0.00 0.00 0.00  0.00  0.00 1.01     1408     2289\n comegaT[4]       0.00   0.00 0.00 0.00  0.00  0.00 1.00     2595     2298\n crho[1,1]        1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n crho[2,1]        0.57   0.57 0.07 0.07  0.44  0.68 1.00     1083     1700\n crho[3,1]        0.78   0.78 0.04 0.04  0.71  0.84 1.01     1015     1731\n crho[4,1]        0.72   0.72 0.05 0.05  0.64  0.79 1.00     1300     2030\n crho[1,2]        0.57   0.57 0.07 0.07  0.44  0.68 1.00     1083     1700\n crho[2,2]        1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n crho[3,2]        0.55   0.55 0.07 0.07  0.42  0.67 1.00     1242     1933\n crho[4,2]        0.55   0.56 0.07 0.07  0.43  0.66 1.00     1383     2292\n crho[1,3]        0.78   0.78 0.04 0.04  0.71  0.84 1.01     1015     1731\n crho[2,3]        0.55   0.55 0.07 0.07  0.42  0.67 1.00     1242     1933\n crho[3,3]        1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n crho[4,3]        0.92   0.92 0.02 0.02  0.89  0.94 1.00     1324     2429\n crho[1,4]        0.72   0.72 0.05 0.05  0.64  0.79 1.00     1300     2030\n crho[2,4]        0.55   0.56 0.07 0.07  0.43  0.66 1.00     1383     2292\n crho[3,4]        0.92   0.92 0.02 0.02  0.89  0.94 1.00     1324     2429\n crho[4,4]        1.00   1.00 0.00 0.00  1.00  1.00   NA       NA       NA\n clogmsigma[1]    0.20   0.20 0.02 0.02  0.17  0.22 1.00     2901     3087\n clogmsigma[2]   -0.01  -0.01 0.02 0.02 -0.05  0.02 1.00     3536     3376\n clogmsigma[3]   -0.26  -0.26 0.02 0.02 -0.29 -0.22 1.00     3010     3356\n clogmsigma[4]   -0.10  -0.10 0.02 0.02 -0.13 -0.07 1.00     3325     3444\n cssigma[1]       0.07   0.07 0.03 0.03  0.02  0.11 1.01      574     1063\n cssigma[2]       0.17   0.17 0.02 0.02  0.14  0.20 1.00     1761     2633\n cssigma[3]       0.16   0.16 0.02 0.02  0.13  0.19 1.00     1919     2850\n cssigma[4]       0.08   0.08 0.03 0.02  0.03  0.12 1.01      560      769\n\n\nThe summary can also be extracted for individual parameters. Here presented for analyte 9 (Baclofen)\n\n\nCode\n# which(unique(data$METID)==9) - 3rd compound in stan\nfit$print(c(\"logkwx[3,1,1]\", \"logkwx[3,1,2]\", \"logkwx[3,1,3]\",\n            \"logkwx[3,2,1]\", \"logkwx[3,2,2]\", \"logkwx[3,2,3]\",\n                \"S1x[3,1,1,1]\", \"S1x[3,1,1,2]\", \"S1x[3,1,1,3]\",\n                \"S1x[3,2,1,1]\", \"S1x[3,2,1,2]\", \"S1x[3,2,1,3]\",\n                \"S1x[3,1,2,1]\", \"S1x[3,1,2,2]\", \"S1x[3,1,2,3]\", \n                \"S1x[3,2,2,1]\", \"S1x[3,2,2,2]\", \"S1x[3,2,2,3]\",\n                \"apHx[3,1,1]\", \"apHx[3,1,2]\", \"apHx[3,1,3]\",\n                \"pKawx[3,1]\", \"pKawx[3,2]\",\n                \"alphax[3,1,1]\", \"alphax[3,1,2]\",\n                \"alphax[3,2,1]\", \"alphax[3,2,2]\",\n                \"S2x[1,1]\", \"S2x[2,1]\",\n                \"sigmax[3,1]\", \"sigmax[3,2]\"), max_rows = 31)\n\n\n      variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n logkwx[3,1,1]  1.33   1.33 0.03 0.03  1.28  1.38 1.00     6062     3190\n logkwx[3,1,2]  0.68   0.68 0.07 0.07  0.58  0.79 1.00     5550     3342\n logkwx[3,1,3]  0.68   0.68 0.07 0.07  0.58  0.79 1.00     5550     3342\n logkwx[3,2,1]  1.64   1.64 0.04 0.04  1.58  1.70 1.00     6117     3234\n logkwx[3,2,2]  1.04   1.04 0.06 0.06  0.94  1.14 1.00     6694     3794\n logkwx[3,2,3]  1.04   1.04 0.06 0.06  0.94  1.14 1.00     6694     3794\n S1x[3,1,1,1]   3.78   3.79 0.31 0.31  3.28  4.28 1.00     5248     2966\n S1x[3,1,1,2]   4.74   4.72 0.71 0.71  3.59  5.95 1.00     6928     3011\n S1x[3,1,1,3]   4.74   4.72 0.71 0.71  3.59  5.95 1.00     6928     3011\n S1x[3,2,1,1]   3.35   3.35 0.26 0.27  2.92  3.78 1.00     5914     3292\n S1x[3,2,1,2]   5.74   5.74 0.63 0.63  4.73  6.78 1.00     6900     3283\n S1x[3,2,1,3]   5.74   5.74 0.63 0.63  4.73  6.78 1.00     6900     3283\n S1x[3,1,2,1]   4.53   4.53 0.31 0.32  4.02  5.03 1.00     5363     3001\n S1x[3,1,2,2]   5.48   5.46 0.72 0.71  4.30  6.69 1.00     7097     3287\n S1x[3,1,2,3]   5.48   5.46 0.72 0.71  4.30  6.69 1.00     7097     3287\n S1x[3,2,2,1]   4.20   4.20 0.27 0.28  3.76  4.62 1.00     5462     3331\n S1x[3,2,2,2]   6.62   6.62 0.64 0.64  5.58  7.68 1.00     6955     3383\n S1x[3,2,2,3]   6.62   6.62 0.64 0.64  5.58  7.68 1.00     6955     3383\n apHx[3,1,1]    0.00   0.00 0.00 0.00  0.00  0.00   NA       NA       NA\n apHx[3,1,2]   -0.03  -0.03 0.00 0.00 -0.03 -0.03 1.00     4583     3724\n apHx[3,1,3]   -0.03  -0.03 0.00 0.00 -0.03 -0.03 1.00     4583     3724\n pKawx[3,1]     6.74   6.74 0.08 0.08  6.61  6.86 1.00     8439     3301\n pKawx[3,2]     0.00   0.00 0.00 0.00  0.00  0.00   NA       NA       NA\n alphax[3,1,1]  2.14   2.14 0.90 0.90  0.67  3.64 1.00     8395     3357\n alphax[3,1,2]  0.00   0.00 0.00 0.00  0.00  0.00   NA       NA       NA\n alphax[3,2,1]  2.49   2.47 1.14 1.11  0.59  4.39 1.00     7846     3292\n alphax[3,2,2]  0.00   0.00 0.00 0.00  0.00  0.00   NA       NA       NA\n S2x[1,1]       0.49   0.49 0.02 0.02  0.47  0.52 1.02      432      986\n S2x[2,1]       1.30   1.30 0.03 0.03  1.26  1.34 1.02      355      754\n sigmax[3,1]    0.39   0.39 0.03 0.03  0.34  0.45 1.00     4626     3538\n sigmax[3,2]    0.45   0.45 0.04 0.04  0.38  0.52 1.00     2663     3556"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling"
  },
  {
    "objectID": "index.html#trace-plots",
    "href": "index.html#trace-plots",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Trace plots",
    "text": "Trace plots\nSeveral trace plots are shown.\n\n\nCode\nbayesplot::mcmc_trace(fit$draws(c(\"logkwHat\",\"S1mHat\",\"dS1Hat\",\"cdS1Hat\")))"
  },
  {
    "objectID": "index.html#summary-of-model-parameters-figures",
    "href": "index.html#summary-of-model-parameters-figures",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Summary of model parameters (figures)",
    "text": "Summary of model parameters (figures)\nFirst plot presents parameter specific for XBridge Shield RP18 column and parameters common for all the columns:\n\n\nCode\np1&lt;-bayesplot::mcmc_intervals(fit$draws(c(\"logkwHat\",\"S1mHat\",\"dS1Hat\",\"dlogkwHat\",\n                                  \"dlogkTHat\", \"dS1mHat\",\"ddS1Hat\",\"logS2mHat\",\"dlogS2Hat\",\"beta\",\n                                  \"apH\",\"alphamHat\",\"dalphaHat\")), point_size = 2)\n\np2&lt;-bayesplot::mcmc_intervals(fit$draws(c(\"omega\",\"omegaT\",\"kappa\",\"msigma\",\"ssigma\", \"tau\",\"rho[2,1]\")), point_size = 2)\n\nggsave(paste0(\"figures\\\\param\\\\\", \"Paramteres.XBridgeShieldRP18_1\", \".png\"), plot=p1, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\param\\\\\", \"Paramteres.XBridgeShieldRP18_2\", \".png\"), plot=p2, width = 20, height = 20, units = \"cm\")\n\nprint(p1)\n\n\n\n\n\nCode\nprint(p2)\n\n\n\n\n\nColumn effects relative to XBridge Shield RP18 column:\n\n\nCode\np1&lt;-bayesplot::mcmc_intervals(fit$draws(c(\"clogkwHat[1]\",\"cS1mHat[1]\",\"cdS1Hat[1]\",\n            \"cdlogkwHat[1,1]\", \"cdlogkwHat[1,2]\",\n            \"cdS1mHat[1,1]\",\"cdS1mHat[1,2]\", \n            \"cddS1Hat[1,1]\",\"cddS1Hat[1,2]\",\n            \"cbeta[1,1]\",\"cbeta[1,2]\",\n            \"cdlogkTHat[1]\",\n            \"capH[1,1]\", \"capH[1,2]\")), point_size = 2)+\n   theme(plot.title = element_text(size = 8))+\n  scale_y_discrete(labels = c(\"clogkwHat[1]\"=\"clogkwHat[c]\",\n                              \"cS1mHat[1]\"=\"cS1mHat[c]\",\n                              \"cdS1Hat[1]\"=\"cdS1Hat[c]\",\n                              \"cdlogkwHat[1,1]\"=\"cdlogkwHat[c,1]\", \n                              \"cdlogkwHat[1,2]\"=\"cdlogkwHat[c,2]\",\n                              \"cdS1mHat[1,1]\"= \"cdS1mHat[c,1]\",\n                              \"cdS1mHat[1,2]\"=\"cdS1mHat[c,2]\", \n                              \"cddS1Hat[1,1]\"=\"cddS1Hat[c,1]\",\n                              \"cddS1Hat[1,2]\"=\"cddS1Hat[c,2]\",\n                              \"cbeta[1,1]\"=\"cbeta[c,1]\",\n                              \"cbeta[1,2]\"=\"cbeta[x,2]\",\n                              \"cdlogkTHat[1]\"=\"cdlogkTHat[c]\",\n                              \"capH[1,1]\"=\"capH[c,1]\", \n                              \"capH[1,2]\"=\"capH[c,2]\"),\n                   limits = c(\"capH[1,2]\",\n                               \"capH[1,1]\",\n                               \"cdlogkTHat[1]\",                    \n                               \"cbeta[1,2]\",\n                               \"cbeta[1,1]\",\n                               \"cddS1Hat[1,2]\",\n                               \"cddS1Hat[1,1]\",\n                               \"cdS1mHat[1,2]\",\n                               \"cdS1mHat[1,1]\",\n                               \"cdlogkwHat[1,2]\",\n                               \"cdlogkwHat[1,1]\", \n                               \"cdS1Hat[1]\",\n                               \"cS1mHat[1]\",                              \n                               \"clogkwHat[1]\"))+\n  xlim(-0.5,1)\n\np2&lt;-bayesplot::mcmc_intervals(fit$draws(c(\"clogkwHat[2]\",\"cS1mHat[2]\",\"cdS1Hat[2]\",\n            \"cdlogkwHat[2,1]\", \"cdlogkwHat[2,2]\",\n            \"cdS1mHat[2,1]\",\"cdS1mHat[2,2]\", \n            \"cddS1Hat[2,1]\",\"cddS1Hat[2,2]\",\n            \"cbeta[2,1]\",\"cbeta[2,2]\",\n            \"cdlogkTHat[2]\",\n            \"capH[2,1]\", \"capH[2,2]\")), point_size = 2)+\n  theme(axis.text.y=element_blank(),plot.title = element_text(size = 8))+\n  xlim(-0.5,1)\n\np3&lt;-bayesplot::mcmc_intervals(fit$draws(c(\"clogkwHat[3]\",\"cS1mHat[3]\",\"cdS1Hat[3]\",\n            \"cdlogkwHat[3,1]\", \"cdlogkwHat[3,2]\",\n            \"cdS1mHat[3,1]\",\"cdS1mHat[3,2]\", \n            \"cddS1Hat[3,1]\",\"cddS1Hat[3,2]\",\n            \"cbeta[3,1]\",\"cbeta[3,2]\",\n            \"cdlogkTHat[3]\",\n            \"capH[3,1]\", \"capH[3,2]\")), point_size = 2)+\n  theme(axis.text.y=element_blank(),plot.title = element_text(size = 8))+\n  xlim(-0.5,1)\n\np4&lt;-bayesplot::mcmc_intervals(fit$draws(c(\"clogkwHat[4]\",\"cS1mHat[4]\",\"cdS1Hat[4]\",\n            \"cdlogkwHat[4,1]\", \"cdlogkwHat[4,2]\",\n            \"cdS1mHat[4,1]\",\"cdS1mHat[4,2]\", \n            \"cddS1Hat[4,1]\",\"cddS1Hat[4,2]\",\n            \"cbeta[4,1]\",\"cbeta[4,2]\",\n            \"cdlogkTHat[4]\",\n            \"capH[4,1]\", \"capH[4,2]\")), point_size = 2)+\n  theme(axis.text.y=element_blank(),plot.title = element_text(size = 8))+\n  xlim(-0.5,1)\n\np=grid.arrange(p1+ggtitle(\"XTerra MS C18\"), \n               p2+ggtitle(\"XBridge Phenyl\"),\n               p3+ggtitle(\"XBridge C8\"),\n               p4+ggtitle(\"Xterra MS C8\"), ncol=4, widths=c(1.75,1,1,1))\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\param\\\\\", \"Difference_1\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n\n\n\n\nCode\np1&lt;-bayesplot::mcmc_intervals(fit$draws(c(\"comega[1,1]\",\n                                          \"comega[1,2]\",\n                                          \"comega[1,3]\",\n                                          \"comegaT[1]\",\n                                          \"ckappa[1,1]\",\n                                          \"ckappa[1,2]\",\n                                          \"ckappa[1,3]\")), point_size = 2) + \n  theme(plot.title = element_text(size = 8))+\n  scale_y_discrete(labels = c(\"comega[1,1]\"=\"comega[c,1]\",\n                             \"comega[1,2]\"=\"comega[c,2]\",\n                             \"comega[1,3]\"=\"comega[c,3]\",\n                             \"comegaT[1]\" = \"comegaT[c]\",\n                             \"ckappa[1,1]\"=\"ckappa[c,1]\",\n                             \"ckappa[1,2]\"=\"ckappa[c,2]\",\n                             \"ckappa[1,3]\"=\"ckappa[c,3]\"),\n                   limits = c(\"ckappa[1,3]\",\n                              \"ckappa[1,2]\",\n                              \"ckappa[1,1]\",\n                              \"comegaT[1]\",\n                              \"comega[1,3]\",                                          \n                              \"comega[1,2]\",\n                              \"comega[1,1]\"))+\n  xlim(0,0.8)\n\np2&lt;-bayesplot::mcmc_intervals(fit$draws(c(\"comega[2,1]\",\n                                          \"comega[2,2]\",\n                                          \"comega[2,3]\",\n                                          \"comegaT[2]\",\n                                          \"ckappa[2,1]\",\n                                          \"ckappa[2,2]\",\n                                          \"ckappa[2,3]\")), point_size = 2)+\n  theme(axis.text.y=element_blank(),plot.title = element_text(size = 8))+\n  xlim(0,0.8)\n\np3&lt;-bayesplot::mcmc_intervals(fit$draws(c(\"comega[3,1]\",\n                                          \"comega[3,2]\",\n                                          \"comega[3,3]\",\n                                          \"comegaT[3]\",\n                                          \"ckappa[3,1]\",\n                                          \"ckappa[3,2]\",\n                                          \"ckappa[3,3]\")), point_size = 2)+\n  theme(axis.text.y=element_blank(),plot.title = element_text(size = 8))+\n  xlim(0,0.8)\n\np4&lt;-bayesplot::mcmc_intervals(fit$draws(c(\"comega[4,1]\",\n                                          \"comega[4,2]\",\n                                          \"comega[4,3]\",\n                                          \"comegaT[4]\",\n                                          \"ckappa[4,1]\",\n                                          \"ckappa[4,2]\",\n                                          \"ckappa[4,3]\")), point_size = 2)+\n  theme(axis.text.y=element_blank(),plot.title = element_text(size = 8))+\n  xlim(0,0.8)\n\np=grid.arrange(p1+ggtitle(\"XTerra MS C18\"), \n               p2+ggtitle(\"XBridge Phenyl\"),\n               p3+ggtitle(\"XBridge C8\"),\n               p4+ggtitle(\"Xterra MS C8\"), ncol=4, widths=c(1.75,1,1,1))\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\param\\\\\", \"Difference_2\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n\n\nParameters characterizing columns:\n\n\nCode\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\"clogkwHat\",\"cdlogkwHat\"))\n\nNeutral_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(clogkwHat[c]) %&gt;%\n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(logkwHat = clogkwHat) %&gt;%\n  mutate(Type = \"N\")\n\nAcids_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(clogkwHat[c],cdlogkwHat[c,r]) %&gt;%\n  filter(r==1) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(xlogkwHat=clogkwHat+cdlogkwHat)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(logkwHat = xlogkwHat) %&gt;%\n  mutate(Type = \"A\")\n\nBasic_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(clogkwHat[c],cdlogkwHat[c,r]) %&gt;%\n  filter(r==2)%&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(xlogkwHat=clogkwHat+cdlogkwHat)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(logkwHat = xlogkwHat) %&gt;%\n  mutate(Type = \"B\")\n\n\np1&lt;-bind_rows(Neutral_results, Acids_results, Basic_results) %&gt;%\n  ggplot(aes(y = ColumnNames, x = logkwHat, xmin = .lower, xmax = .upper,color = Type)) +\n   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  \n  scale_color_manual(labels = c(\"A\", \"B\", \"N\"), values = c(\"#F8766D\", \"#619CFF\", \"black\"))+ \n   ylab(' ') +\n   xlab(\"Typical clogkw\")\n\n\nprint(p1)\n\n\n\n\n\n\n\nCode\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\"S1mHat\",\"cS1mHat\",\"dS1mHat\",\"cdS1mHat\",\n                                                         \"dS1Hat\",\"cdS1Hat\",\"ddS1Hat\",\"cddS1Hat\"))\n\nMeOH_Neutral_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(S1mHat,cS1mHat[c]) %&gt;%\n  mutate(xS1mHat=cS1mHat)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(S1Hat = xS1mHat) %&gt;%\n  mutate(Type = \"N\")%&gt;% \n  mutate(Modifier=\"MeOH\")\n\nMeOH_Acids_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(cS1mHat[c],cdS1mHat[c,r]) %&gt;%\n  filter(r==1) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(xS1mHat=cS1mHat+cdS1mHat)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(S1Hat = xS1mHat) %&gt;%\n  mutate(Type = \"A\")%&gt;% \n  mutate(Modifier=\"MeOH\")\n\nMeOH_Basic_results  &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(cS1mHat[c],cdS1mHat[c,r]) %&gt;%\n  filter(r==2) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(xS1mHat=cS1mHat+cdS1mHat)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(S1Hat = xS1mHat) %&gt;%\n  mutate(Type = \"B\")%&gt;% \n  mutate(Modifier=\"MeOH\")\n\n\nACN_Neutral_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(cS1mHat[c],cdS1Hat[c]) %&gt;%\n  mutate(xS1aHat=cS1mHat+cdS1Hat)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(S1Hat = xS1aHat) %&gt;%\n  mutate(Type = \"N\")%&gt;% \n  mutate(Modifier=\"ACN\")\n\nACN_Acids_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(cS1mHat[c],cdS1Hat[c],cdS1mHat[c,r],cddS1Hat[c,r]) %&gt;%\n  filter(r==1) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(xS1aHat= cS1mHat +cdS1mHat +cdS1Hat + cddS1Hat)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(S1Hat = xS1aHat) %&gt;%\n  mutate(Type = \"A\")%&gt;% \n  mutate(Modifier=\"ACN\")\n\nACN_Basic_results  &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(cS1mHat[c],cdS1Hat[c],cdS1mHat[c,r],cddS1Hat[c,r]) %&gt;%\n  filter(r==2) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(xS1aHat= cS1mHat+cdS1mHat+cdS1Hat + cddS1Hat)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;%  \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(S1Hat = xS1aHat) %&gt;%\n  mutate(Type = \"B\")%&gt;% \n  mutate(Modifier=\"ACN\")\n\n\np2&lt;-bind_rows(MeOH_Neutral_results, MeOH_Acids_results, MeOH_Basic_results,\n             ACN_Neutral_results,ACN_Acids_results, ACN_Basic_results) %&gt;%\n  ggplot(aes(y = ColumnNames, x = S1Hat, xmin = .lower, xmax = .upper,color = Type)) +\n   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  \n  scale_color_manual(labels = c(\"A\", \"B\", \"N\"), values = c(\"#F8766D\", \"#619CFF\", \"black\"))+ \n  ylab(' ')+\n  xlab(\"Typical cS1\")+\n  facet_wrap(.~Modifier)\n\nprint(p2)\n\n\n\n\n\n\n\nCode\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\"beta\",\"cbeta\"))\n\nlogkw_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n = 1000) %&gt;%\n  tidybayes::spread_draws(cbeta[c,r]) %&gt;%\n  filter(r==1) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(xbeta=cbeta)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(beta = xbeta)%&gt;% \n  mutate(Parameter=\"logkw\")\n\nS1_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n = 1000) %&gt;%\n  tidybayes::spread_draws(cbeta[c,r]) %&gt;%\n  filter(r==2) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(xbeta=cbeta)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(beta = xbeta)%&gt;% \n  mutate(Parameter=\"S1\")\n\n\np3&lt;-bind_rows(logkw_results, S1_results) %&gt;%\n  ggplot(aes(y = ColumnNames, x = beta, xmin = .lower, xmax = .upper,color = Parameter)) +\n   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) + \n  scale_color_manual(labels = c(\"clogkw\", \"cS1\"), values = c(\"black\", \"gray\"))+\n  ylab(' ')+\n  xlab(\"log P effect (c\\u03b2)\")\n\nprint(p3)\n\n\n\n\n\n\n\nCode\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\"apH\",\"capH\"))\n\nAcids_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n = 1000) %&gt;%\n  tidybayes::spread_draws(capH[c,r]) %&gt;%\n  filter(r==1) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(xapH=capH)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(apH = xapH)%&gt;% \n  mutate(Type=\"A\")\n\nBases_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n = 1000) %&gt;%\n  tidybayes::spread_draws(capH[c,r]) %&gt;%\n  filter(r==2) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(xapH=capH)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(apH = xapH)%&gt;% \n  mutate(Type=\"B\")\n\n\np4&lt;-bind_rows(Acids_results, Bases_results) %&gt;%\n  ggplot(aes(y = ColumnNames, x = apH, xmin = .lower, xmax = .upper,color = Type)) +\n   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  \n  scale_color_manual(labels = c(\"A\", \"B\"), values = c(\"#F8766D\", \"#619CFF\"))+\n  ylab(' ')+\n   xlab(\"pH effects (capH)\")\n\nprint(p4)\n\n\n\n\n\n\n\nCode\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\"dlogkTHat\",\"cdlogkTHat\"))\n\nResults &lt;-draws_df_subset %&gt;%\n  slice_sample(n = 1000) %&gt;%\n  tidybayes::spread_draws(cdlogkTHat[c]) %&gt;%\n  ungroup() %&gt;%\n  mutate(xdlogkTHat=cdlogkTHat)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(dlogkTHat = xdlogkTHat)%&gt;% \n  mutate(Parameter=\"clogkw\")\n\np5&lt;-Results %&gt;%\n  ggplot(aes(y = ColumnNames, x = dlogkTHat, xmin = .lower, xmax = .upper,color = Parameter)) +\n   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) + \n  scale_color_manual(labels = c(\"clogkw\"), values = c(\"black\"))+\n  ylab(' ')+\n  xlab(\"Temp. effects (cdlogkT)\")\n\nprint(p5)\n\n\n\n\n\n\n\nCode\np=grid.arrange(p1+ theme(legend.position='none'), \n               p3+theme(axis.text.y=element_blank()), \n               p4+ theme(legend.position='none'),\n               p5+theme(axis.text.y=element_blank()), \n               p2, ncol=2, widths = c(1,1), layout_matrix = rbind(c(1, 2),c(3, 4), c(5, 5)))\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\param\\\\\", \"Joined_Effects\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n\n\nParameters characterizing columns:\n\n\nCode\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\"logkwHat\",\"clogkwHat\",\"dlogkwHat\",\"cdlogkwHat\"))\n\nNeutral_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(logkwHat,clogkwHat[c]) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(clogkwHat=logkwHat+clogkwHat)%&gt;%\n  select(.draw,logkwHat,clogkwHat,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = clogkwHat) %&gt;%\n  rename(`1`=logkwHat) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xlogkwHat\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(logkwHat = xlogkwHat) %&gt;%\n  mutate(Type = \"N\")\n\nAcids_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(logkwHat,clogkwHat[c],dlogkwHat[r],cdlogkwHat[c,r]) %&gt;%\n  filter(r==1) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(clogkwHat=logkwHat+clogkwHat+dlogkwHat+cdlogkwHat)%&gt;%\n  mutate(logkwHat=logkwHat+dlogkwHat)%&gt;%\n  select(.draw,logkwHat,clogkwHat,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = clogkwHat) %&gt;%\n  rename(`1`=logkwHat) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xlogkwHat\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(logkwHat = xlogkwHat) %&gt;%\n  mutate(Type = \"A\")\n\nBasic_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(logkwHat,clogkwHat[c],dlogkwHat[r],cdlogkwHat[c,r]) %&gt;%\n  filter(r==2)%&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(clogkwHat=logkwHat+clogkwHat+dlogkwHat+cdlogkwHat)%&gt;%\n  mutate(logkwHat=logkwHat+dlogkwHat)%&gt;%\n  select(.draw,logkwHat,clogkwHat,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = clogkwHat) %&gt;%\n  rename(`1`=logkwHat) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xlogkwHat\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(logkwHat = xlogkwHat) %&gt;%\n  mutate(Type = \"B\")\n\n\np1&lt;-bind_rows(Neutral_results, Acids_results, Basic_results) %&gt;%\n  ggplot(aes(y = ColumnNames, x = logkwHat, xmin = .lower, xmax = .upper,color = Type)) +\n   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  \n  scale_color_manual(labels = c(\"A\", \"B\", \"N\"), values = c(\"#F8766D\", \"#619CFF\", \"black\"))+ \n   ylab(' ') +\n   xlab(\"Typical logkw\")\n\n\nprint(p1)\n\n\n\n\n\n\n\nCode\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\"S1mHat\",\"cS1mHat\",\"dS1mHat\",\"cdS1mHat\",\n                                                         \"dS1Hat\",\"cdS1Hat\",\"ddS1Hat\",\"cddS1Hat\"))\n\nMeOH_Neutral_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(S1mHat,cS1mHat[c]) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(cS1mHat=S1mHat+cS1mHat)%&gt;%\n  select(.draw,S1mHat,cS1mHat,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = cS1mHat) %&gt;%\n  rename(`1`=S1mHat) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xS1mHat\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(S1Hat = xS1mHat) %&gt;%\n  mutate(Type = \"N\")%&gt;% \n  mutate(Modifier=\"MeOH\")\n\nMeOH_Acids_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(S1mHat,cS1mHat[c],dS1mHat[r],cdS1mHat[c,r]) %&gt;%\n  filter(r==1) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(cS1mHat=S1mHat+cS1mHat+dS1mHat+cdS1mHat)%&gt;%\n  mutate(S1mHat=S1mHat+dS1mHat)%&gt;%\n  select(.draw,S1mHat,cS1mHat,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = cS1mHat) %&gt;%\n  rename(`1`=S1mHat) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xS1mHat\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(S1Hat = xS1mHat) %&gt;%\n  mutate(Type = \"A\")%&gt;% \n  mutate(Modifier=\"MeOH\")\n\nMeOH_Basic_results  &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(S1mHat,cS1mHat[c],dS1mHat[r],cdS1mHat[c,r]) %&gt;%\n  filter(r==2) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(cS1mHat=S1mHat+cS1mHat+dS1mHat+cdS1mHat)%&gt;%\n  mutate(S1mHat=S1mHat+dS1mHat)%&gt;%\n  select(.draw,S1mHat,cS1mHat,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = cS1mHat) %&gt;%\n  rename(`1`=S1mHat) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xS1mHat\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(S1Hat = xS1mHat) %&gt;%\n  mutate(Type = \"B\")%&gt;% \n  mutate(Modifier=\"MeOH\")\n\n\nACN_Neutral_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(S1mHat,cS1mHat[c],dS1Hat,cdS1Hat[c]) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(cS1aHat=S1mHat+cS1mHat+dS1Hat+cdS1Hat)%&gt;%\n  mutate(S1aHat =S1mHat+dS1Hat)%&gt;%\n  select(.draw,S1aHat,cS1aHat,c)%&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = cS1aHat) %&gt;%\n  rename(`1`=S1aHat) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xS1aHat\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(S1Hat = xS1aHat) %&gt;%\n  mutate(Type = \"N\")%&gt;% \n  mutate(Modifier=\"ACN\")\n\nACN_Acids_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(S1mHat,cS1mHat[c],dS1Hat,cdS1Hat[c],dS1mHat[r],cdS1mHat[c,r],ddS1Hat[r],cddS1Hat[c,r]) %&gt;%\n  filter(r==1) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(cS1aHat= S1mHat+cS1mHat + dS1mHat+cdS1mHat + dS1Hat+cdS1Hat + ddS1Hat+ cddS1Hat)%&gt;%\n  mutate(S1aHat = S1mHat+dS1mHat+dS1Hat+ddS1Hat)%&gt;%\n  select(.draw,S1aHat,cS1aHat,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = cS1aHat) %&gt;%\n  rename(`1`=S1aHat) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xS1aHat\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(S1Hat = xS1aHat) %&gt;%\n  mutate(Type = \"A\")%&gt;% \n  mutate(Modifier=\"ACN\")\n\nACN_Basic_results  &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(S1mHat,cS1mHat[c],dS1Hat,cdS1Hat[c],dS1mHat[r],cdS1mHat[c,r],ddS1Hat[r],cddS1Hat[c,r]) %&gt;%\n  filter(r==2) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(cS1aHat= S1mHat+cS1mHat + dS1mHat+cdS1mHat + dS1Hat+cdS1Hat + ddS1Hat+cddS1Hat)%&gt;%\n  mutate(S1aHat = S1mHat+dS1mHat+dS1Hat+ddS1Hat)%&gt;%\n  select(.draw,S1aHat,cS1aHat,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = cS1aHat) %&gt;%\n  rename(`1`=S1aHat) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xS1aHat\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(S1Hat = xS1aHat) %&gt;%\n  mutate(Type = \"B\")%&gt;% \n  mutate(Modifier=\"ACN\")\n\n\np2&lt;-bind_rows(MeOH_Neutral_results, MeOH_Acids_results, MeOH_Basic_results,\n             ACN_Neutral_results,ACN_Acids_results, ACN_Basic_results) %&gt;%\n  ggplot(aes(y = ColumnNames, x = S1Hat, xmin = .lower, xmax = .upper,color = Type)) +\n   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  \n  scale_color_manual(labels = c(\"A\", \"B\", \"N\"), values = c(\"#F8766D\", \"#619CFF\", \"black\"))+ \n  ylab(' ')+\n  xlab(\"Typical S1\")+\n  facet_wrap(.~Modifier)\n\nprint(p2)\n\n\n\n\n\n\n\nCode\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\"beta\",\"cbeta\"))\n\nlogkw_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n = 1000) %&gt;%\n  tidybayes::spread_draws(beta[r],cbeta[c,r]) %&gt;%\n  filter(r==1) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(cbeta=beta+cbeta)%&gt;%\n  select(.draw,beta,cbeta,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = cbeta) %&gt;%\n  rename(`1`=beta) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xbeta\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(beta = xbeta)%&gt;% \n  mutate(Parameter=\"logkw\")\n\nS1_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n = 1000) %&gt;%\n  tidybayes::spread_draws(beta[r],cbeta[c,r]) %&gt;%\n  filter(r==2) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(cbeta=beta+cbeta)%&gt;%\n  select(.draw,beta,cbeta,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = cbeta) %&gt;%\n  rename(`1`=beta) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xbeta\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(beta = xbeta)%&gt;% \n  mutate(Parameter=\"S1\")\n\n\np3&lt;-bind_rows(logkw_results, S1_results) %&gt;%\n  ggplot(aes(y = ColumnNames, x = beta, xmin = .lower, xmax = .upper,color = Parameter)) +\n   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) + \n  scale_color_manual(labels = c(\"logkw\", \"S1\"), values = c(\"black\", \"gray\"))+\n  ylab(' ')+\n  xlab(\"logP effects (\\u03b2)\")\n\nprint(p3)\n\n\n\n\n\n\n\nCode\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\"apH\",\"capH\"))\n\nAcids_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n = 1000) %&gt;%\n  tidybayes::spread_draws(apH[r], capH[c,r]) %&gt;%\n  filter(r==1) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(capH=apH+capH)%&gt;%\n  select(.draw,apH,capH,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = capH) %&gt;%\n  rename(`1`= apH) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xapH\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(apH = xapH)%&gt;% \n  mutate(Type=\"A\")\n\nBases_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n = 1000) %&gt;%\n  tidybayes::spread_draws(apH[r], capH[c,r]) %&gt;%\n  filter(r==2) %&gt;%\n  ungroup() %&gt;%\n  select(-r) %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(capH=apH+capH)%&gt;%\n  select(.draw,apH,capH,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = capH) %&gt;%\n  rename(`1`= apH) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xapH\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(apH = xapH)%&gt;% \n  mutate(Type=\"B\")\n\n\np4&lt;-bind_rows(Acids_results, Bases_results) %&gt;%\n  ggplot(aes(y = ColumnNames, x = apH, xmin = .lower, xmax = .upper,color = Type)) +\n   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) +  \n  scale_color_manual(labels = c(\"A\", \"B\"), values = c(\"#F8766D\", \"#619CFF\"))+\n  ylab(' ')+\n   xlab(\"pH effects (apH)\")\n\nprint(p4)\n\n\n\n\n\n\n\nCode\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\"dlogkTHat\",\"cdlogkTHat\"))\n\nResults &lt;-draws_df_subset %&gt;%\n  slice_sample(n = 1000) %&gt;%\n  tidybayes::spread_draws(dlogkTHat, cdlogkTHat[c]) %&gt;%\n  ungroup() %&gt;%\n  mutate(c=c+1)%&gt;%\n  mutate(cdlogkTHat=dlogkTHat+cdlogkTHat)%&gt;%\n  select(.draw,dlogkTHat,cdlogkTHat,c) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = cdlogkTHat) %&gt;%\n  rename(`1`= dlogkTHat) %&gt;%\n  select(-.draw)%&gt;%\n  tidyr::pivot_longer(c(1:5),names_to = \"ColumnNames\", values_to = \"xdlogkTHat\") %&gt;% \n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(ColumnNames,\n                                '1' = 'XBridge Shield RP18',\n                                '2' = 'XTerra MS C18',\n                                '3' = 'XBridge Phenyl',\n                                '4' = 'XBridge C8',\n                                '5' = 'Xterra MS C8'))%&gt;% \n  group_by(ColumnNames)%&gt;%\n  tidybayes::median_qi(dlogkTHat = xdlogkTHat)%&gt;% \n  mutate(Parameter=\"logkw\")\n\np5&lt;-Results %&gt;%\n  ggplot(aes(y = ColumnNames, x = dlogkTHat, xmin = .lower, xmax = .upper,color = Parameter)) +\n   tidybayes::geom_pointinterval(position = position_dodge(width = .3)) + \n  scale_color_manual(labels = c(\"logkw\"), values = c(\"black\"))+\n  ylab(' ')+\n  xlab(\"Temp. effects (dlogkT)\")\n\nprint(p5)\n\n\n\n\n\n\n\nCode\np=grid.arrange(p1+ theme(legend.position='none'), \n               p3+theme(axis.text.y=element_blank()), \n               p4+ theme(legend.position='none'),\n               p5+theme(axis.text.y=element_blank()), \n               p2, ncol=2, widths = c(1,1), layout_matrix = rbind(c(1, 2),c(3, 4), c(5, 5)))\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\param\\\\\", \"Joined\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n\n\nStandard deviations:\n\n\nCode\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\"comega\",\"ckappa\"))\n\ncomega_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n = 1000) %&gt;%\n  tidybayes::spread_draws(comega[c,r]) %&gt;%\n  ungroup() %&gt;%\n  mutate(xparam=comega)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n    mutate(ParamNames=recode(r,\n                                '1' = 'clogkw',\n                                '2' = 'cS1m',\n                                '3' = 'cdS1'))%&gt;% \n  group_by(ColumnNames,ParamNames)%&gt;%\n  tidybayes::median_qi(param = xparam)%&gt;% \n  mutate(Parameter=\"comega\")\n\n\nckappa_results &lt;-draws_df_subset %&gt;%\n  slice_sample(n = 1000) %&gt;%\n  tidybayes::spread_draws(ckappa[c,r]) %&gt;%\n  ungroup() %&gt;%\n  mutate(xparam=ckappa)%&gt;%\n  mutate_if(is.character,as.factor) %&gt;% \n  mutate(ColumnNames=recode(c,\n                                '1' = 'XTerra MS C18',\n                                '2' = 'XBridge Phenyl',\n                                '3' = 'XBridge C8',\n                                '4' = 'Xterra MS C8'))%&gt;% \n    mutate(ParamNames=recode(r,\n                                '1' = 'clogkw',\n                                '2' = 'cS1m',\n                                '3' = 'cdS1'))%&gt;% \n  group_by(ColumnNames,ParamNames)%&gt;%\n  tidybayes::median_qi(param = xparam)%&gt;% \n  mutate(Parameter=\"ckappa\")\n\n\np1&lt;-bind_rows(comega_results, ckappa_results) %&gt;%\n  mutate(ParamNames=factor(ParamNames,levels=c(\"clogkw\",\"cS1m\",\"cdS1\")))%&gt;%\n  ggplot(aes(y = ColumnNames, x = param, xmin = .lower, xmax = .upper, color=ParamNames)) +\n  tidybayes::geom_pointinterval(position = position_dodge(width = .3)) + \n  scale_colour_manual(name = \" \", values=c(\"clogkw\" = \"#F8766D\",\"cS1m\" = \"#619CFF\",\"cdS1\" = \"#00BA38\")) +\n  facet_wrap(.~factor(Parameter,levels=c(\"comega\",\"ckappa\"),labels=c(expression(paste(\"c\",omega)),expression(paste(\"c\",kappa)))),labeller = label_parsed)+\n  ylab(' ')+\n  xlab(\"standard deviations\")\n\nprint(p1)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\param\\\\\", \"Joined_SD\", \".png\"), plot=p1, width = 20, height = 10, units = \"cm\")"
  },
  {
    "objectID": "index.html#isocratic-predictions",
    "href": "index.html#isocratic-predictions",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Isocratic predictions",
    "text": "Isocratic predictions\nTo better asses the impact of parameters on retention we created graphs presenting the isocratic logarithm of retention factor vs. \\(\\varphi\\) for selected analytes. Separate graphs are shown for each dissociation form (r=1,r=2,r=3). Here the individual predictions (given all the data) are shown:\n\n\nCode\nanalyte_ID_sample &lt;-c(9,17,33,58,140,180)\n\nfor(i in 1:length(analyte_ID_sample)){\n\nidx_analyte = which(unique(data$METID)==analyte_ID_sample[i])\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\n                sprintf(\"logkwx[%s,1,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,1,2]\",idx_analyte), \n                sprintf(\"logkwx[%s,1,3]\",idx_analyte),\n                sprintf(\"logkwx[%s,2,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,2,2]\",idx_analyte),\n                sprintf(\"logkwx[%s,2,3]\",idx_analyte),\n                sprintf(\"logkwx[%s,3,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,3,2]\",idx_analyte),\n                sprintf(\"logkwx[%s,3,3]\",idx_analyte),\n                sprintf(\"logkwx[%s,4,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,4,2]\",idx_analyte),\n                sprintf(\"logkwx[%s,4,3]\",idx_analyte),\n                sprintf(\"logkwx[%s,5,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,5,2]\",idx_analyte),\n                sprintf(\"logkwx[%s,5,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,1,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,1,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,1,3]\",idx_analyte),\n                sprintf(\"S1x[%s,2,1,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,1,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,1,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,2,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,2,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,2,3]\",idx_analyte), \n                sprintf(\"S1x[%s,2,2,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,2,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,2,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,3,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,3,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,3,3]\",idx_analyte), \n                sprintf(\"S1x[%s,2,3,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,3,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,3,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,4,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,4,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,4,3]\",idx_analyte), \n                sprintf(\"S1x[%s,2,4,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,4,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,4,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,5,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,5,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,5,3]\",idx_analyte), \n                sprintf(\"S1x[%s,2,5,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,5,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,5,3]\",idx_analyte),\n                \"S2x[1,1]\", \n                \"S2x[2,1]\"))\n\np &lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(logkwx[, c, r], S1x[, m, c, r], S2x[m, ]) %&gt;%\n  filter(r&lt;=R[idx_analyte]+1)  %&gt;% \n  tidyr::expand_grid(fi = seq(0,1,0.1)) %&gt;%\n  mutate(logk = logkwx-S1x*(1+S2x)*fi/(1+S2x*fi)) %&gt;%\n  ggplot(aes(x = fi, y = logk, color = as.factor(c), fill = as.factor(c))) +\n  ggdist::stat_lineribbon(.width = c(.90), alpha = 1/2) +\n  facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))+\n  labs(title=paste(dataNames$Name[analyte_ID_sample[i]]),color= \" \",fill= \" \", x=\"\\u03C6\", y=\"logk (individual)\")+\n  scale_fill_discrete(labels= c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\")) +\n  scale_color_discrete(labels= c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\"))+\n  geom_hline(yintercept= c(0,1), linetype=\"dashed\",color=\"gray\")  + \n  coord_cartesian(xlim=c(0,1),ylim=c(-1,2))\n\nprint(p)\n\nggsave(paste0(\"figures\\\\izoparam\\\\\", paste(dataNames$Name[analyte_ID_sample[i]]), \".IsocraticPredictions\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# AGG as the graphic backend of RStudio. (Tools -&gt; Global Options -&gt; General -&gt; Graphics)\n# https://github.com/tidyverse/ggplot2/issues/4661\n# otherwise coord_cartesian does not work\n\n\nSimilarly we can quantify the column effects (between column differences in logk using XBridge Shield RP18 as a reference column):\n\n\nCode\nanalyte_ID_sample &lt;-c(9,17,33,58,140,180)\n\n\nfor(i in 1:length(analyte_ID_sample)){\n\nidx_analyte = which(unique(data$METID)==analyte_ID_sample[i])\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\n                sprintf(\"logkwx[%s,1,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,1,2]\",idx_analyte), \n                sprintf(\"logkwx[%s,1,3]\",idx_analyte),\n                sprintf(\"logkwx[%s,2,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,2,2]\",idx_analyte),\n                sprintf(\"logkwx[%s,2,3]\",idx_analyte),\n                sprintf(\"logkwx[%s,3,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,3,2]\",idx_analyte),\n                sprintf(\"logkwx[%s,3,3]\",idx_analyte),\n                sprintf(\"logkwx[%s,4,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,4,2]\",idx_analyte),\n                sprintf(\"logkwx[%s,4,3]\",idx_analyte),\n                sprintf(\"logkwx[%s,5,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,5,2]\",idx_analyte),\n                sprintf(\"logkwx[%s,5,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,1,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,1,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,1,3]\",idx_analyte),\n                sprintf(\"S1x[%s,2,1,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,1,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,1,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,2,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,2,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,2,3]\",idx_analyte), \n                sprintf(\"S1x[%s,2,2,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,2,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,2,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,3,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,3,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,3,3]\",idx_analyte), \n                sprintf(\"S1x[%s,2,3,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,3,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,3,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,4,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,4,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,4,3]\",idx_analyte), \n                sprintf(\"S1x[%s,2,4,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,4,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,4,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,5,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,5,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,5,3]\",idx_analyte), \n                sprintf(\"S1x[%s,2,5,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,5,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,5,3]\",idx_analyte),\n                \"S2x[1,1]\", \n                \"S2x[2,1]\"))\n\np&lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(logkwx[, c, r], S1x[, m, c, r], S2x[m, ]) %&gt;%\n  filter(r&lt;=R[idx_analyte]+1) %&gt;% \n  tidyr::expand_grid(fi = seq(0,1,0.05)) %&gt;%\n  mutate(k = (logkwx-S1x*(1+S2x)*fi/(1+S2x*fi))) %&gt;%\n  select(.draw,c,r,m,k,fi) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = k) %&gt;%\n  mutate(cdk2 = `2`-`1` ) %&gt;%\n  mutate(cdk3 = `3`-`1` ) %&gt;%\n  mutate(cdk4 = `4`-`1` ) %&gt;%\n  mutate(cdk5 = `5`-`1` ) %&gt;%\n  tidyr::pivot_longer(cdk2:cdk5,names_to = \"names_cdk\", values_to = \"cdk\")%&gt;%\n   ggplot(aes(x = fi, y = cdk, color = as.factor(names_cdk), fill = as.factor(names_cdk))) +\n   ggdist::stat_lineribbon(.width = c(.90), alpha = 1/2)+\n   facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))+\n   labs(y = \"Between column difference in logk (individual)\", title=paste(dataNames$Name[analyte_ID_sample[i]]),color= \" \",fill= \" \", x=\"\\u03C6\")+\n  scale_fill_discrete(labels= c(\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\")) +\n  scale_color_discrete(labels= c(\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\"))+\n   geom_hline(yintercept= c(0), linetype=\"dashed\",color=\"gray\") + \n  coord_cartesian(xlim=c(0,1),ylim=c(-1,1))\n\n print(p)\n \n ggsave(paste0(\"figures\\\\izoparam\\\\\", paste(dataNames$Name[analyte_ID_sample[i]]), \".IsocraticDifferences\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nor predict the organic modifier content leading to logk of 1:\n\n\nCode\nanalyte_ID_sample &lt;-c(9,17,33,58,140,180)\n\n\nfor(i in 1:length(analyte_ID_sample)){\n\nidx_analyte = which(unique(data$METID)==analyte_ID_sample[i])\ndraws_df_subset &lt;- fit$draws(format = \"df\", variable = c(\n                sprintf(\"logkwx[%s,1,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,1,2]\",idx_analyte), \n                sprintf(\"logkwx[%s,1,3]\",idx_analyte),\n                sprintf(\"logkwx[%s,2,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,2,2]\",idx_analyte),\n                sprintf(\"logkwx[%s,2,3]\",idx_analyte),\n                sprintf(\"logkwx[%s,3,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,3,2]\",idx_analyte),\n                sprintf(\"logkwx[%s,3,3]\",idx_analyte),\n                sprintf(\"logkwx[%s,4,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,4,2]\",idx_analyte),\n                sprintf(\"logkwx[%s,4,3]\",idx_analyte),\n                sprintf(\"logkwx[%s,5,1]\",idx_analyte), \n                sprintf(\"logkwx[%s,5,2]\",idx_analyte),\n                sprintf(\"logkwx[%s,5,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,1,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,1,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,1,3]\",idx_analyte),\n                sprintf(\"S1x[%s,2,1,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,1,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,1,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,2,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,2,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,2,3]\",idx_analyte), \n                sprintf(\"S1x[%s,2,2,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,2,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,2,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,3,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,3,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,3,3]\",idx_analyte), \n                sprintf(\"S1x[%s,2,3,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,3,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,3,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,4,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,4,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,4,3]\",idx_analyte), \n                sprintf(\"S1x[%s,2,4,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,4,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,4,3]\",idx_analyte),\n                sprintf(\"S1x[%s,1,5,1]\",idx_analyte), \n                sprintf(\"S1x[%s,1,5,2]\",idx_analyte), \n                sprintf(\"S1x[%s,1,5,3]\",idx_analyte), \n                sprintf(\"S1x[%s,2,5,1]\",idx_analyte), \n                sprintf(\"S1x[%s,2,5,2]\",idx_analyte), \n                sprintf(\"S1x[%s,2,5,3]\",idx_analyte),\n                \"S2x[1,1]\", \n                \"S2x[2,1]\"))\n\np&lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(logkwx[, c, r], S1x[, m, c, r], S2x[m, ]) %&gt;%\n  filter(r&lt;=R[idx_analyte]+1)  %&gt;% \n  mutate(foo = (logkwx-1)/S1x/(1+S2x)) %&gt;%\n  mutate(fix = foo/(1-S2x*foo)) %&gt;%\n  ggplot(aes(x = fix, color = as.factor(c), fill = as.factor(c))) +\n  geom_density(alpha = 1/2) +\n  #coord_cartesian(xlim=c(0,1))+\n  facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))+\n  labs(title=paste(dataNames$Name[analyte_ID_sample[i]]),\n       color= \" \",\n       fill= \" \",\n       x = \"\\u03C6 leading to logk=1 (individual)\")+\n  scale_fill_discrete(labels= c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\")) +\n  scale_color_discrete(labels= c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\"))+\n  facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))\n\nprint(p)\n\n ggsave(paste0(\"figures\\\\izoparam\\\\\", paste(dataNames$Name[analyte_ID_sample[i]]), \".filogk1\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n}"
  },
  {
    "objectID": "index.html#individual-parameters",
    "href": "index.html#individual-parameters",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Individual Parameters",
    "text": "Individual Parameters\nIndividual parameter are the analyte-specific parameters estimated by the model. The following plots allow to assess the correlations between these parameters.\n\nNeutral Form\n\n\nCode\n#Extract sample for plots\ndraws_df &lt;- fit$draws(format = \"df\")\n\n\nIndividual parameters for the reference column (XBridge Shield RP18):\n\n\nCode\nparam &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^param\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparam &lt;- melt(param)\nparam1 &lt;- param[1:nAnalytes,]\nparam2 &lt;- param[(nAnalytes+1):(2*nAnalytes),]\nparam3 &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^dS1N\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\n\ndata_to_plot_param &lt;- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,param2,param3)\ncolnames(data_to_plot_param) &lt;- c(expression('logP'[i]),expression('logkwN'[i]),expression('S1mN'[i]),expression('dS1N'[i]))\n\np&lt;-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,\n        labeller = \"label_parsed\",upper = list(continuous = \"points\"))\n\nprint(p)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\iparam\\\\\", \"XBridgeShieldRP18.NeutralForm\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n\n\nIndividual parameters for column effects\n\n\nCode\nparam &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^clogkwN\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparam &lt;- melt(param)\nparam &lt;- matrix(param$value,nrow = nAnalytes, byrow = TRUE)\nparam1 &lt;- param[,1]\nparam2 &lt;- param[,2]\nparam3 &lt;- param[,3]\nparam4 &lt;- param[,4]\n\ndata_to_plot_param &lt;- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,param2,param3,param4)\ncolnames(data_to_plot_param) &lt;- c(expression('logP'[i]),expression('clogkwN1'[i]),expression('clogkwN2'[i]),expression('clogkwN3'[i]),expression('clogkwN4'[i]))\n\np1&lt;-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,\n        labeller = \"label_parsed\",upper = list(continuous = \"points\"))\n\n\nparam &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^cS1mN\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparam &lt;- melt(param)\nparam &lt;- matrix(param$value,nrow = nAnalytes, byrow = TRUE)\nparam1 &lt;- param[,1]\nparam2 &lt;- param[,2]\nparam3 &lt;- param[,3]\nparam4 &lt;- param[,4]\n\ndata_to_plot_param &lt;- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,param2,param3,param4)\ncolnames(data_to_plot_param) &lt;- c(expression('logP'[i]),expression('cS1mN1'[i]),expression('cS1mN2'[i]),expression('cS1mN3'[i]),expression('cS1mN4'[i]))\n\np2&lt;-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,\n        labeller = \"label_parsed\",upper = list(continuous = \"points\"))\n\nparam &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^cdS1N\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparam &lt;- melt(param)\nparam &lt;- matrix(param$value,nrow = nAnalytes, byrow = TRUE)\nparam1 &lt;- param[,1]\nparam2 &lt;- param[,2]\nparam3 &lt;- param[,3]\nparam4 &lt;- param[,4]\n\ndata_to_plot_param &lt;- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,param2,param3,param4)\ncolnames(data_to_plot_param) &lt;- c(expression('logP'[i]),expression('cdS1N1'[i]),expression('cdS1N2'[i]),expression('cdS1N3'[i]),expression('cdS1N4'[i]))\n\np3&lt;-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,\n        labeller = \"label_parsed\",upper = list(continuous = \"points\"))\n\nprint(p1)\n\n\n\n\n\nCode\nprint(p2)\n\n\n\n\n\nCode\nprint(p3)\n\n\n\n\n\nCode\n ggsave(paste0(\"figures\\\\iparam\\\\\", \"coleffects.NeutralForm_1\", \".png\"), plot=p1, width = 20, height = 20, units = \"cm\")\n  ggsave(paste0(\"figures\\\\iparam\\\\\", \"coleffects.NeutralForm_2\", \".png\"), plot=p2, width = 20, height = 20, units = \"cm\")\n   ggsave(paste0(\"figures\\\\iparam\\\\\", \"coleffects.NeutralForm_3\", \".png\"), plot=p3, width = 20, height = 20, units = \"cm\")\n\n\n\n\nEffect of dissociation\nIndividual parameters for the reference column (XBridge Shield RP18)\n\n\nCode\ndlogkwA &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^dlogkwA\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\ndlogkwA &lt;- melt(dlogkwA)[,1]\n\ndlogkwB &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^dlogkwB\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\ndlogkwB &lt;- melt(dlogkwB)[,1]\n\ndlogkw &lt;- c(dlogkwA,dlogkwB)\n\ndS1mA &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^dS1mA\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\ndS1mA &lt;- melt(dS1mA)[,1]\ndS1mB &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^dS1mB\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\ndS1mB &lt;- melt(dS1mB)[,1]\n\ndS1m &lt;- c(dS1mA,dS1mB)\n\ndS1A &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^dS1A\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\ndS1A &lt;- melt(dS1A)[,1]\ndS1B &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^dS1B\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\ndS1B &lt;- melt(dS1B)[,1]\n\ndS1 &lt;- c(dS1A,dS1B)\n\nGroupType = c(rep(\"Acids\", length(dlogkwA)),rep(\"Bases\", length(dlogkwB)))\n\ndata_to_plot_diss &lt;- data.frame(dlogkw, dS1m,dS1,GroupType)\n\np&lt;-ggpairs(data_to_plot_diss,columns = 1:3, columnLabels = c(\"dlogkw\",\"dS1m\",\"ddS1\"),\n        labeller = \"label_parsed\",\n        legend =1,\n        aes(color = GroupType, alpha = 0.5),\n        upper = list(continuous = \"points\"))+\n        scale_alpha(guide = \"none\")\n\nprint(p)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\iparam\\\\\", \"XBridgeShieldRP18.DissForm\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n\n\nIndividual parameters for the particular column (1-4) relative to XBridge Shield RP18\n\n\nCode\nparamA &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^cdlogkwA\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparamA &lt;- melt(paramA)\nparamA &lt;- matrix(paramA$value,nrow = datastruct$nGroupsA, byrow = TRUE)\nparamA1 &lt;- paramA[,1]\nparamA2 &lt;- paramA[,2]\nparamA3 &lt;- paramA[,3]\nparamA4 &lt;- paramA[,4]\n\nparamB &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^cdlogkwB\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparamB &lt;- melt(paramB)\nparamB &lt;- matrix(paramB$value,nrow = datastruct$nGroupsB, byrow = TRUE)\nparamB1 &lt;- paramB[,1]\nparamB2 &lt;- paramB[,2]\nparamB3 &lt;- paramB[,3]\nparamB4 &lt;- paramB[,4]\n\nparam1 &lt;- c(paramA1,paramB1)\nparam2 &lt;- c(paramA2,paramB2)\nparam3 &lt;- c(paramA3,paramB3)\nparam4 &lt;- c(paramA4,paramB4)\n\nGroupType = c(rep(\"Acids\", length(paramA1)),rep(\"Bases\", length(paramB1)))\n\ndata_to_plot_diss &lt;- data.frame(param1,param2,param3,param4,GroupType)\n\np1&lt;-ggpairs(data_to_plot_diss,columns = 1:4, columnLabels = c(\"cdlogkw1\",\"cdlogkw2\",\"cdlogkw3\",\"cdlogkw4\"),\n        labeller = \"label_parsed\",\n        legend =1,\n        aes(color = GroupType, alpha = 0.5),\n        upper = list(continuous = \"points\"))+\n        scale_alpha(guide = \"none\")\n\nparamA &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^cdS1mA\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparamA &lt;- melt(paramA)\nparamA &lt;- matrix(paramA$value,nrow = datastruct$nGroupsA, byrow = TRUE)\nparamA1 &lt;- paramA[,1]\nparamA2 &lt;- paramA[,2]\nparamA3 &lt;- paramA[,3]\nparamA4 &lt;- paramA[,4]\n\nparamB &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^cdS1mB\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparamB &lt;- melt(paramB)\nparamB &lt;- matrix(paramB$value,nrow = datastruct$nGroupsB, byrow = TRUE)\nparamB1 &lt;- paramB[,1]\nparamB2 &lt;- paramB[,2]\nparamB3 &lt;- paramB[,3]\nparamB4 &lt;- paramB[,4]\n\nparam1 &lt;- c(paramA1,paramB1)\nparam2 &lt;- c(paramA2,paramB2)\nparam3 &lt;- c(paramA3,paramB3)\nparam4 &lt;- c(paramA4,paramB4)\n\nGroupType = c(rep(\"Acids\", length(paramA1)),rep(\"Bases\", length(paramB1)))\n\ndata_to_plot_diss &lt;- data.frame(param1,param2,param3,param4,GroupType)\n\np2&lt;-ggpairs(data_to_plot_diss,columns = 1:4, columnLabels = c(\"cdS1m1\",\"cdS1m2\",\"cdS1m3\",\"cdS1m4\"),\n        labeller = \"label_parsed\",\n        legend =1,\n        aes(color = GroupType, alpha = 0.5),\n        upper = list(continuous = \"points\"))+\n        scale_alpha(guide = \"none\")\n\nparamA &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^cdS1A\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparamA &lt;- melt(paramA)\nparamA &lt;- matrix(paramA$value,nrow = datastruct$nGroupsA, byrow = TRUE)\nparamA1 &lt;- paramA[,1]\nparamA2 &lt;- paramA[,2]\nparamA3 &lt;- paramA[,3]\nparamA4 &lt;- paramA[,4]\n\nparamB &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^cdS1B\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparamB &lt;- melt(paramB)\nparamB &lt;- matrix(paramB$value,nrow = datastruct$nGroupsB, byrow = TRUE)\nparamB1 &lt;- paramB[,1]\nparamB2 &lt;- paramB[,2]\nparamB3 &lt;- paramB[,3]\nparamB4 &lt;- paramB[,4]\n\nparam1 &lt;- c(paramA1,paramB1)\nparam2 &lt;- c(paramA2,paramB2)\nparam3 &lt;- c(paramA3,paramB3)\nparam4 &lt;- c(paramA4,paramB4)\n\nGroupType = c(rep(\"Acids\", length(paramA1)),rep(\"Bases\", length(paramB1)))\n\ndata_to_plot_diss &lt;- data.frame(param1,param2,param3,param4,GroupType)\n\np3&lt;-ggpairs(data_to_plot_diss,columns = 1:4, columnLabels = c(\"cdS11\",\"cdS12\",\"cdS13\",\"cdS14\"),\n        labeller = \"label_parsed\",\n        legend =1,\n        aes(color = GroupType, alpha = 0.5),\n        upper = list(continuous = \"points\"))+\n        scale_alpha(guide = \"none\")\n\nprint(p1)\n\n\n\n\n\nCode\nprint(p2)\n\n\n\n\n\nCode\nprint(p3)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\iparam\\\\\", \"Differences.DissForm_1\", \".png\"), plot=p1, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\iparam\\\\\", \"Differences.DissForm_2\", \".png\"), plot=p2, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\iparam\\\\\", \"Differences.DissForm_3\", \".png\"), plot=p3, width = 20, height = 20, units = \"cm\")\n\n\n\n\npKa-related paraemters\n\n\nCode\npKawA &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^pKawA\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\npKawA &lt;- melt(pKawA)[,1]\npKawB &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^pKawB\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\npKawB &lt;- melt(pKawB)[,1]\n\nalphamA &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^alphamA\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\nalphamA &lt;- melt(alphamA)[,1]\nalphamB &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^alphamB\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\nalphamB &lt;- melt(alphamB)[,1]\n\ndalphaA &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^dalphaA\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\ndalphaA &lt;- melt(dalphaA)[,1]\ndalphaB &lt;- apply(draws_df[,which(colnames(draws_df) %in% grep(\"^dalphaB\", names(draws_df), value = TRUE))], MARGIN = 2, FUN = mean)\ndalphaB &lt;- melt(dalphaB)[,1]\n\npKapred &lt;- c(pKawA, pKawB)\npKaslit &lt;- c(pKaslitA, pKaslitB)\nalpham &lt;- c(alphamA, alphamB)\ndalpha &lt;- c(dalphaA, dalphaB)\n\nGroupType = c(rep(\"Acids\", length(alphamA)),rep(\"Bases\", length(alphamB)))\n\n\ndata_to_plot_param &lt;- data.frame(pKapred, pKaslit, alpham, dalpha, GroupType)\n\np&lt;-ggpairs(data_to_plot_param,columns = 1:4, columnLabels = c(\"pKalit\", \"pKapred\", \"alpham\", \"dalpha\"),\n        labeller = \"label_parsed\",\n        legend =1,\n        aes(color = GroupType, alpha = 0.5),\n        upper = list(continuous = \"points\"))+\n        scale_alpha(guide = \"none\")\nprint(p)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\iparam\\\\\", \"pKas\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")"
  },
  {
    "objectID": "index.html#eta-plots",
    "href": "index.html#eta-plots",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Eta plots",
    "text": "Eta plots\nEta plots shows the centered individual parameters (e.g. \\(\\eta_{logkwN,i} = (logkwN_i-(\\hat{logkwN} + \\beta_1 \\cdot \\log P_i))/\\omega_1\\)). They allow to visualize the unexplained between-analyte variability of chromatographic parameters.\n\n\nCode\nmodel_etas &lt;- cmdstan_model(\"stan/hplc-gra-fivecolumns-etas.stan\")\nfit_etas  &lt;- model_etas$generate_quantities(fit,\n                                         data = datastruct,\n                                         seed = 123,\n                                         parallel_chains = 4,\n                                         output_dir = \"stanfiles\")\n\n\n\n\nCode\nx&lt;- cmdstanr::read_cmdstan_csv(c(\n                                  'stanfiles/hplc-gra-fivecolumns-etas-202308081442-1-656020.csv',\n                                  'stanfiles/hplc-gra-fivecolumns-etas-202308081442-2-656020.csv',\n                                  'stanfiles/hplc-gra-fivecolumns-etas-202308081442-3-656020.csv',\n                                  'stanfiles/hplc-gra-fivecolumns-etas-202308081442-4-656020.csv'\n                                ))\ndraws_etas_df &lt;- as_draws_df(x$generated_quantities)\n\n# draws_etas_df &lt;- fit_etas$draws(format = \"df\")\n\n\n\nNeutral Forms\netalogkwN:\n\n\nCode\nparam1 &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etalogkwN\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\n\ncparam &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etaclogkwNc\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\ncparam &lt;- melt(cparam)\ncparam &lt;- matrix(cparam$value,nrow = nAnalytes, byrow = TRUE)\ncparam1 &lt;- cparam[,1]\ncparam2 &lt;- cparam[,2]\ncparam3 &lt;- cparam[,3]\ncparam4 &lt;- cparam[,4]\n\n\ndata_to_plot_param &lt;- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,cparam1,cparam2,cparam3,cparam4)\ncolnames(data_to_plot_param) &lt;- c(expression('logP'[i]),expression('etalogkwN'),expression('etaclogkwN_1'),expression('etaclogkwN_2'), expression('etaclogkwN_3'),expression('etaclogkwN_4'))\n\np&lt;-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,\n        labeller = \"label_parsed\",upper = list(continuous = \"points\"))\n\nprint(p)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\etaplots\\\\\", \"neutralforms_1\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n\n\netaS1mN and etadS1N:\n\n\nCode\nparam1 &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etaS1mN\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\n\ncparam &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etacS1mNc\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\ncparam &lt;- melt(cparam)\ncparam &lt;- matrix(cparam$value,nrow = nAnalytes, byrow = TRUE)\ncparam1 &lt;- cparam[,1]\ncparam2 &lt;- cparam[,2]\ncparam3 &lt;- cparam[,3]\ncparam4 &lt;- cparam[,4]\n\n\ndata_to_plot_param &lt;- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,cparam1,cparam2,cparam3,cparam4)\ncolnames(data_to_plot_param) &lt;- c(expression('logP'[i]),expression('etaS1mN'),expression('etacS1mN_1'),expression('etacS1mN_2'), expression('etacS1mN_3'),expression('etacS1mN_4'))\n\np2&lt;-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,\n        labeller = \"label_parsed\",upper = list(continuous = \"points\"))\n\n\nparam1 &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etadS1N\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\n\ncparam &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etacdS1Nc\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\ncparam &lt;- melt(cparam)\ncparam &lt;- matrix(cparam$value,nrow = nAnalytes, byrow = TRUE)\ncparam1 &lt;- cparam[,1]\ncparam2 &lt;- cparam[,2]\ncparam3 &lt;- cparam[,3]\ncparam4 &lt;- cparam[,4]\n\n\ndata_to_plot_param &lt;- cbind(dataACD$logP[which(dataACD$METID %in% data$METID)],param1,cparam1,cparam2,cparam3,cparam4)\ncolnames(data_to_plot_param) &lt;- c(expression('logP'[i]),expression('etadS1N'),expression('etacdS1N_1'),expression('etacdS1N_2'), expression('etacdS1N_3'),expression('etacdS1N_4'))\n\np3&lt;-ggpairs(as.data.frame(data_to_plot_param), columnLabels = colnames(data_to_plot_param) ,\n        labeller = \"label_parsed\",upper = list(continuous = \"points\"))\n\nprint(p2)\n\n\n\n\n\nCode\nprint(p3)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\etaplots\\\\\", \"neutralforms_2\", \".png\"), plot=p2, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\etaplots\\\\\", \"neutralforms_3\", \".png\"), plot=p3, width = 20, height = 20, units = \"cm\")\n\n\n\n\nEffect of functional groups (exploratory)\nThe following ETA plots present the relationship between individual eta values for logkwN and number of functional groups. This part is exploratory. Graphs are shown if there are at least 10 functional groups present in the dataset.\n\n\nCode\nparam1 &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etalogkwN\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\n\ncparam &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etaclogkwNc\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\ncparam &lt;- melt(cparam)\ncparam &lt;- matrix(cparam$value,nrow = nAnalytes, byrow = TRUE)\ncparam1 &lt;- cparam[,1]\ncparam2 &lt;- cparam[,2]\ncparam3 &lt;- cparam[,3]\ncparam4 &lt;- cparam[,4]\n\nfor(i in which(totalnrgroups&gt;10)){\nnrgroups = as.factor(nrfungroups[,i])\n\ndata_to_plot_fungr &lt;- data.frame(param1,cparam1,cparam2,cparam3,cparam4, nrgroups)\n\np1&lt;-data_to_plot_fungr %&gt;% tidyr::gather(\"name\", \"count\", 1:5)  %&gt;%\n   mutate(etaname = case_when(name == \"param1\" ~ \"etalogkwN\",\n                        name == \"cparam1\" ~ \"etaclogkwN_1\",\n                        name == \"cparam2\" ~ \"etaclogkwN_2\",\n                        name == \"cparam3\" ~ \"etaclogkwN_3\",\n                        name == \"cparam4\" ~ \"etaclogkwN_4\"\n                        ))  %&gt;%\n   ggplot(., aes(y=count, x=nrgroups))+\n   geom_boxplot()+\n   facet_wrap(.~etaname)+\n   labs(title=paste(functionalgroupsnames[i,2]), x=\"Nr of functional groups\", y=\"eta\")\n\nprint(p1)\n\n\n ggsave(paste0(\"figures\\\\etaplots\\\\\", functionalgroupsnames[i,2], \".functionalgroupseffects\", \".png\"), plot=p1, width = 20, height = 20, units = \"cm\")\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEffect of dissociation\n\n\nCode\nparamA &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etacdlogkwAc\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparamA &lt;- melt(paramA)\nparamA &lt;- matrix(paramA$value,nrow = datastruct$nGroupsA, byrow = TRUE)\nparamA1 &lt;- paramA[,1]\nparamA2 &lt;- paramA[,2]\nparamA3 &lt;- paramA[,3]\nparamA4 &lt;- paramA[,4]\n\nparamB &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etacdlogkwBc\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparamB &lt;- melt(paramB)\nparamB &lt;- matrix(paramB$value,nrow = datastruct$nGroupsB, byrow = TRUE)\nparamB1 &lt;- paramB[,1]\nparamB2 &lt;- paramB[,2]\nparamB3 &lt;- paramB[,3]\nparamB4 &lt;- paramB[,4]\n\nparam1 &lt;- c(paramA1,paramB1)\nparam2 &lt;- c(paramA2,paramB2)\nparam3 &lt;- c(paramA3,paramB3)\nparam4 &lt;- c(paramA4,paramB4)\n\nGroupType = c(rep(\"Acids\", length(paramA1)),rep(\"Bases\", length(paramB1)))\n\ndata_to_plot_diss &lt;- data.frame(param1,param2,param3,param4,GroupType)\n\n\np1&lt;-ggpairs(data_to_plot_diss,columns = 1:4, columnLabels = c(\"etadlogkw1\",\"etadlogkw2\",\"etadlogkw3\", \"etadlogkw4\"),\n        labeller = \"label_parsed\",\n        legend =1,\n        aes(color = GroupType, alpha = 0.5),\n        upper = list(continuous = \"points\"))+\n        scale_alpha(guide = \"none\")\n\n\nparamA &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etacdS1mAc\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparamA &lt;- melt(paramA)\nparamA &lt;- matrix(paramA$value,nrow = datastruct$nGroupsA, byrow = TRUE)\nparamA1 &lt;- paramA[,1]\nparamA2 &lt;- paramA[,2]\nparamA3 &lt;- paramA[,3]\nparamA4 &lt;- paramA[,4]\n\nparamB &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etacdS1mBc\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparamB &lt;- melt(paramB)\nparamB &lt;- matrix(paramB$value,nrow = datastruct$nGroupsB, byrow = TRUE)\nparamB1 &lt;- paramB[,1]\nparamB2 &lt;- paramB[,2]\nparamB3 &lt;- paramB[,3]\nparamB4 &lt;- paramB[,4]\n\nparam1 &lt;- c(paramA1,paramB1)\nparam2 &lt;- c(paramA2,paramB2)\nparam3 &lt;- c(paramA3,paramB3)\nparam4 &lt;- c(paramA4,paramB4)\n\nGroupType = c(rep(\"Acids\", length(paramA1)),rep(\"Bases\", length(paramB1)))\n\ndata_to_plot_diss &lt;- data.frame(param1,param2,param3,param4,GroupType)\n\n\np2&lt;-ggpairs(data_to_plot_diss,columns = 1:4, columnLabels = c(\"etacdS1m1\",\"etacdS1m2\",\"etacdS1m3\", \"etacdS1m4\"),\n        labeller = \"label_parsed\",\n        legend =1,\n        aes(color = GroupType, alpha = 0.5),\n        upper = list(continuous = \"points\"))+\n        scale_alpha(guide = \"none\")\n\n\nparamA &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etacdS1Ac\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparamA &lt;- melt(paramA)\nparamA &lt;- matrix(paramA$value,nrow = datastruct$nGroupsA, byrow = TRUE)\nparamA1 &lt;- paramA[,1]\nparamA2 &lt;- paramA[,2]\nparamA3 &lt;- paramA[,3]\nparamA4 &lt;- paramA[,4]\n\nparamB &lt;- apply(draws_etas_df[,which(colnames(draws_etas_df) %in% grep(\"^etacdS1Bc\", names(draws_etas_df), value = TRUE))], MARGIN = 2, FUN = mean)\nparamB &lt;- melt(paramB)\nparamB &lt;- matrix(paramB$value,nrow = datastruct$nGroupsB, byrow = TRUE)\nparamB1 &lt;- paramB[,1]\nparamB2 &lt;- paramB[,2]\nparamB3 &lt;- paramB[,3]\nparamB4 &lt;- paramB[,4]\n\nparam1 &lt;- c(paramA1,paramB1)\nparam2 &lt;- c(paramA2,paramB2)\nparam3 &lt;- c(paramA3,paramB3)\nparam4 &lt;- c(paramA4,paramB4)\n\nGroupType = c(rep(\"Acids\", length(paramA1)),rep(\"Bases\", length(paramB1)))\n\ndata_to_plot_diss &lt;- data.frame(param1,param2,param3,param4,GroupType)\n\n\np3&lt;-ggpairs(data_to_plot_diss,columns = 1:4, columnLabels = c(\"etacdS11\",\"etacdS12\",\"etacdS13\", \"etacdS14\"),\n        labeller = \"label_parsed\",\n        legend =1,\n        aes(color = GroupType, alpha = 0.5),\n        upper = list(continuous = \"points\"))+\n        scale_alpha(guide = \"none\")\n\nprint(p1)\n\n\n\n\n\nCode\nprint(p2)\n\n\n\n\n\nCode\nprint(p3)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\etaplots\\\\\", \"dissociatedforms_1\", \".png\"), plot=p1, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\etaplots\\\\\", \"dissociatedforms_2\", \".png\"), plot=p2, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\etaplots\\\\\", \"dissociatedforms_3\", \".png\"), plot=p3, width = 20, height = 20, units = \"cm\")\n\n\n\n\n\n\nCode\nfitsim &lt;- cmdstanr::as_cmdstan_fit(c(\n                                 #  'stanfiles/output_1.csv',\n                                 #  'stanfiles/output_2.csv',\n                                 #  'stanfiles/output_3.csv',\n                                 #  'stanfiles/output_4.csv',\n                                 #  'stanfiles/output_5.csv',\n                                 #  'stanfiles/output_6.csv',\n                                 #  'stanfiles/output_7.csv',\n                                    'stanfiles/output_8.csv'\n                                ))\n\n\n\n\nCode\ndesign &lt;- read.csv('data/hplcparam_design.csv')\ndesign$Mod  = as.character(design$Mod)\ndesign$Mod2 = ifelse(design$Mod==\"MeOH\",1,2) # MeOH = 1, ACN = 2\ndesign$expid = match(design$expid, unique(design$expid))\nnAnalytes &lt;- datastruct$nAnalytes\nnColumns &lt;- datastruct$nColumns\nnExp &lt;- nrow(design);\ndatasim &lt;- design %&gt;%\n           slice(rep(row_number(), nAnalytes*nColumns)) %&gt;%\n           mutate(Column = rep(c(1,2,3,4,5), each = nExp*nAnalytes)) %&gt;%\n           mutate(METID = rep(rep(unique(data$METID),each=nExp),nColumns))\ndatasim$expid = datasim$expid*(2-datasim$Colum) + (length(unique(datasim$expid))+datasim$expid) *(datasim$Colum-1)\ndatasim$ColumnName = ifelse(datasim$Column==1,\"XBridge Shield RP18\",\n                            ifelse(datasim$Column==2,\"XTerra MS C18\",\n                                   ifelse(datasim$Column==3,\"XBridge Phenyl\",\n                                          ifelse(datasim$Column==4,\"XBridge C8\", \"Xterra MS C8\"))))\n\ndatasim$to[datasim$Column==1] = 0.532\ndatasim$to[datasim$Column==2] = 0.542\ndatasim$to[datasim$Column==3] = 0.542\ndatasim$to[datasim$Column==4] = 0.552\ndatasim$to[datasim$Column==5] = 0.566\n\ndatastructsim &lt;-datastruct\ndatastructsim$nObs=length(datasim$METID)\ndatastructsim$analyte=match(datasim$METID, unique(datasim$METID))\ndatastructsim$modifier=match(datasim$Mod2, sort(unique(datasim$Mod2)))\ndatastructsim$steps=4*(2-datasim$Mod2) + 10*(datasim$Mod2-1)\ndatastructsim$column=match(datasim$Column, unique(datasim$Column))\ndatastructsim$hplcparam=cbind(datasim$tg,datasim$td,datasim$to,datasim$te,\n                              datasim$fio,datasim$fik,datasim$Mod2-1,datasim$pHo,\n                              datasim$alpha1,datasim$alpha2,(datasim$Temp-25)/10,\n                              datasim$Column-1)\ndatastructsim$trobs = rep(0,datastructsim$nObs)\n\n\n\n\nCode\nmodel_sim &lt;- cmdstan_model(\"stan/hplc-gra-fivecolumns-sim.stan\")\n\nfit_sim  &lt;- model_sim$generate_quantities(fitsim,\n                                         data = datastructsim,\n                                         seed = 123,\n                                         parallel_chains = 4,\n                                         output_dir = \"stanfiles\")\n\n\n\n\nCode\nx&lt;- cmdstanr::read_cmdstan_csv(c(\n                                  'stanfiles/hplc-gra-fivecolumns-sim-202308082137-1-2fe368.csv'\n                                ))\n\ndraws_sim_df &lt;- as_draws_df(x$generated_quantities)\n\n# draws_sim_df &lt;- fit_sim$draws(format = \"df\")\n\n\n\n\nCode\ntr_sim_Cond &lt;- apply(draws_sim_df[,which(colnames(draws_sim_df) %in% grep(\"^trCond\", names(draws_sim_df), value = TRUE))], MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))\n\ntr_sim_Pred &lt;- apply(draws_sim_df[,which(colnames(draws_sim_df) %in% grep(\"^trPred\", names(draws_sim_df), value = TRUE))], MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))\n\ntr_sim_Cond&lt;-as.data.frame(t(tr_sim_Cond))\n\ndatasim$trCond_l=tr_sim_Cond$`5%`\n\ndatasim$trCond_m=tr_sim_Cond$`50%`\n\ndatasim$trCond_h=tr_sim_Cond$`95%`\n\ntr_sim_Pred&lt;-as.data.frame(t(tr_sim_Pred))\n\ndatasim$trPred_l=tr_sim_Pred$`5%`\n\ndatasim$trPred_m=tr_sim_Pred$`50%`\n\ndatasim$trPred_h=tr_sim_Pred$`95%`"
  },
  {
    "objectID": "index.html#prepare-the-data",
    "href": "index.html#prepare-the-data",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Prepare the data",
    "text": "Prepare the data\nFirst we load the data:\n\n\nCode\ndata1 = read.csv('data/1-X_Bridge_Shield_C18_5cm.csv')\ndata2 = read.csv('data/1-XTerra_MS_C18.csv')\ndata3 = read.csv('data/1-X_Bridge_Phenyl.csv')\ndata4 = read.csv('data/1-XBridge_C8.csv')\ndata5 = read.csv('data/1-Xterra_C8.csv')\n\ndataNames = read.csv('data/4-compounds-names.csv')\ndataACD = read.csv('data/2-ACD-pKas-logP.csv')\ndataACD$R = rowSums(dataACD[,3:7]&lt;14) # No of dissociation steps\n\nfunctional_groups = read.csv('data/6-checkmol-functional-groups.csv')\nfunctional_groups_names = read.csv('data/Legend-checkmol-functional-group-names.csv')\n\n# marge the data:\n\ndata1['Column'] &lt;- 1\ndata2['Column'] &lt;- 2\ndata3['Column'] &lt;- 3\ndata4['Column'] &lt;- 4\ndata5['Column'] &lt;- 5\n\ndata1['ColumnName'] &lt;- 'XBridge Shield RP18'\ndata2['ColumnName'] &lt;- 'XTerra MS C18'\ndata3['ColumnName'] &lt;- 'XBridge Phenyl'\ndata4['ColumnName'] &lt;- 'XBridge C8'\ndata5['ColumnName'] &lt;- 'Xterra MS C8'\n\ndata = rbind(data1, data2, data3, data4, data5)\n\ndata$Mod  = as.character(data$Mod)\ndata$Mod2 = ifelse(data$Mod==\"MeOH\",1,2)   \n\ndata&lt;-data %&gt;% \n  left_join(select(dataACD,METID,R))\n  \nrm(data1, data2, data3, data4, data5)\n\n\nSecond, we did some data wrangling:\n\nwe removed measurements with low score, analytes with less than 42 measurements per column, analytes with less than 210 measurements out of total 420, and used measurements with the highest score (If several were present)\n\n\n\nCode\ndata &lt;- data  %&gt;%\n  subset(Score&gt;95) %&gt;%\n  group_by(METID,EXPID,Column) %&gt;%\n  slice(which.max(Score)) %&gt;%\n  group_by(METID,Column) %&gt;%\n  add_count() %&gt;%\n  subset(n&gt;42) %&gt;%\n  group_by(METID) %&gt;%\n  add_count() %&gt;%\n  subset(nn&gt;210) %&gt;%\n  select(-n,-nn) %&gt;%\n  ungroup()\n\n\n\nwe removed some outlying measurements (mismatch between literature pKa and observed data)\n\n\n\nCode\ndata &lt;- data %&gt;%  \n  subset(METID!=72) %&gt;%  # dilevalol is repeated in the dataset\n  subset(!(tg==270 & Temp==25 & Mod2==1 & pH==5)) %&gt;% \n  subset(!(tg==270 & Temp==25 & Mod2==1 & pH==9)) %&gt;% \n  subset(R&lt;=2) %&gt;%\n   subset(!(METID %in% c(11,91,154,204,227,274,102,235,131,158,257,138,281,248,110,135,78,201,264,31,293,8,25,176,246)))%&gt;%\n  select(-R)\n\n\n\nwe prepared predictors: pKa, logP and functional_groups\n\n\n\nCode\npKaslit = dataACD[,3:7]           # pKa values as predicted by ACD\npKasliterror = dataACD[,25:29]    # pKa error as predicted by ACD\nchargesA = abs(dataACD[,13:18])   # number of ionized groups (anions)\nchargesB = abs(dataACD[,19:24])   # number of ionized groups (cations)\ncharges = chargesA+chargesB                         # absolute charge\ngroupsA = (chargesA[,2:5] - chargesA[,1:4])         # acidic group\ngroupsB = -(chargesB[,2:5] - chargesB[,1:4])        # basic group\nR = dataACD$R                      # number of dissociation steps\ngroups = groupsB-groupsA\nlogPobs = dataACD$logP \n\nfunctional_groups=functional_groups[,2:ncol(functional_groups)]\n\n# combine nr of caroboxylic acid and carboxyalic acid salt functional groups\n# heterocyclic compounds with more than 6 heterocycles are treated as if they have six\nfunctional_groups[,76]=functional_groups[,76]+functional_groups[,77]       \nfunctional_groups[which(functional_groups[,202]&gt;5.5),202] = 6; \n\n# exclude some functional groups\nidx_included &lt;- c(4,5,9,11,14,18,19,20,21,24,26,29,30,31,32,33,34,38,39,40,41,45,49,50,52,53,54,56,57,59,63,64,68,69,70,71,76,78,79,81,82,83,84,85,88,90,106,108,113,114,115,127,131,133,137,138,150,164,166,167)\nfunctional_groups_names &lt;- functional_groups_names[idx_included,]\nfunctional_groups &lt;- functional_groups[,idx_included]\n\nrm(idx_included)\n\n\n\nwe selected analytes with two or less dissociation steps\n\n\n\nCode\nmaxR &lt;- 2         \nidx &lt;- which(dataACD$METID %in% data$METID)\n # max two dissociation steps        \npKaslit &lt;- pKaslit[idx,1:maxR]           # pKa values as predicted by ACD\npKasliterror &lt;- pKasliterror[idx,1:maxR] # pKa error as predicted by ACD\nchargesA &lt;- chargesA[idx,1:(maxR+1)]     # number of ionized groups (anions)\nchargesB &lt;- chargesB[idx,1:(maxR+1)]     # number of ionized groups (cations)\ncharges &lt;- charges[idx,1:(maxR+1)]       # absolute charge\ngroupsA &lt;- groupsA[idx,1:maxR]           # acidic group\ngroupsB &lt;- groupsB[idx,1:maxR]           # basic group\nR &lt;- R[idx]                              # number of dissociation steps\nlogPobs &lt;- logPobs[idx]                     # logP\nnrfungroups=functional_groups[idx,]\ntotalnrgroups &lt;- summarise_each(nrfungroups, funs(sum))\n\n# remove functional groups not present in the dataset:\nnrfungroups &lt;- nrfungroups[,which(totalnrgroups!=0)]\nfunctionalgroupsnames&lt;- functional_groups_names[which(totalnrgroups!=0),]\ntotalnrgroups &lt;- summarise_each(nrfungroups, funs(sum))\nK &lt;- ncol(nrfungroups)\n\n# identify acidic groups\nidxGroupsA &lt;-which(groupsA!=0,arr.ind = T)\nnGroupsA &lt;- nrow(idxGroupsA)\npKaslitA&lt;-pKaslit[idxGroupsA]\n# identify basic groups\nidxGroupsB &lt;-which(groupsB!=0,arr.ind = T)\nnGroupsB &lt;- nrow(idxGroupsB)\npKaslitB&lt;-pKaslit[idxGroupsB]\n\n# groups dissociated in the whole pH range\n\nidxB = which(chargesB[,3]==1)\nidxA = which(chargesA[,1]==1)\n\nnObs &lt;- length(data$METID)\nnAnalytes &lt;- length(unique(data$METID))\nnColumns&lt;-length(unique(data$Column))\n                \n#  variables used later to annotate graphs legend\ntemp.labs &lt;- c(\"25\\u00b0C\",\"35\\u00b0C\")\nnames(temp.labs) &lt;- c('25','35')\n\nmod.labs &lt;- c(\"ACN\",\"MeOH\")\nnames(mod.labs) &lt;- c('2','1')\n\n\ncol.labs &lt;- c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\")\nnames(col.labs) &lt;- c('1','2','3','4','5')\n\ndiss.labs &lt;- c(\"r=1\",\"r=2\",\"r=3\")\nnames(diss.labs) &lt;- c('1','2','3')"
  },
  {
    "objectID": "index.html#individual-predictions",
    "href": "index.html#individual-predictions",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Individual predictions:",
    "text": "Individual predictions:\n\n\nCode\nanalyte_ID_sample &lt;- c(9,17,33,58,140,180)\n\n#analyte_ID_sample &lt;-unique(data$METID)\n\nfor(i in 1:length(analyte_ID_sample)){\n\np &lt;- ggplot()+\n     geom_point(data=data[which(data$METID %in% analyte_ID_sample[i]),],\n                aes(x = pHs, y = RT, color = as.factor(tg)))+\n     geom_line(data=datasim[which(datasim$METID %in% analyte_ID_sample[i]),],\n               aes(x = pHs, y = trCond_m, color = as.factor(tg)))+\n     geom_ribbon(data=datasim[which(datasim$METID %in% analyte_ID_sample[i]),],\n                 aes(x = pHs, ymin = trCond_l, ymax = trCond_h, fill = as.factor(tg)), alpha = 0.25)+\n     xlim(2,11)+\n     facet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+\n      labs(title=paste(dataNames$Name[analyte_ID_sample[i]]),\n           x =\"pH\",\n           y = \"Retention time (individual), min\",\n           color = \"tg, min\",\n           fill = \"tg, min\")\n\nprint(p)\n\nggsave(paste0(\"figures\\\\concordanceplots\\\\\", paste(dataNames$Name[analyte_ID_sample[i]]), \".individual\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n}"
  },
  {
    "objectID": "index.html#population-predictions",
    "href": "index.html#population-predictions",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Population predictions:",
    "text": "Population predictions:\n\n\nCode\nanalyte_ID_sample &lt;- c(9,17,33,58,140,180)\n\nfor(i in 1:length(analyte_ID_sample)){\np &lt;- ggplot()+\n     geom_point(data=data[which(data$METID %in% analyte_ID_sample[i]),],\n                aes(x = pHs, y = RT, color = as.factor(tg)))+\n     geom_line(data=datasim[which(datasim$METID %in% analyte_ID_sample[i]),],\n               aes(x = pHs, y = trPred_m, color = as.factor(tg)))+\n     geom_ribbon(data=datasim[which(datasim$METID %in% analyte_ID_sample[i]),],\n                aes(x = pHs, ymin = trPred_l, ymax = trPred_h, fill = as.factor(tg)), alpha = 0.25)+\n     xlim(2,11)+\n     facet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+\n      labs(title=paste(dataNames$Name[analyte_ID_sample[i]]),\n           x =\"pH\",\n           y = \"Retention time (population), min\",\n           color = \"tg, min\",\n           fill = \"tg, min\")\nprint(p)\n\nggsave(paste0(\"figures\\\\concordanceplots\\\\\", paste(dataNames$Name[analyte_ID_sample[i]]), \".population\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n}"
  },
  {
    "objectID": "index.html#isocratic-predictions-population-predictions",
    "href": "index.html#isocratic-predictions-population-predictions",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Isocratic predictions (population predictions)",
    "text": "Isocratic predictions (population predictions)\nTo better asses the impact of parameters on retention we created graphs presenting the isocratic logarithm of retention factor vs. φ for selected analytes. Separate graphs are shown for each dissociation form (r=1,r=2,r=3). Here the population predictions are shown:\n\n\nCode\nanalyte_ID_sample &lt;-c(9,17,33,58,140,180)\n\nfor(i in 1:length(analyte_ID_sample)){\n\nidx_analyte = which(unique(data$METID)==analyte_ID_sample[i])\ndraws_df_subset &lt;- draws_epred_df[,which(colnames(draws_epred_df) %in% c(\n                sprintf(\"logkwxPred[%s,1,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,1,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,1,3]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,2,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,2,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,2,3]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,3,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,3,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,3,3]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,4,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,4,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,4,3]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,5,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,5,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,5,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,1,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,1,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,1,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,1,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,1,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,1,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,2,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,2,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,2,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,2,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,2,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,2,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,3,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,3,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,3,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,3,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,3,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,3,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,4,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,4,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,4,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,4,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,4,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,4,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,5,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,5,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,5,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,5,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,5,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,5,3]\",idx_analyte),\n                \"S2xPred[1,1]\",\n                \"S2xPred[2,1]\",\n                \".draw\",\".iteration\",\".chain\"))]\n\np&lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(logkwxPred[, c, r], S1xPred[, m, c, r], S2xPred[m, ]) %&gt;%\n  filter(r&lt;=R[idx_analyte]+1)  %&gt;%\n  tidyr::expand_grid(fi = seq(0,1,0.1)) %&gt;%\n  mutate(logkPred = logkwxPred-S1xPred*(1+S2xPred)*fi/(1+S2xPred*fi)) %&gt;%\n  ggplot(aes(x = fi, y = logkPred, color = as.factor(c), fill = as.factor(c))) +\n  ggdist::stat_lineribbon(.width = c(.90), alpha = 1/2) +\n  facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))+\n  labs(title=paste(dataNames$Name[analyte_ID_sample[i]]),color= \" \",fill= \" \", y = \"logk (population)\", x=\"\\u03C6\")+\n  scale_fill_discrete(labels= c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\")) +\n  scale_color_discrete(labels= c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\"))+\n  geom_hline(yintercept= c(0,1), linetype=\"dashed\",color=\"gray\")\nprint(p)\n\nggsave(paste0(\"figures\\\\izoparam\\\\\", paste(dataNames$Name[analyte_ID_sample[i]]), \".isopred.population\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimilarly we can quantify the column effects (between column differences in logk using XBridge Shield RP18 as a reference column):\n\n\nCode\nanalyte_ID_sample &lt;-c(9,17,33,58,140,180)\n\nfor(i in 1:length(analyte_ID_sample)){\n\nidx_analyte = which(unique(data$METID)==analyte_ID_sample[i])\n\ndraws_df_subset &lt;- draws_epred_df[,which(colnames(draws_epred_df) %in% c(\n                sprintf(\"logkwxPred[%s,1,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,1,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,1,3]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,2,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,2,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,2,3]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,3,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,3,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,3,3]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,4,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,4,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,4,3]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,5,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,5,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,5,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,1,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,1,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,1,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,1,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,1,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,1,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,2,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,2,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,2,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,2,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,2,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,2,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,3,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,3,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,3,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,3,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,3,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,3,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,4,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,4,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,4,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,4,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,4,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,4,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,5,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,5,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,5,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,5,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,5,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,5,3]\",idx_analyte),\n                \"S2xPred[1,1]\",\n                \"S2xPred[2,1]\",\n                \".draw\",\".iteration\",\".chain\"))]\n\np&lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(logkwxPred[, c, r], S1xPred[, m, c, r], S2xPred[m, ]) %&gt;%\n  filter(r&lt;=R[idx_analyte]+1) %&gt;%\n  tidyr::expand_grid(fi = seq(0,1,0.05)) %&gt;%\n  mutate(logkPred = logkwxPred-S1xPred*(1+S2xPred)*fi/(1+S2xPred*fi)) %&gt;%\n  select(.draw,c,r,m,logkPred,fi) %&gt;%\n  tidyr::pivot_wider(names_from = c, values_from = logkPred) %&gt;%\n  mutate(cdk2 = `2`-`1` ) %&gt;%\n  mutate(cdk3 = `3`-`1` ) %&gt;%\n  mutate(cdk4 = `4`-`1` ) %&gt;%\n  mutate(cdk5 = `5`-`1` ) %&gt;%\n  tidyr::pivot_longer(cdk2:cdk5,names_to = \"names_cdk\", values_to = \"cdk\")%&gt;%\n   ggplot(aes(x = fi, y = cdk, color = as.factor(names_cdk), fill = as.factor(names_cdk))) +\n   ggdist::stat_lineribbon(.width = c(.90), alpha = 1/2)+\n   facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))+\n   labs(y = \"Between column difference in logk (population)\", title=paste(dataNames$Name[analyte_ID_sample[i]]),color= \" \",fill= \" \", x=\"\\u03C6\")+\n  scale_fill_discrete(labels= c(\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\")) +\n  scale_color_discrete(labels= c(\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\"))+\n   geom_hline(yintercept= c(0), linetype=\"dashed\",color=\"gray\") +\n  coord_cartesian(xlim=c(0,1),ylim=c(-1,1))\n print(p)\n\n ggsave(paste0(\"figures\\\\izoparam\\\\\", paste(dataNames$Name[analyte_ID_sample[i]]), \"isodifferences.population\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nor predict the organic modifier content leading to logk of 1:\n\n\nCode\nanalyte_ID_sample &lt;-c(9,17,33,58,140,180)\n\nfor(i in 1:length(analyte_ID_sample)){\n\nidx_analyte = which(unique(data$METID)==analyte_ID_sample[i])\n\ndraws_df_subset &lt;- draws_epred_df[,which(colnames(draws_epred_df) %in% c(\n                sprintf(\"logkwxPred[%s,1,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,1,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,1,3]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,2,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,2,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,2,3]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,3,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,3,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,3,3]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,4,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,4,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,4,3]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,5,1]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,5,2]\",idx_analyte),\n                sprintf(\"logkwxPred[%s,5,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,1,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,1,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,1,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,1,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,1,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,1,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,2,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,2,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,2,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,2,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,2,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,2,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,3,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,3,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,3,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,3,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,3,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,3,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,4,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,4,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,4,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,4,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,4,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,4,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,5,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,5,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,1,5,3]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,5,1]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,5,2]\",idx_analyte),\n                sprintf(\"S1xPred[%s,2,5,3]\",idx_analyte),\n                \"S2xPred[1,1]\",\n                \"S2xPred[2,1]\",\n                \".draw\",\".iteration\",\".chain\"))]\n\np&lt;-draws_df_subset %&gt;%\n  slice_sample(n=1000) %&gt;%\n  tidybayes::spread_draws(logkwxPred[, c, r], S1xPred[, m, c, r], S2xPred[m, ]) %&gt;%\n  filter(r&lt;=R[idx_analyte]+1)  %&gt;%\n  mutate(foo = (logkwxPred-1)/S1xPred/(1+S2xPred)) %&gt;%\n  mutate(fix = foo/(1-S2xPred*foo)) %&gt;%\n  ggplot(aes(x = fix, color = as.factor(c), fill = as.factor(c))) +\n  geom_density(alpha = 1/2) +\n  coord_cartesian(xlim=c(0,1))+\n  facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))+\n  labs(title=paste(dataNames$Name[analyte_ID_sample[i]]),color= \" \",fill= \" \", x = \"\\u03C6 leading to logk=1 (population)\")+\n  scale_fill_discrete(labels= c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\")) +\n  scale_color_discrete(labels= c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\"))+\n  facet_wrap(m~r, nrow = 2,labeller = labeller(m=mod.labs,r=diss.labs))\nprint(p)\n ggsave(paste0(\"figures\\\\izoparam\\\\\", paste(dataNames$Name[analyte_ID_sample[i]]), \"filogk1.population\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n}"
  },
  {
    "objectID": "index.html#utility-maps",
    "href": "index.html#utility-maps",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Utility maps",
    "text": "Utility maps\nLet’s find the best chromatogram that maximize utility using the set of experiments used to build the model.\nThe utility function is based on lowest retention time, highest retention time and the difference of retention times between the critical pair of analytes. This utility is zero if at least one of the analyte has retention higher that 40, less than 2 min or the difference in retention time is less than 2. Otherwise, it favors shorter runs. (.) denotes design variables.\n$$\nU(.)= I((mintr(.)&gt;2)  &  (res(.)&gt;2)) (40-maxtr(.)) I(maxtr(.)&lt;40)\n$$\n$$\nI(x) = 1  if  condition  x  is  true \\\nI(x) = 0  if  condition  x  is  false \\\n$$\n\n\nCode\nupH &lt;- datasim %&gt;%\n  select(1:20) %&gt;%\n  distinct(Temp,Mod, pHo, alpha1, alpha2) %&gt;%\n  group_by(Temp,Mod) %&gt;%\n  tidyr::complete(pHo = seq(min(pHo), max(pHo), len = 17)) %&gt;%\n  arrange(Temp,Mod,pHo) %&gt;%\n  mutate(alpha1 = zoo::na.approx(alpha1,pHo)) %&gt;%\n  mutate(alpha2 = zoo::na.approx(alpha2,pHo)) %&gt;%\n  group_by(Temp,Mod) %&gt;%\n  mutate(pHid = row_number()) %&gt;%\n  group_by(pHid)  %&gt;%\n  mutate(pHs = round(mean(pHo),2)) %&gt;%\n  ungroup()\n\ndatasim2 &lt;- datasim %&gt;%\n  select(1:20) %&gt;%\n  filter(tg==30, Temp==25) %&gt;%\n  select(-tg, -fio, -expid, -pHs, -pHo, -alpha1, -alpha2, -pH) %&gt;%\n  distinct() %&gt;%\n tidyr::expand_grid(fio = seq(0.05,0.2,0.05),tg = seq(20,260,20), pHs=unique(upH$pHs))%&gt;%\n  left_join(upH, by = join_by(pHs, Mod, Temp), relationship = \"many-to-one\") %&gt;%\n  group_by(tg, fio, Mod, Column, pHs) %&gt;%\n  mutate(expid = cur_group_id()) %&gt;%\n  ungroup()\n\ndatastructsim2 &lt;-datastruct\ndatastructsim2$nObs=length(datasim2$METID)\ndatastructsim2$analyte=match(datasim2$METID, unique(datasim2$METID))\ndatastructsim2$modifier=match(datasim2$Mod2, sort(unique(datasim2$Mod2)))\ndatastructsim2$steps=4*(2-datasim2$Mod2) + 10*(datasim2$Mod2-1)\ndatastructsim2$column=match(datasim2$Column, unique(datasim2$Column))\ndatastructsim2$hplcparam=cbind(datasim2$tg,datasim2$td,datasim2$to,datasim2$te,\n                              datasim2$fio,datasim2$fik,datasim2$Mod2-1,datasim2$pHo,\n                              datasim2$alpha1,datasim2$alpha2,(datasim2$Temp-25)/10,\n                              datasim2$Column-1)\ndatastructsim2$trobs = rep(0,datastructsim2$nObs)\nanalyte_ID_sample =  c(9,17,33,58,140,180)\nidx &lt;- which(datasim2$METID %in% analyte_ID_sample)\ndatasim_red = datasim2[idx,]\ndatastructsim_red &lt;-datastructsim2\ndatastructsim_red$nObs=length(datastructsim_red$analyte[idx])\ndatastructsim_red$analyte=datastructsim_red$analyte[idx]\ndatastructsim_red$modifier=datastructsim_red$modifier[idx]\ndatastructsim_red$steps=datastructsim_red$steps[idx]\ndatastructsim_red$column=datastructsim_red$column[idx]\ndatastructsim_red$hplcparam=datastructsim_red$hplcparam[idx,]\ndatastructsim_red$trobs = rep(0,datastructsim_red$nObs)\ndatastructsim_red$nexpid=length(unique(datasim_red$expid))\ndatastructsim_red$expid=match(datasim_red$expid, unique(datasim_red$expid))\ndatastructsim_red$nAnalytessim=length(unique(datastructsim_red$analyte))\ndatastructsim_red$analytesim=match(datastructsim_red$analyte, unique(datastructsim_red$analyte))\n\n\n\n\nCode\nmodel_sim_red &lt;- cmdstan_model(\"stan/hplc-gra-fivecolumns-fixed-sim.stan\")\n\nfit_sim_red2  &lt;- model_sim_red$generate_quantities(fit_red2,\n                                         data = datastructsim_red,\n                                         seed = 123,\n                                         parallel_chains = 4,\n                                         output_dir = \"stanfiles\")\n\n\n\n\nCode\nx&lt;- cmdstanr::read_cmdstan_csv(c(\n                                  'stanfiles/hplc-gra-fivecolumns-fixed-sim-202308090855-1-54912f.csv'\n                                ))\n\ndraws_sim_red_df &lt;- as_draws_df(x$generated_quantities)\n\n#draws_sim_red_df &lt;- fit_sim_red$draws(format = \"df\")\n\n\n\n\nCode\nfoo&lt;-datasim_red[!duplicated(datasim_red$expid),]\nx&lt;-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep(\"^mindifftr\", names(draws_sim_red_df), value = TRUE))]\ny&lt;-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep(\"^maxtr\", names(draws_sim_red_df), value = TRUE))]\nz&lt;-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep(\"^mintr\", names(draws_sim_red_df), value = TRUE))]\n\nu=x;\n\nfor (i in 1:ncol(x)){u[,i] &lt;- as.numeric(x[,i]&gt;2 & z[,i] &gt; 2) * (40-y[,i]) * as.numeric(y[,i]&lt;40)}\n\npr &lt;- apply(u, MARGIN = 2, FUN = mean)\npr&lt;-as.data.frame(pr)\n\nfoo$EUtility=pr$pr\n\nx &lt;- apply(x, MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))\nx&lt;-as.data.frame(t(x))\n\nfoo$mindifftr_l=x$`5%`\nfoo$mindifftr_m=x$`50%`\nfoo$mindifftr_h=x$`95%`\n\ny &lt;- apply(y, MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))\n\ny&lt;-as.data.frame(t(y))\n\nfoo$maxtr_l=y$`5%`\nfoo$maxtr_m=y$`50%`\nfoo$maxtr_h=y$`95%`\n\np11 &lt;- ggplot()+\n     geom_contour_filled(data=subset(foo,Column==1), aes(x = pHs, y=tg, z = EUtility))+\n     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"tg, min\",\n          fill = \"Expected Utility\")\n\nprint(p11)\n\n\n\n\n\nCode\np12 &lt;- ggplot()+\n     geom_contour_filled(data=subset(foo,Column==2), aes(x = pHs, y=tg, z = EUtility))+\n     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"tg, min\",\n          fill = \"Expected Utility\")\n\nprint(p12)\n\n\n\n\n\nCode\np13 &lt;- ggplot()+\n     geom_contour_filled(data=subset(foo,Column==3), aes(x = pHs, y=tg, z = EUtility))+\n     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"tg, min\",\n          fill = \"Expected Utility\")\n\nprint(p13)\n\n\n\n\n\nCode\np14 &lt;- ggplot()+\n     geom_contour_filled(data=subset(foo,Column==4), aes(x = pHs, y=tg, z = EUtility))+\n     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"tg, min\",\n          fill = \"Expected Utility\")\n\nprint(p14)\n\n\n\n\n\nCode\np15 &lt;- ggplot()+\n     geom_contour_filled(data=subset(foo,Column==5), aes(x = pHs, y=tg, z = EUtility))+\n     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"tg, min\",\n          fill = \"Expected Utility\")\n\nprint(p15)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\casestudy1\\\\utilitymap\\\\\",  \"utilitymap1\", \".png\"), plot=p11, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\casestudy1\\\\utilitymap\\\\\",  \"utilitymap2\", \".png\"), plot=p12, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\casestudy1\\\\utilitymap\\\\\",  \"utilitymap3\", \".png\"), plot=p13, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\casestudy1\\\\utilitymap\\\\\",  \"utilitymap4\", \".png\"), plot=p14, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\casestudy1\\\\utilitymap\\\\\",  \"utilitymap5\", \".png\"), plot=p15, width = 20, height = 20, units = \"cm\")\n\n # The best for XBridge Shield RP18\n\n foo1&lt;-foo[foo$Column==1 & foo$pHo&lt;7,];\n foo1[which(foo1$EUtility==max(foo1$EUtility)),c('tg','fio', 'fik','Mod', 'pHid','pHo','Temp','ColumnName','EUtility')]\n\n\n# A tibble: 1 x 9\n     tg   fio   fik Mod    pHid   pHo  Temp ColumnName          EUtility\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;\n1    60  0.05   0.8 ACN      10  5.50    25 XBridge Shield RP18     11.4\n\n\nCode\n # The best choice for XTerra MS C18\n\n foo2&lt;-foo[foo$Column==2& foo$pHo&lt;7,];\n foo2[which(foo2$EUtility==max(foo2$EUtility)),c('tg','fio', 'fik','Mod', 'pHid','pHo','Temp','ColumnName','EUtility')]\n\n\n# A tibble: 1 x 9\n     tg   fio   fik Mod    pHid   pHo  Temp ColumnName    EUtility\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;            &lt;dbl&gt;\n1    60  0.05   0.8 ACN      10  5.50    25 XTerra MS C18     9.50\n\n\nCode\n  # The best choice for XBridge Phenyl\n\n foo3&lt;-foo[foo$Column==3& foo$pHo&lt;7,];\n foo3[which(foo3$EUtility==max(foo3$EUtility)),c('tg','fio', 'fik','Mod', 'pHid','pHo','Temp','ColumnName','EUtility')]\n\n\n# A tibble: 1 x 9\n     tg   fio   fik Mod    pHid   pHo  Temp ColumnName     EUtility\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;             &lt;dbl&gt;\n1    40  0.15   0.8 MeOH     12  6.00    25 XBridge Phenyl     4.08\n\n\nCode\n  # The best choice for XBridge C8\n\n foo4&lt;-foo[foo$Column==4& foo$pHo&lt;7,];\n foo4[which(foo4$EUtility==max(foo4$EUtility)),c('tg','fio', 'fik','Mod', 'pHid','pHo','Temp','ColumnName','EUtility')]\n\n\n# A tibble: 1 x 9\n     tg   fio   fik Mod    pHid   pHo  Temp ColumnName EUtility\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;         &lt;dbl&gt;\n1    80  0.05   0.8 ACN       5  4.00    25 XBridge C8     7.73\n\n\nCode\n  # The best choice for Xterra MS C8\n\n foo5&lt;-foo[foo$Column==5& foo$pHo&lt;7,];\n foo5[which(foo5$EUtility==max(foo5$EUtility)),c('tg','fio', 'fik','Mod', 'pHid','pHo','Temp','ColumnName','EUtility')]\n\n\n# A tibble: 1 x 9\n     tg   fio   fik Mod    pHid   pHo  Temp ColumnName   EUtility\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;           &lt;dbl&gt;\n1    80   0.1   0.8 ACN       5  4.00    25 Xterra MS C8     13.7\n\n\n\nUncertainity chromatogram\nLet’s visualize chromatograms with the highest expected utility\n\n\nCode\nanalyte_ID_sample &lt;-c(9,17,33,58,140,180)\ncol.labs &lt;- c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\")\ndatasim_red$fio = as.factor(datasim_red$fio)\n\nwpCond= data.frame()\n\nfor (i in 1:5) {\nidx &lt;- which(datasim_red$METID %in% analyte_ID_sample &\n               datasim_red$tg == 60 & # c(30, 90, 270)\n               datasim_red$pHid == 10 &   # c(1:9)\n               datasim_red$fio == 0.05 &   # ...\n               datasim_red$Column == i &  # c(1, 2)\n               datasim_red$Mod2 == 2 & # c(1, 2)\n               datasim_red$Temp == 25) # c(25, 35)\n\nif (i==3){\n\n idx &lt;- which(datasim_red$METID %in% analyte_ID_sample &\n               datasim_red$tg == 60 & # c(30, 90, 270)\n               datasim_red$pHid == 6 &   # c(1:9)\n               datasim_red$fio == 0.1 &   # ...\n               datasim_red$Column == i &  # c(1, 2)\n               datasim_red$Mod2 == 2 & # c(1, 2)\n               datasim_red$Temp == 25) # c(25, 35)\n\n}\n\nif (i==4){\n\n idx &lt;- which(datasim_red$METID %in% analyte_ID_sample &\n               datasim_red$tg == 80 & # c(30, 90, 270)\n               datasim_red$pHid == 5 &   # c(1:9)\n               datasim_red$fio == 0.05 &   # ...\n               datasim_red$Column == i &  # c(1, 2)\n               datasim_red$Mod2 == 2 & # c(1, 2)\n               datasim_red$Temp == 25) # c(25, 35)\n\n}\n\nif (i==5){\n\n idx &lt;- which(datasim_red$METID %in% analyte_ID_sample &\n               datasim_red$tg == 80 & # c(30, 90, 270)\n               datasim_red$pHid == 5 &   # c(1:9)\n               datasim_red$fio == 0.1 &   # ...\n               datasim_red$Column == i &  # c(1, 2)\n               datasim_red$Mod2 == 2 & # c(1, 2)\n               datasim_red$Temp == 25) # c(25, 35)\n}\n\ndata_to_plot &lt;- draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% paste0(\"trHatCond[\",idx,\"]\"))]\n\ncolnames(data_to_plot) &lt;- paste(dataNames$Name[analyte_ID_sample])\nwpCond1 &lt;- melt(data_to_plot)\nwpCond1$Column &lt;- unname(col.labs[i])\nwpCond= rbind(wpCond,wpCond1)\n\nwpCond$Column=as.factor(wpCond$Column)\n\np &lt;- ggplot(data = wpCond)+\n     geom_density(aes(x=value, colour=variable)) +\n     labs(title=\"uncertainty chromatogram (individual predictions)\",\n          x =\"Retention time, min\",\n          y = \"pdf\",\n          colour=\"Analyte\"\n          )+\n     xlim(c(0,80))+\n     facet_wrap(.~Column, nrow=3,scales = \"free\")+\n     theme(legend.position = c(1, 0),\n        legend.justification = c(1, 0))\n\nprint(p)\n\nggsave(paste0(\"figures\\\\casestudy1\\\\utilitymap\\\\\",  \"chromatogram\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")\n\n}"
  },
  {
    "objectID": "index.html#summary-of-individual-parameters",
    "href": "index.html#summary-of-individual-parameters",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Summary of individual parameters",
    "text": "Summary of individual parameters\nHere shown for analyte 9 (Baclofen)\n\n\nCode\n# which(unique(data$METID)==9) - 3rd compound in stan\n\nfit_red$print(c(\"logkwx[3,1,1]\", \"logkwx[3,1,2]\", \"logkwx[3,1,3]\",\n                \"logkwx[3,2,1]\", \"logkwx[3,2,2]\", \"logkwx[3,2,3]\",\n                \"S1x[3,1,1,1]\", \"S1x[3,1,1,2]\", \"S1x[3,1,1,3]\",\n                \"S1x[3,2,1,1]\", \"S1x[3,2,1,2]\", \"S1x[3,2,1,3]\",\n                \"S1x[3,1,2,1]\", \"S1x[3,1,2,2]\", \"S1x[3,1,2,3]\",\n                \"S1x[3,2,2,1]\", \"S1x[3,2,2,2]\", \"S1x[3,2,2,3]\",\n                \"apHx[3,1,1]\", \"apHx[3,1,2]\", \"apHx[3,1,3]\",\n                \"pKawx[3,1]\", \"pKawx[3,2]\",\n                \"alphax[3,1,1]\", \"alphax[3,1,2]\",\n                \"alphax[3,2,1]\", \"alphax[3,2,2]\",\n                \"S2x[1,1]\", \"S2x[2,1]\",\n                \"sigmax[3,1]\", \"sigmax[3,2]\"), max_rows = 31)\n\n\n      variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n logkwx[3,1,1]  1.86   1.85 0.93 0.92  0.35  3.37 1.00     2529     1615\n logkwx[3,1,2]  1.09   1.11 1.10 1.08 -0.74  2.93 1.00     2787     1492\n logkwx[3,1,3]  1.09   1.11 1.10 1.08 -0.74  2.93 1.00     2787     1492\n logkwx[3,2,1]  2.28   2.28 0.94 0.93  0.73  3.81 1.00     2566     1563\n logkwx[3,2,2]  1.56   1.59 1.11 1.12 -0.29  3.38 1.00     2831     1587\n logkwx[3,2,3]  1.56   1.59 1.11 1.12 -0.29  3.38 1.00     2831     1587\n S1x[3,1,1,1]   3.88   3.88 0.98 0.99  2.28  5.47 1.00     2252     1400\n S1x[3,1,1,2]   4.07   4.08 1.21 1.24  2.11  6.02 1.00     2970     1570\n S1x[3,1,1,3]   4.07   4.08 1.21 1.24  2.11  6.02 1.00     2970     1570\n S1x[3,2,1,1]   4.50   4.49 1.16 1.15  2.54  6.45 1.00     2274     1222\n S1x[3,2,1,2]   4.99   5.03 1.48 1.49  2.54  7.35 1.00     2970     1545\n S1x[3,2,1,3]   4.99   5.03 1.48 1.49  2.54  7.35 1.00     2970     1545\n S1x[3,1,2,1]   4.61   4.61 0.98 0.98  3.00  6.20 1.00     2245     1382\n S1x[3,1,2,2]   4.79   4.80 1.21 1.22  2.84  6.70 1.00     2941     1706\n S1x[3,1,2,3]   4.79   4.80 1.21 1.22  2.84  6.70 1.00     2941     1706\n S1x[3,2,2,1]   5.39   5.39 1.17 1.16  3.46  7.34 1.00     2331     1324\n S1x[3,2,2,2]   5.91   5.92 1.49 1.47  3.46  8.30 1.00     2872     1544\n S1x[3,2,2,3]   5.91   5.92 1.49 1.47  3.46  8.30 1.00     2872     1544\n apHx[3,1,1]    0.00   0.00 0.00 0.00  0.00  0.00   NA       NA       NA\n apHx[3,1,2]   -0.03  -0.03 0.00 0.00 -0.03 -0.03 1.00     2097     1267\n apHx[3,1,3]   -0.03  -0.03 0.00 0.00 -0.03 -0.03 1.00     2097     1267\n pKawx[3,1]     7.35   7.35 0.87 0.86  5.97  8.71 1.00     5293     1413\n pKawx[3,2]     0.00   0.00 0.00 0.00  0.00  0.00   NA       NA       NA\n alphax[3,1,1]  2.20   2.20 0.99 0.97  0.59  3.84 1.01     4318     1276\n alphax[3,1,2]  0.00   0.00 0.00 0.00  0.00  0.00   NA       NA       NA\n alphax[3,2,1]  2.38   2.41 1.29 1.27  0.17  4.46 1.01     4760     1525\n alphax[3,2,2]  0.00   0.00 0.00 0.00  0.00  0.00   NA       NA       NA\n S2x[1,1]       0.47   0.47 0.01 0.01  0.44  0.49 1.00     1556     1617\n S2x[2,1]       1.20   1.20 0.04 0.04  1.13  1.26 1.00     1020     1252\n sigmax[3,1]    0.53   0.39 0.47 0.30  0.11  1.36 1.00     4335     1335\n sigmax[3,2]    0.64   0.48 0.58 0.36  0.13  1.66 1.00     4345     1331"
  },
  {
    "objectID": "index.html#predicted-retention-times",
    "href": "index.html#predicted-retention-times",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Predicted retention times",
    "text": "Predicted retention times\n\n\nCode\nanalyte_ID_sample =  c(9,17,33,58,140,180)\nidx &lt;- which(datasim$METID %in% analyte_ID_sample)\ndatasim_red = datasim[idx,1:20]\ndatastructsim_red &lt;-datastructsim\ndatastructsim_red$nObs=length(datastructsim_red$analyte[idx])\ndatastructsim_red$analyte=datastructsim_red$analyte[idx]\ndatastructsim_red$modifier=datastructsim_red$modifier[idx]\ndatastructsim_red$steps=datastructsim_red$steps[idx]\ndatastructsim_red$column=datastructsim_red$column[idx]\ndatastructsim_red$hplcparam=datastructsim_red$hplcparam[idx,]\ndatastructsim_red$trobs = rep(0,datastructsim_red$nObs)\ndatastructsim_red$nexpid=length(unique(datasim_red$expid))\ndatastructsim_red$expid=match(datasim_red$expid, unique(datasim_red$expid))\ndatastructsim_red$nAnalytessim=length(unique(datastructsim_red$analyte))\ndatastructsim_red$analytesim=match(datastructsim_red$analyte, unique(datastructsim_red$analyte))\n\n\n\n\nCode\nmodel_sim_red &lt;- cmdstan_model(\"stan/hplc-gra-fivecolumns-fixed-sim.stan\")\n\nfit_sim_red  &lt;- model_sim_red$generate_quantities(fit_red,\n                                         data = datastructsim_red,\n                                         seed = 123,\n                                         parallel_chains = 4,\n                                         output_dir = \"stanfiles\")\n\n\n\n\nCode\nx&lt;- cmdstanr::read_cmdstan_csv(c(\n                                  'stanfiles/hplc-gra-fivecolumns-fixed-sim-202308091209-1-392f75.csv',\n                                  'stanfiles/hplc-gra-fivecolumns-fixed-sim-202308091209-2-392f75.csv',\n                                  'stanfiles/hplc-gra-fivecolumns-fixed-sim-202308091209-3-392f75.csv',\n                                  'stanfiles/hplc-gra-fivecolumns-fixed-sim-202308091209-4-392f75.csv'\n                                ))\n\ndraws_sim_red_df &lt;- as_draws_df(x$generated_quantities)\n#draws_sim_red_df &lt;- fit_sim_red$draws(format = \"df\")\n\n\n\nPlot the predicted vs. observed:\n\n\nCode\ntr_sim_red_Cond &lt;- apply(draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep(\"^trCond\", names(draws_sim_red_df), value = TRUE))], MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))\n\ntr_sim_Cond&lt;-as.data.frame(t(tr_sim_red_Cond))\n\ndatasim_red$trCond_l=tr_sim_Cond$`5%`\ndatasim_red$trCond_m=tr_sim_Cond$`50%`\ndatasim_red$trCond_h=tr_sim_Cond$`95%`\n\nidx &lt;- which(data$METID %in% analyte_ID_sample &\n               data$tg %in% c(30, 90, 270) &\n               data$pH %in% c(1:9) &\n               data$Column %in% c(1) &  # c(1, 2)\n               data$Mod2 %in% c(1, 2) &\n               data$Temp %in% c(25, 35))\n\ndata_red = data[idx,]\n\nfor(i in 1:length(analyte_ID_sample)){\n\npi &lt;- ggplot()+\n      geom_point(data=data[which(data$METID %in% analyte_ID_sample[i]),], aes(x = pHs, y = RT, color = as.factor(tg)), shape = 1)+\n      geom_point(data=data_red[which(data_red$METID %in% analyte_ID_sample[i]),], aes(x = pHs, y = RT, color = as.factor(tg)))+\n\n     geom_line(data=datasim_red[which(datasim_red$METID %in% analyte_ID_sample[i]),], aes(x = pHs, y = trCond_m, color = as.factor(tg)))+\n\n     geom_ribbon(data=datasim_red[which(datasim_red$METID %in% analyte_ID_sample[i]),], aes(x = pHs, ymin = trCond_l, ymax = trCond_h, fill = as.factor(tg)), alpha = 0.25)+\n\n  xlim(2,11)+\n\nfacet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+\n\n      labs(title=paste(dataNames$Name[analyte_ID_sample[i]]), x =\"pH\", y = \"Retention time, min\", color = \"tg, min\", fill = \"tg, min\")\n\nprint(pi)\n\nggsave(paste0(\"figures\\\\casestudy2\\\\concordanceplots\\\\\", paste(dataNames$Name[analyte_ID_sample[i]]), \".IndividualPredictions\", \".png\"), plot=pi, width = 20, height = 20, units = \"cm\")\n\n}"
  },
  {
    "objectID": "index.html#decision-making",
    "href": "index.html#decision-making",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Decision making",
    "text": "Decision making\nThe same utility function was used:\n\n\nCode\nfoo&lt;-datasim_red[!duplicated(datasim_red$expid),]\n\nx&lt;-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep(\"^mindifftr\", names(draws_sim_red_df), value = TRUE))]\n\ny&lt;-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep(\"^maxtr\", names(draws_sim_red_df), value = TRUE))]\n\nz&lt;-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep(\"^mintr\", names(draws_sim_red_df), value = TRUE))]\n\nu=x;\n\nfor (i in 1:ncol(x)){u[,i] &lt;- as.numeric(x[,i]&gt;2 & z[,i] &gt; 2) * (40-y[,i]) * as.numeric(y[,i]&lt;40)}\nu &lt;- apply(u, MARGIN = 2, FUN = mean)\nu&lt;-as.data.frame(u)\n\nfoo$EUtility=u$u\nx &lt;- apply(x, MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))\nx&lt;-as.data.frame(t(x))\n\nfoo$mindifftr_l=x$`5%`\nfoo$mindifftr_m=x$`50%`\nfoo$mindifftr_h=x$`95%`\n\ny &lt;- apply(y, MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))\n\ny&lt;-as.data.frame(t(y))\nfoo$maxtr_l=y$`5%`\nfoo$maxtr_m=y$`50%`\nfoo$maxtr_h=y$`95%`\n\np1 &lt;- ggplot()+\n     geom_line(data=foo, aes(x = pHs, y = EUtility, color = as.factor(tg)))+\n     xlim(2,11)+\n     facet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"Expected Utility\",\n          color = \"tg, min\")\n\nprint(p1)\n\n\n\n\n\nCode\np2 &lt;- ggplot()+\n     geom_line(data=foo, aes(x = pHs, y = mindifftr_m, color = as.factor(tg)))+\n     geom_ribbon(data=foo, aes(x = pHs, ymin = mindifftr_l, ymax = mindifftr_h, fill = as.factor(tg)), alpha = 0.25)+\n     xlim(2,11)+\n     facet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"Resolution (difference), min\",\n          color = \"tg, min\",\n          fill = \"tg, min\")\n\nprint(p2)\n\n\n\n\n\nCode\np3 &lt;- ggplot()+\n     geom_line(data=foo, aes(x = pHs, y = maxtr_m, color = as.factor(tg)))+\n  geom_ribbon(data=foo, aes(x = pHs, ymin = maxtr_l, ymax = maxtr_h, fill = as.factor(tg)), alpha = 0.25)+\n     xlim(2,11)+\n     facet_grid(ColumnName~Mod2+Temp, labeller = labeller(Temp=temp.labs,Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"Maximal tR, min\",\n          color = \"tg, min\",\n          fill = \"tg, min\")\n\nprint(p3)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\casestudy2\\\\decision\\\\\", \"ExpectedUtility\", \".png\"), plot=p1, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\casestudy2\\\\decision\\\\\",  \"Resolution\", \".png\"), plot=p2, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\casestudy2\\\\decision\\\\\",  \"maxtr\", \".png\"), plot=p3, width = 20, height = 20, units = \"cm\")\n\n # The best for XBridge Shield RP18\n foo1&lt;-foo[foo$Column==1,];\n foo1[which(foo1$EUtility==max(foo1$EUtility)),c('tg','fio', 'fik','Mod', 'pH','pHo','Temp','ColumnName','EUtility')]\n\n\n    tg  fio fik Mod pH     pHo Temp          ColumnName EUtility\n158 90 0.05 0.8 ACN  7 8.87588   25 XBridge Shield RP18 1.611051\n\n\nCode\n # The best choice for XTerra MS C18\n foo2&lt;-foo[foo$Column==2,];\n foo2[which(foo2$EUtility==max(foo2$EUtility)),c('tg','fio', 'fik','Mod', 'pH','pHo','Temp','ColumnName','EUtility')]\n\n\n      tg  fio fik Mod pH      pHo Temp    ColumnName EUtility\n15404 90 0.05 0.8 ACN  3 4.202902   35 XTerra MS C18 1.377401\n\n\nCode\n  # The best choice for XBridge Phenyl\n foo3&lt;-foo[foo$Column==3,];\n foo3[which(foo3$EUtility==max(foo3$EUtility)),c('tg','fio', 'fik','Mod', 'pH','pHo','Temp','ColumnName','EUtility')]\n\n\n      tg  fio fik Mod pH      pHo Temp     ColumnName EUtility\n30632 90 0.05 0.8 ACN  3 4.202902   35 XBridge Phenyl 1.596929\n\n\nCode\n  # The best choice for XBridge C8\n foo4&lt;-foo[foo$Column==4,];\n foo4[which(foo4$EUtility==max(foo4$EUtility)),c('tg','fio', 'fik','Mod', 'pH','pHo','Temp','ColumnName','EUtility')]\n\n\n      tg  fio fik Mod pH      pHo Temp ColumnName EUtility\n45860 90 0.05 0.8 ACN  3 4.202902   35 XBridge C8 1.880014\n\n\nCode\n  # The best choice for Xterra MS C8\n foo5&lt;-foo[foo$Column==5,];\n foo5[which(foo5$EUtility==max(foo5$EUtility)),c('tg','fio', 'fik','Mod', 'pH','pHo','Temp','ColumnName','EUtility')]\n\n\n      tg  fio fik Mod pH      pHo Temp   ColumnName EUtility\n61088 90 0.05 0.8 ACN  3 4.202902   35 Xterra MS C8 1.577515\n\n\n\nuncertainity chromatogram\nBelow is the example of a chromatogram (along with uncertainty) expected for tg = 90 min, pH = 8.9, Temp = 25oC in ACN.\n\n\nCode\nanalyte_ID_sample &lt;-c(9,17,33,58,140,180)\n\ncol.labs &lt;- c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\")\n\nwpCond= data.frame()\n\nfor (i in 1:5) {\n\nidx &lt;- which(datasim_red$METID %in% analyte_ID_sample &\n               datasim_red$tg==90 & # c(30, 90, 270)\n               datasim_red$pH== 7 &   # c(1:9)\n               datasim_red$Column==i &  # c(1, 2)\n               datasim_red$Mod2==2 & # c(1, 2)\n               datasim_red$Temp==25) # c(25, 35)\n\ndata_to_plot &lt;- draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% paste0(\"trHatCond[\",idx,\"]\"))]\n\ncolnames(data_to_plot) &lt;- paste(dataNames$Name[analyte_ID_sample])\n\nwpCond1 &lt;- melt(data_to_plot)\nwpCond1$Column &lt;- unname(col.labs[i])\nwpCond= rbind(wpCond,wpCond1)\n\n}\n\nwpCond$Column=as.factor(wpCond$Column)\np &lt;- ggplot(data = wpCond)+\n     geom_density(aes(x=value, colour=variable)) +\n     labs(title=\"uncertainty chromatogram (limited data preditions)\",\n          x =\"Retention Time, min\",\n          y = \"pdf\",\n          colour=\"Analyte\")+\n     xlim(c(0,80))+\n     facet_wrap(.~Column, nrow=3,scales = \"free\")+\n     theme(legend.position = c(1, 0),\n     legend.justification = c(1, 0))\n\nprint(p)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\casestudy2\\\\decision\\\\\",  \"Chromatogram\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")"
  },
  {
    "objectID": "index.html#utility-maps-1",
    "href": "index.html#utility-maps-1",
    "title": "Comparison of chromatographic stationary phases using Bayesian-based multilevel modeling",
    "section": "Utility maps",
    "text": "Utility maps\nWe can also determine more detailed graph presenting relationship between the expected utility and design variables:\n\n\nCode\nupH &lt;- datasim %&gt;%\n  select(1:20) %&gt;%\n  distinct(Temp,Mod, pHo, alpha1, alpha2) %&gt;%\n  group_by(Temp,Mod) %&gt;%\n  tidyr::complete(pHo = seq(min(pHo), max(pHo), len = 17)) %&gt;%\n  arrange(Temp,Mod,pHo) %&gt;%\n  mutate(alpha1 = zoo::na.approx(alpha1,pHo)) %&gt;%\n  mutate(alpha2 = zoo::na.approx(alpha2,pHo)) %&gt;%\n  group_by(Temp,Mod) %&gt;%\n  mutate(pHid = row_number()) %&gt;%\n  group_by(pHid)  %&gt;%\n  mutate(pHs = round(mean(pHo),2)) %&gt;%\n  ungroup()\n\ndatasim2 &lt;- datasim %&gt;%\n  select(1:20) %&gt;%\n  filter(tg==30, Temp==25) %&gt;%\n  select(-tg, -fio, -expid, -pHs, -pHo, -alpha1, -alpha2, -pH) %&gt;%\n  distinct() %&gt;%\n tidyr::expand_grid(fio = seq(0.05,0.2,0.05),tg = seq(20,260,20), pHs=unique(upH$pHs))%&gt;%\n  left_join(upH, by = join_by(pHs, Mod, Temp), relationship = \"many-to-one\") %&gt;%\n  group_by(tg, fio, Mod, Column, pHs) %&gt;%\n  mutate(expid = cur_group_id()) %&gt;%\n  ungroup()\ndatastructsim2 &lt;-datastruct\ndatastructsim2$nObs=length(datasim2$METID)\ndatastructsim2$analyte=match(datasim2$METID, unique(datasim2$METID))\ndatastructsim2$modifier=match(datasim2$Mod2, sort(unique(datasim2$Mod2)))\ndatastructsim2$steps=4*(2-datasim2$Mod2) + 10*(datasim2$Mod2-1)\ndatastructsim2$column=match(datasim2$Column, unique(datasim2$Column))\ndatastructsim2$hplcparam=cbind(datasim2$tg,datasim2$td,datasim2$to,datasim2$te,\n                              datasim2$fio,datasim2$fik,datasim2$Mod2-1,datasim2$pHo,\n                              datasim2$alpha1,datasim2$alpha2,(datasim2$Temp-25)/10,\n                              datasim2$Column-1)\ndatastructsim2$trobs = rep(0,datastructsim2$nObs)\nanalyte_ID_sample =  c(9,17,33,58,140,180)\nidx &lt;- which(datasim2$METID %in% analyte_ID_sample)\ndatasim_red = datasim2[idx,]\ndatastructsim_red &lt;-datastructsim2\ndatastructsim_red$nObs=length(datastructsim_red$analyte[idx])\ndatastructsim_red$analyte=datastructsim_red$analyte[idx]\ndatastructsim_red$modifier=datastructsim_red$modifier[idx]\ndatastructsim_red$steps=datastructsim_red$steps[idx]\ndatastructsim_red$column=datastructsim_red$column[idx]\ndatastructsim_red$hplcparam=datastructsim_red$hplcparam[idx,]\ndatastructsim_red$trobs = rep(0,datastructsim_red$nObs)\ndatastructsim_red$nexpid=length(unique(datasim_red$expid))\ndatastructsim_red$expid=match(datasim_red$expid, unique(datasim_red$expid))\ndatastructsim_red$nAnalytessim=length(unique(datastructsim_red$analyte))\ndatastructsim_red$analytesim=match(datastructsim_red$analyte, unique(datastructsim_red$analyte))\n\n\n\n\nCode\nmodel_sim_red &lt;- cmdstan_model(\"stan/hplc-gra-fivecolumns-fixed-sim.stan\")\nfit_sim_red  &lt;- model_sim_red$generate_quantities(fit_red,\n                                         data = datastructsim_red,\n                                         seed = 123,\n                                         parallel_chains = 4,\n                                         output_dir = \"stanfiles\")\n\n\n\n\nCode\nx&lt;- cmdstanr::read_cmdstan_csv(c(\n                                  'stanfiles/hplc-gra-fivecolumns-fixed-sim-202308091217-1-637877.csv'\n                                ))\n\ndraws_sim_red_df &lt;- as_draws_df(x$generated_quantities)\n#draws_sim_red_df &lt;- fit_sim_red$draws(format = \"df\")\n\n\nThe best chromatogram can be sought based on utility map:\n\n\nCode\nfoo&lt;-datasim_red[!duplicated(datasim_red$expid),]\n\nx&lt;-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep(\"^mindifftr\", names(draws_sim_red_df), value = TRUE))]\ny&lt;-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep(\"^maxtr\", names(draws_sim_red_df), value = TRUE))]\nz&lt;-draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% grep(\"^mintr\", names(draws_sim_red_df), value = TRUE))]\n\nu=x;\n\nfor (i in 1:ncol(x)){u[,i] &lt;- as.numeric(x[,i]&gt;2 & z[,i] &gt; 2) * (40-y[,i]) * as.numeric(y[,i]&lt;40)}\n\npr &lt;- apply(u, MARGIN = 2, FUN = mean)\n\npr&lt;-as.data.frame(pr)\n\nfoo$EUtility=pr$pr\n\nx &lt;- apply(x, MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))\n\nx&lt;-as.data.frame(t(x))\n\nfoo$mindifftr_l=x$`5%`\nfoo$mindifftr_m=x$`50%`\nfoo$mindifftr_h=x$`95%`\n\ny &lt;- apply(y, MARGIN = 2, FUN = quantile, probs = c(.05,.5,.95))\n\ny&lt;-as.data.frame(t(y))\n\nfoo$maxtr_l=y$`5%`\nfoo$maxtr_m=y$`50%`\nfoo$maxtr_h=y$`95%`\n\np11 &lt;- ggplot()+\n     geom_contour_filled(data=subset(foo,Column==1), aes(x = pHs, y=tg, z = EUtility))+\n     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"tg, min\",\n          fill = \"Expected Utility\")\n\nprint(p11)\n\n\n\n\n\nCode\np12 &lt;- ggplot()+\n     geom_contour_filled(data=subset(foo,Column==2), aes(x = pHs, y=tg, z = EUtility))+\n     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"tg, min\",\n          fill = \"Expected Utility\")\n\nprint(p12)\n\n\n\n\n\nCode\np13 &lt;- ggplot()+\n     geom_contour_filled(data=subset(foo,Column==3), aes(x = pHs, y=tg, z = EUtility))+\n     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"tg, min\",\n          fill = \"Expected Utility\")\n\nprint(p13)\n\n\n\n\n\nCode\np14 &lt;- ggplot()+\n     geom_contour_filled(data=subset(foo,Column==4), aes(x = pHs, y=tg, z = EUtility))+\n     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"tg, min\",\n          fill = \"Expected Utility\")\n\nprint(p14)\n\n\n\n\n\nCode\np15 &lt;- ggplot()+\n     geom_contour_filled(data=subset(foo,Column==5), aes(x = pHs, y=tg, z = EUtility))+\n     facet_grid(fio~Mod2+ColumnName, labeller = labeller(Mod2=mod.labs))+\n     labs(x =\"pH\",\n          y = \"tg, min\",\n          fill = \"Expected Utility\")\n\nprint(p15)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\casestudy2\\\\utylitymap\\\\\",  \"utylitymap1\", \".png\"), plot=p11, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\casestudy2\\\\utylitymap\\\\\",  \"utylitymap2\", \".png\"), plot=p12, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\casestudy2\\\\utylitymap\\\\\",  \"utylitymap3\", \".png\"), plot=p13, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\casestudy2\\\\utylitymap\\\\\",  \"utylitymap4\", \".png\"), plot=p14, width = 20, height = 20, units = \"cm\")\nggsave(paste0(\"figures\\\\casestudy2\\\\utylitymap\\\\\",  \"utylitymap5\", \".png\"), plot=p15, width = 20, height = 20, units = \"cm\")\n\n # The best for XBridge Shield RP18\n foo1&lt;-foo[foo$Column==1,];\n foo1[which(foo1$EUtility==max(foo1$EUtility)),c('tg','fio', 'fik','Mod', 'pHid','pHo','Temp','ColumnName','EUtility')]\n\n\n# A tibble: 1 x 9\n     tg   fio   fik Mod    pHid   pHo  Temp ColumnName          EUtility\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;                  &lt;dbl&gt;\n1    60  0.05   0.8 ACN      10  5.50    25 XBridge Shield RP18     10.4\n\n\nCode\n # The best choice for XTerra MS C18\n foo2&lt;-foo[foo$Column==2,];\n foo2[which(foo2$EUtility==max(foo2$EUtility)),c('tg','fio', 'fik','Mod', 'pHid','pHo','Temp','ColumnName','EUtility')]\n\n\n# A tibble: 1 x 9\n     tg   fio   fik Mod    pHid   pHo  Temp ColumnName    EUtility\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;            &lt;dbl&gt;\n1    80   0.1   0.8 ACN       5  4.00    25 XTerra MS C18     2.69\n\n\nCode\n  # The best choice for XBridge Phenyl\n foo3&lt;-foo[foo$Column==3,];\n foo3[which(foo3$EUtility==max(foo3$EUtility)),c('tg','fio', 'fik','Mod', 'pHid','pHo','Temp','ColumnName','EUtility')]\n\n\n# A tibble: 1 x 9\n     tg   fio   fik Mod    pHid   pHo  Temp ColumnName     EUtility\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;             &lt;dbl&gt;\n1   120   0.1   0.8 ACN       5  4.00    25 XBridge Phenyl     2.36\n\n\nCode\n  # The best choice for XBridge C8\n foo4&lt;-foo[foo$Column==4,];\n foo4[which(foo4$EUtility==max(foo4$EUtility)),c('tg','fio', 'fik','Mod', 'pHid','pHo','Temp','ColumnName','EUtility')]\n\n\n# A tibble: 1 x 9\n     tg   fio   fik Mod    pHid   pHo  Temp ColumnName EUtility\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;         &lt;dbl&gt;\n1    80  0.05   0.8 ACN       5  4.00    25 XBridge C8     1.74\n\n\nCode\n  # The best choice for Xterra MS C8\n foo5&lt;-foo[foo$Column==5,];\n foo5[which(foo5$EUtility==max(foo5$EUtility)),c('tg','fio', 'fik','Mod', 'pHid','pHo','Temp','ColumnName','EUtility')]\n\n\n# A tibble: 1 x 9\n     tg   fio   fik Mod    pHid   pHo  Temp ColumnName   EUtility\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;chr&gt;           &lt;dbl&gt;\n1    80   0.1   0.8 ACN       6  4.17    25 Xterra MS C8     2.39\n\n\n\nuncertainity chromatogram\nLet’s visualize chromatograms with the highest expected utility given the experimental data.\n\n\nCode\nanalyte_ID_sample &lt;-c(9,17,33,58,140,180)\n\ncol.labs &lt;- c(\"XBridge Shield RP18\",\"XTerra MS C18\", \"XBridge Phenyl\", \"XBridge C8\", \"Xterra MS C8\")\n\ndatasim_red$fio = as.factor(datasim_red$fio)\n\nwpCond= data.frame()\n\nfor (i in 1:5) {\n\nidx &lt;- which(datasim_red$METID %in% analyte_ID_sample &\n               datasim_red$tg == 60 & # c(30, 90, 270)\n               datasim_red$pHid == 10 &   # c(1:9)\n               datasim_red$fio == 0.05 &   # ...\n               datasim_red$Column == i &  # c(1, 2)\n               datasim_red$Mod2 == 2 & # c(1, 2)\n               datasim_red$Temp == 25) # c(25, 35)\n\nif (i==2){\n\n idx &lt;- which(datasim_red$METID %in% analyte_ID_sample &\n               datasim_red$tg == 80 & # c(30, 90, 270)\n               datasim_red$pHid == 5 &   # c(1:9)\n               datasim_red$fio == 0.1 &   # ...\n               datasim_red$Column == i &  # c(1, 2)\n               datasim_red$Mod2 == 2 & # c(1, 2)\n               datasim_red$Temp == 25) # c(25, 35)\n\n}\n\nif (i==3){\n\n idx &lt;- which(datasim_red$METID %in% analyte_ID_sample &\n               datasim_red$tg == 120 & # c(30, 90, 270)\n               datasim_red$pHid == 5 &   # c(1:9)\n               datasim_red$fio == 0.1 &   # ...\n               datasim_red$Column == i &  # c(1, 2)\n               datasim_red$Mod2 == 2 & # c(1, 2)\n               datasim_red$Temp == 25) # c(25, 35)\n\n}\n\nif (i==4){\n\n idx &lt;- which(datasim_red$METID %in% analyte_ID_sample &\n               datasim_red$tg == 100 & # c(30, 90, 270)\n               datasim_red$pHid == 5 &   # c(1:9)\n               datasim_red$fio == 0.05 &   # ...\n               datasim_red$Column == i &  # c(1, 2)\n               datasim_red$Mod2 == 2 & # c(1, 2)\n               datasim_red$Temp == 25) # c(25, 35)\n\n}\n\nif (i==5){\n\n idx &lt;- which(datasim_red$METID %in% analyte_ID_sample &\n               datasim_red$tg == 100 & # c(30, 90, 270)\n               datasim_red$pHid == 6 &   # c(1:9)\n               datasim_red$fio == 0.1 &   # ...\n               datasim_red$Column == i &  # c(1, 2)\n               datasim_red$Mod2 == 2 & # c(1, 2)\n               datasim_red$Temp == 25) # c(25, 35)\n\n}\n\n data_to_plot &lt;- draws_sim_red_df[,which(colnames(draws_sim_red_df) %in% paste0(\"trHatCond[\",idx,\"]\"))]\n colnames(data_to_plot) &lt;- paste(dataNames$Name[analyte_ID_sample])\n wpCond1 &lt;- melt(data_to_plot)\nwpCond1$Column &lt;- unname(col.labs[i])\nwpCond= rbind(wpCond,wpCond1)\n\n}\n\nwpCond$Column=as.factor(wpCond$Column)\n\np &lt;- ggplot(data = wpCond)+\n     geom_density(aes(x=value, colour=variable)) +\n     labs(title=\"uncertainty chromatogram (individual predictions)\",\n          x =\"Retention Time, min\",\n          y = \"pdf\",\n          colour=\"Analyte\")+\n     xlim(c(0,80))+\n     facet_wrap(.~Column, nrow=3,scales = \"free\")+\n     theme(legend.position = c(1, 0),\n        legend.justification = c(1, 0))\n\nprint(p)\n\n\n\n\n\nCode\nggsave(paste0(\"figures\\\\casestudy2\\\\utilitymap\\\\\",  \"chromatogram\", \".png\"), plot=p, width = 20, height = 20, units = \"cm\")"
  }
]